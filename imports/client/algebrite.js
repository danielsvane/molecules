// Generated by CoffeeScript 1.10.0
(function() {
  var $, ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARSUBSTRULES, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearsubstrules, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_display, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mag, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_setq, Eval_sgn, Eval_shape, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_LATEX_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MP_MAX_FREE, MP_MIN_SIZE, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PI, POLAR, POWER, PRIME, PRINT, PRINTLATEX, PRINTLIST, PRINTOUTRESULT, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, absValFloat, absval, absval_tensor, ac, ad, add, addSymbolRightOfAssignment, add_all, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, arg, arglist, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, choose, choose_check_args, circexp, clear, clear_symbols, clear_term, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexResultLine, collectPlainResultLine, combine_factors, combine_gammas, combine_terms, compare_numbers, compare_rationals, compare_tensors, compatible, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, echo_input, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, factpoly_expo, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findroot, fixed_top_level_eval, fixup_fraction, fixup_power, flag, fmt_index, fmt_level, fmt_x, frame, free_stack, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_expr, gcd_expr_expr, gcd_factor_term, gcd_main, gcd_numbers, gcd_term_factor, gcd_term_term, gen, getSimpleRoots, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hermite, hilbert, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isSimpleRoot, isSymbolLeftOfAssignment, is_denominator, is_factor, is_small_integer, is_square_matrix, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isnum, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispoly, ispoly_expr, ispoly_factor, ispoly_term, isposint, ispower, isquarterturn, isrational, isspace, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, iszero, itab, laguerre, laguerre2, lastFoundSymbol, latexMode, lcm, leading, legendre, length, lessp, level, list, logarithm, logbuf, lookupsTotal, lu_decomp, madd, mag, makePositive, makeSignSameAs, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_string, newline_flag, nil_symbols, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, numerator, numericRootOfPolynomial, o, one, oneElement, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, peek, peek2, performing_roots, polar, polarRectAMinusOneBase, polycoeff, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print1, print_ABS_latex, print_BINOMIAL_latex, print_DEFINT_latex, print_DOT_latex, print_INV_latex, print_SQRT_latex, print_TRANSPOSE_latex, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_index_function, print_it, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringToBePrinted, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsRightOfAssignment, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, test_dependencies, test_flag, text_metric, theRandom, token, token_buf, token_str, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, ucmp, unique, unique_f, update_token_buf, userSimplificationsInListForm, usr_symbol, verbosing, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymag, yymultiply, yyouter, yypower, yyrationalize, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat,
    slice = [].slice;

  bigInt = require('big-integer');

  SELFTEST = 1;

  NSYM = 1000;

  DEBUG = false;

  PRINTOUTRESULT = false;

  dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;

  recursionLevelNestedRadicalsRemoval = 0;

  do_simplify_nested_radicals = true;

  avoidCalculatingPowersIntoArctans = true;

  rational = (function() {
    function rational() {}

    rational.prototype.a = null;

    rational.prototype.b = null;

    return rational;

  })();

  U = (function() {
    U.prototype.cons = null;

    U.prototype.printname = "";

    U.prototype.str = "";

    U.prototype.tensor = null;

    U.prototype.q = null;

    U.prototype.d = 0.0;

    U.prototype.k = 0;

    U.prototype.tag = 0;

    U.prototype.toString = function() {
      return collectPlainResultLine(this);
    };

    U.prototype.toLatexString = function() {
      return collectLatexResultLine(this);
    };

    function U() {
      this.cons = {};
      this.cons.car = null;
      this.cons.cdr = null;
      this.q = new rational();
    }

    return U;

  })();

  errorMessage = "";

  CONS = 0;

  NUM = 1;

  DOUBLE = 2;

  STR = 3;

  TENSOR = 4;

  SYM = 5;

  counter = 0;

  ABS = counter++;

  ADD = counter++;

  PATTERN = counter++;

  ADJ = counter++;

  AND = counter++;

  ARCCOS = counter++;

  ARCCOSH = counter++;

  ARCSIN = counter++;

  ARCSINH = counter++;

  ARCTAN = counter++;

  ARCTANH = counter++;

  ARG = counter++;

  ATOMIZE = counter++;

  BESSELJ = counter++;

  BESSELY = counter++;

  BINDING = counter++;

  BINOMIAL = counter++;

  CEILING = counter++;

  CHECK = counter++;

  CHOOSE = counter++;

  CIRCEXP = counter++;

  CLEAR = counter++;

  CLEARSUBSTRULES = counter++;

  CLOCK = counter++;

  COEFF = counter++;

  COFACTOR = counter++;

  CONDENSE = counter++;

  CONJ = counter++;

  CONTRACT = counter++;

  COS = counter++;

  COSH = counter++;

  DECOMP = counter++;

  DEFINT = counter++;

  DEGREE = counter++;

  DENOMINATOR = counter++;

  DERIVATIVE = counter++;

  DET = counter++;

  DIM = counter++;

  DIRAC = counter++;

  DISPLAY = counter++;

  DIVISORS = counter++;

  DO = counter++;

  DOT = counter++;

  DRAW = counter++;

  DSOLVE = counter++;

  EIGEN = counter++;

  EIGENVAL = counter++;

  EIGENVEC = counter++;

  ERF = counter++;

  ERFC = counter++;

  EVAL = counter++;

  EXP = counter++;

  EXPAND = counter++;

  EXPCOS = counter++;

  EXPSIN = counter++;

  FACTOR = counter++;

  FACTORIAL = counter++;

  FACTORPOLY = counter++;

  FILTER = counter++;

  FLOATF = counter++;

  FLOOR = counter++;

  FOR = counter++;

  FUNCTION = counter++;

  GAMMA = counter++;

  GCD = counter++;

  HERMITE = counter++;

  HILBERT = counter++;

  IMAG = counter++;

  INDEX = counter++;

  INNER = counter++;

  INTEGRAL = counter++;

  INV = counter++;

  INVG = counter++;

  ISINTEGER = counter++;

  ISPRIME = counter++;

  LAGUERRE = counter++;

  LCM = counter++;

  LEADING = counter++;

  LEGENDRE = counter++;

  LOG = counter++;

  LOOKUP = counter++;

  MAG = counter++;

  MOD = counter++;

  MULTIPLY = counter++;

  NOT = counter++;

  NROOTS = counter++;

  NUMBER = counter++;

  NUMERATOR = counter++;

  OPERATOR = counter++;

  OR = counter++;

  OUTER = counter++;

  POLAR = counter++;

  POWER = counter++;

  PRIME = counter++;

  PRINT = counter++;

  PRINTLATEX = counter++;

  PRINT_LEAVE_E_ALONE = counter++;

  PRINT_LEAVE_X_ALONE = counter++;

  PRINTLIST = counter++;

  PRODUCT = counter++;

  QUOTE = counter++;

  QUOTIENT = counter++;

  RANK = counter++;

  RATIONALIZE = counter++;

  REAL = counter++;

  YYRECT = counter++;

  ROOTS = counter++;

  SETQ = counter++;

  SGN = counter++;

  SIMPLIFY = counter++;

  SIN = counter++;

  SINH = counter++;

  SHAPE = counter++;

  SQRT = counter++;

  STOP = counter++;

  SUBST = counter++;

  SUM = counter++;

  TAN = counter++;

  TANH = counter++;

  TAYLOR = counter++;

  TEST = counter++;

  TESTEQ = counter++;

  TESTGE = counter++;

  TESTGT = counter++;

  TESTLE = counter++;

  TESTLT = counter++;

  TRANSPOSE = counter++;

  UNIT = counter++;

  ZERO = counter++;

  NIL = counter++;

  AUTOEXPAND = counter++;

  BAKE = counter++;

  LAST = counter++;

  LAST_LATEX_PRINT = counter++;

  TRACE = counter++;

  TTY = counter++;

  YYE = counter++;

  DRAWX = counter++;

  METAA = counter++;

  METAB = counter++;

  METAX = counter++;

  SECRETX = counter++;

  PI = counter++;

  SYMBOL_A = counter++;

  SYMBOL_B = counter++;

  SYMBOL_C = counter++;

  SYMBOL_D = counter++;

  SYMBOL_I = counter++;

  SYMBOL_J = counter++;

  SYMBOL_N = counter++;

  SYMBOL_R = counter++;

  SYMBOL_S = counter++;

  SYMBOL_T = counter++;

  SYMBOL_X = counter++;

  SYMBOL_Y = counter++;

  SYMBOL_Z = counter++;

  SYMBOL_IDENTITY_MATRIX = counter++;

  SYMBOL_A_UNDERSCORE = counter++;

  SYMBOL_B_UNDERSCORE = counter++;

  SYMBOL_X_UNDERSCORE = counter++;

  C1 = counter++;

  C2 = counter++;

  C3 = counter++;

  C4 = counter++;

  C5 = counter++;

  C6 = counter++;

  USR_SYMBOLS = counter++;

  E = YYE;

  TOS = 100000;

  BUF = 10000;

  MAX_PROGRAM_SIZE = 100001;

  MAXPRIMETAB = 10000;

  MAXDIM = 24;

  symbolsDependencies = {};

  parse_time_simplifications = true;

  tensor = (function() {
    tensor.prototype.ndim = 0;

    tensor.prototype.dim = null;

    tensor.prototype.nelem = 0;

    tensor.prototype.elem = null;

    function tensor() {
      this.dim = (function() {
        var o, ref, results;
        results = [];
        for (o = 0, ref = MAXDIM; 0 <= ref ? o <= ref : o >= ref; 0 <= ref ? o++ : o--) {
          results.push(0);
        }
        return results;
      })();
      this.elem = [];
    }

    return tensor;

  })();

  display = (function() {
    function display() {}

    display.prototype.h = 0;

    display.prototype.w = 0;

    display.prototype.n = 0;

    display.prototype.a = [];

    return display;

  })();

  text_metric = (function() {
    function text_metric() {}

    text_metric.prototype.ascent = 0;

    text_metric.prototype.descent = 0;

    text_metric.prototype.width = 0;

    return text_metric;

  })();

  tos = 0;

  expanding = 0;

  evaluatingAsFloats = 0;

  fmt_x = 0;

  fmt_index = 0;

  fmt_level = 0;

  verbosing = 0;

  primetab = (function() {
    var ceil, i, j, primes;
    primes = [2];
    i = 3;
    while (primes.length < MAXPRIMETAB) {
      j = 0;
      ceil = Math.sqrt(i);
      while (j < primes.length && primes[j] <= ceil) {
        if (i % primes[j] === 0) {
          j = -1;
          break;
        }
        j++;
      }
      if (j !== -1) {
        primes.push(i);
      }
      i += 2;
    }
    primes[MAXPRIMETAB] = 0;
    return primes;
  })();

  esc_flag = 0;

  draw_flag = 0;

  mtotal = 0;

  trigmode = 0;

  logbuf = "";

  program_buf = "";

  symtab = [];

  binding = [];

  arglist = [];

  stack = [];

  frame = 0;

  p0 = null;

  p1 = null;

  p2 = null;

  p3 = null;

  p4 = null;

  p5 = null;

  p6 = null;

  p7 = null;

  p8 = null;

  p9 = null;

  zero = null;

  one = null;

  imaginaryunit = null;

  symtab = [];

  out_buf = "";

  out_count = 0;

  test_flag = 0;

  draw_stop_return = null;

  userSimplificationsInListForm = [];

  symbol = function(x) {
    return symtab[x];
  };

  iscons = function(p) {
    return p.k === CONS;
  };

  isrational = function(p) {
    return p.k === NUM;
  };

  isdouble = function(p) {
    return p.k === DOUBLE;
  };

  isnum = function(p) {
    return isrational(p) || isdouble(p);
  };

  isstr = function(p) {
    return p.k === STR;
  };

  istensor = function(p) {
    if (p == null) {
      debugger;
    } else {
      return p.k === TENSOR;
    }
  };

  issymbol = function(p) {
    return p.k === SYM;
  };

  iskeyword = function(p) {
    return issymbol(p) && symnum(p) < NIL;
  };

  car = function(p) {
    if (iscons(p)) {
      return p.cons.car;
    } else {
      return symbol(NIL);
    }
  };

  cdr = function(p) {
    if (iscons(p)) {
      return p.cons.cdr;
    } else {
      return symbol(NIL);
    }
  };

  caar = function(p) {
    return car(car(p));
  };

  cadr = function(p) {
    return car(cdr(p));
  };

  cdar = function(p) {
    return cdr(car(p));
  };

  cddr = function(p) {
    return cdr(cdr(p));
  };

  caadr = function(p) {
    return car(car(cdr(p)));
  };

  caddr = function(p) {
    return car(cdr(cdr(p)));
  };

  cadar = function(p) {
    return car(cdr(car(p)));
  };

  cdadr = function(p) {
    return cdr(car(cdr(p)));
  };

  cddar = function(p) {
    return cdr(cdr(car(p)));
  };

  cdddr = function(p) {
    return cdr(cdr(cdr(p)));
  };

  caaddr = function(p) {
    return car(car(cdr(cdr(p))));
  };

  cadadr = function(p) {
    return car(cdr(car(cdr(p))));
  };

  caddar = function(p) {
    return car(cdr(cdr(car(p))));
  };

  cdaddr = function(p) {
    return cdr(car(cdr(cdr(p))));
  };

  cadddr = function(p) {
    return car(cdr(cdr(cdr(p))));
  };

  cddddr = function(p) {
    return cdr(cdr(cdr(cdr(p))));
  };

  caddddr = function(p) {
    return car(cdr(cdr(cdr(cdr(p)))));
  };

  cadaddr = function(p) {
    return car(cdr(car(cdr(cdr(p)))));
  };

  cddaddr = function(p) {
    return cdr(cdr(car(cdr(cdr(p)))));
  };

  caddadr = function(p) {
    return car(cdr(cdr(car(cdr(p)))));
  };

  cdddaddr = function(p) {
    return cdr(cdr(cdr(car(cdr(cdr(p))))));
  };

  caddaddr = function(p) {
    return car(cdr(cdr(car(cdr(cdr(p))))));
  };

  isadd = function(p) {
    return car(p) === symbol(ADD);
  };

  ismultiply = function(p) {
    return car(p) === symbol(MULTIPLY);
  };

  ispower = function(p) {
    return car(p) === symbol(POWER);
  };

  isfactorial = function(p) {
    return car(p) === symbol(FACTORIAL);
  };

  isinnerordot = function(p) {
    return (car(p) === symbol(INNER)) || (car(p) === symbol(DOT));
  };

  istranspose = function(p) {
    return car(p) === symbol(TRANSPOSE);
  };

  isinv = function(p) {
    return car(p) === symbol(INV);
  };

  isidentitymatrix = function(p) {
    return p === symbol(SYMBOL_IDENTITY_MATRIX);
  };

  MSIGN = function(p) {
    if (p.isPositive()) {
      return 1;
    } else if (p.isZero()) {
      return 0;
    } else {
      return -1;
    }
  };

  MLENGTH = function(p) {
    return p.toString().length;
  };

  MZERO = function(p) {
    return p.isZero();
  };

  MEQUAL = function(p, n) {
    if (p == null) {
      debugger;
    }
    return p.equals(n);
  };

  $ = typeof exports !== "undefined" && exports !== null ? exports : this;

  $.isadd = isadd;

  $.ismultiply = ismultiply;

  $.ispower = ispower;

  $.isfactorial = isfactorial;

  $.car = car;

  $.cdr = cdr;

  $.caar = caar;

  $.cadr = cadr;

  $.cdar = cdar;

  $.cddr = cddr;

  $.caadr = caadr;

  $.caddr = caddr;

  $.cadar = cadar;

  $.cdadr = cdadr;

  $.cddar = cddar;

  $.cdddr = cdddr;

  $.caaddr = caaddr;

  $.cadadr = cadadr;

  $.caddar = caddar;

  $.cdaddr = cdaddr;

  $.cadddr = cadddr;

  $.cddddr = cddddr;

  $.caddddr = caddddr;

  $.cadaddr = cadaddr;

  $.cddaddr = cddaddr;

  $.caddadr = caddadr;

  $.cdddaddr = cdddaddr;

  $.caddaddr = caddaddr;

  $.symbol = symbol;

  $.iscons = iscons;

  $.isrational = isrational;

  $.isdouble = isdouble;

  $.isnum = isnum;

  $.isstr = isstr;

  $.istensor = istensor;

  $.issymbol = issymbol;

  $.iskeyword = iskeyword;

  $.CONS = CONS;

  $.NUM = NUM;

  $.DOUBLE = DOUBLE;

  $.STR = STR;

  $.TENSOR = TENSOR;

  $.SYM = SYM;

  Eval_abs = function() {
    push(cadr(p1));
    Eval();
    return absval();
  };

  absValFloat = function() {
    Eval();
    absval();
    Eval();
    return zzfloat();
  };

  absval = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (istensor(p1)) {
      absval_tensor();
      restore();
      return;
    }
    if (isnum(p1)) {
      push(p1);
      if (isnegativenumber(p1)) {
        negate();
      }
      restore();
      return;
    }
    if (iscomplexnumber(p1)) {
      push(p1);
      push(p1);
      conjugate();
      multiply();
      push_rational(1, 2);
      power();
      restore();
      return;
    }
    if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(p1);
      reciprocate();
      absval();
      reciprocate();
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        absval();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
      restore();
      return;
    }
    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
      push(p1);
      negate();
      p1 = pop();
    }
    push_symbol(ABS);
    push(p1);
    list(2);
    return restore();
  };

  absval_tensor = function() {
    if (p1.tensor.ndim !== 1) {
      stop("abs(tensor) with tensor rank > 1");
    }
    push(p1);
    push(p1);
    conjugate();
    inner();
    push_rational(1, 2);
    power();
    simplify();
    return Eval();
  };


  /*
   Symbolic addition

  	Terms in a sum are combined if they are identical modulo rational
  	coefficients.

  	For example, A + 2A becomes 3A.

  	However, the sum A + sqrt(2) A is not modified.

  	Combining terms can lead to second-order effects.

  	For example, consider the case of

  		1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A

  	The first two terms are combined to yield 2 sqrt(2) A.

  	This result can now be combined with the third term to yield

  		3 sqrt(2) A
   */

  flag = 0;

  Eval_add = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p2 = pop();
      push_terms(p2);
      p1 = cdr(p1);
    }
    return add_terms(tos - h);
  };

  stackAddsCount = 0;

  add_terms = function(n) {
    var ac, ad, h, i, o, ref, ref1, results, s, subsetOfStack;
    stackAddsCount++;
    i = 0;
    h = tos - n;
    s = h;
    if (DEBUG) {
      console.log("stack before adding terms #" + stackAddsCount);
    }
    if (DEBUG) {
      for (i = o = 0, ref = tos; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        print1(stack[i]);
      }
    }
    for (i = ac = 0; ac < 10; i = ++ac) {
      if (n < 2) {
        break;
      }
      flag = 0;
      subsetOfStack = stack.slice(h, h + n);
      subsetOfStack.sort(cmp_terms);
      stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
      if (flag === 0) {
        break;
      }
      n = combine_terms(h, n);
    }
    tos = h + n;
    switch (n) {
      case 0:
        push_integer(0);
        break;
      case 1:
        break;
      default:
        list(n);
        p1 = pop();
        push_symbol(ADD);
        push(p1);
        cons();
    }
    if (DEBUG) {
      console.log("stack after adding terms #" + stackAddsCount);
    }
    if (DEBUG) {
      results = [];
      for (i = ad = 0, ref1 = tos; 0 <= ref1 ? ad < ref1 : ad > ref1; i = 0 <= ref1 ? ++ad : --ad) {
        results.push(print1(stack[i]));
      }
      return results;
    }
  };

  cmp_terms_count = 0;

  cmp_terms = function(p1, p2) {
    var i, o, ref, t;
    cmp_terms_count++;
    i = 0;
    if (isnum(p1) && isnum(p2)) {
      flag = 1;
      return 0;
    }
    if (istensor(p1) && istensor(p2)) {
      if (p1.tensor.ndim < p2.tensor.ndim) {
        return -1;
      }
      if (p1.tensor.ndim > p2.tensor.ndim) {
        return 1;
      }
      for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
          return -1;
        }
        if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
          return 1;
        }
      }
      flag = 1;
      return 0;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      if (isnum(car(p1))) {
        p1 = cdr(p1);
        if (cdr(p1) === symbol(NIL)) {
          p1 = car(p1);
        }
      }
    }
    if (car(p2) === symbol(MULTIPLY)) {
      p2 = cdr(p2);
      if (isnum(car(p2))) {
        p2 = cdr(p2);
        if (cdr(p2) === symbol(NIL)) {
          p2 = car(p2);
        }
      }
    }
    t = cmp_expr(p1, p2);
    if (t === 0) {
      flag = 1;
    }
    return t;
  };


  /*
   Compare adjacent terms in s[] and combine if possible.

  	Returns the number of terms remaining in s[].

  	n	number of terms in s[] initially
   */

  combine_terms = function(s, n) {
    var ac, ad, ae, af, i, j, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;
    i = 0;
    while (i < (n - 1)) {
      check_esc_flag();
      p3 = stack[s + i];
      p4 = stack[s + i + 1];
      if (istensor(p3) && istensor(p4)) {
        push(p3);
        push(p4);
        tensor_plus_tensor();
        p1 = pop();
        if (p1 !== symbol(NIL)) {
          stack[s + i] = p1;
          for (j = o = ref = i + 1, ref1 = n - 1; ref <= ref1 ? o < ref1 : o > ref1; j = ref <= ref1 ? ++o : --o) {
            stack[s + j] = stack[s + j + 1];
          }
          n--;
          i--;
        }
        i++;
        continue;
      }
      if (istensor(p3) || istensor(p4)) {
        i++;
        continue;
      }
      if (isnum(p3) && isnum(p4)) {
        push(p3);
        push(p4);
        add_numbers();
        p1 = pop();
        if (iszero(p1)) {
          for (j = ac = ref2 = i, ref3 = n - 2; ref2 <= ref3 ? ac < ref3 : ac > ref3; j = ref2 <= ref3 ? ++ac : --ac) {
            stack[s + j] = stack[s + j + 2];
          }
          n -= 2;
        } else {
          stack[s + i] = p1;
          for (j = ad = ref4 = i + 1, ref5 = n - 1; ref4 <= ref5 ? ad < ref5 : ad > ref5; j = ref4 <= ref5 ? ++ad : --ad) {
            stack[s + j] = stack[s + j + 1];
          }
          n--;
        }
        i--;
        i++;
        continue;
      }
      if (isnum(p3) || isnum(p4)) {
        i++;
        continue;
      }
      p1 = one;
      p2 = one;
      t = 0;
      if (car(p3) === symbol(MULTIPLY)) {
        p3 = cdr(p3);
        t = 1;
        if (isnum(car(p3))) {
          p1 = car(p3);
          p3 = cdr(p3);
          if (cdr(p3) === symbol(NIL)) {
            p3 = car(p3);
            t = 0;
          }
        }
      }
      if (car(p4) === symbol(MULTIPLY)) {
        p4 = cdr(p4);
        if (isnum(car(p4))) {
          p2 = car(p4);
          p4 = cdr(p4);
          if (cdr(p4) === symbol(NIL)) {
            p4 = car(p4);
          }
        }
      }
      if (!equal(p3, p4)) {
        i++;
        continue;
      }
      push(p1);
      push(p2);
      add_numbers();
      p1 = pop();
      if (iszero(p1)) {
        for (j = ae = ref6 = i, ref7 = n - 2; ref6 <= ref7 ? ae < ref7 : ae > ref7; j = ref6 <= ref7 ? ++ae : --ae) {
          stack[s + j] = stack[s + j + 2];
        }
        n -= 2;
        i--;
        i++;
        continue;
      }
      push(p1);
      if (t) {
        push(symbol(MULTIPLY));
        push(p3);
        cons();
      } else {
        push(p3);
      }
      multiply();
      stack[s + i] = pop();
      for (j = af = ref8 = i + 1, ref9 = n - 1; ref8 <= ref9 ? af < ref9 : af > ref9; j = ref8 <= ref9 ? ++af : --af) {
        stack[s + j] = stack[s + j + 1];
      }
      n--;
      i--;
      i++;
    }
    return n;
  };

  push_terms = function(p) {
    var results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        push(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else if (!iszero(p)) {
      return push(p);
    }
  };

  add = function() {
    var h;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    push_terms(p1);
    push_terms(p2);
    add_terms(tos - h);
    return restore();
  };

  add_all = function(k) {
    var h, i, o, ref, s;
    i = 0;
    save();
    s = tos - k;
    h = tos;
    for (i = o = 0, ref = k; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push_terms(stack[s + i]);
    }
    add_terms(tos - h);
    p1 = pop();
    tos -= k;
    push(p1);
    return restore();
  };

  subtract = function() {
    negate();
    return add();
  };


  /*
  	Add a substitution rule
   */

  Eval_pattern = function() {
    userSimplificationsInListForm.push(cdr(p1));
    return push_symbol(NIL);
  };

  Eval_adj = function() {
    push(cadr(p1));
    Eval();
    return adj();
  };

  adj = function() {
    var ac, doNothing, i, j, n, o, ref, ref1;
    i = 0;
    j = 0;
    n = 0;
    save();
    p1 = pop();
    if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {
      doNothing = 1;
    } else {
      stop("adj: square matrix expected");
    }
    n = p1.tensor.dim[0];
    p2 = alloc_tensor(n * n);
    p2.tensor.ndim = 2;
    p2.tensor.dim[0] = n;
    p2.tensor.dim[1] = n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        cofactor(p1, n, i, j);
        p2.tensor.elem[n * j + i] = pop();
      }
    }
    push(p2);
    return restore();
  };

  Eval_arccos = function() {
    push(cadr(p1));
    Eval();
    return arccos();
  };

  arccos = function() {
    var d, errno, n;
    n = 0;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.acos(p1.d);
      if (errno) {
        stop("arccos function argument is not in the interval [-1,1]");
      }
      push_double(d);
      restore();
      return;
    }
    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {
      if (evaluatingAsFloats) {
        push_double(Math.PI / 4.0);
      } else {
        push_rational(1, 4);
        push_symbol(PI);
        multiply();
      }
      restore();
      return;
    }
    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {
      if (evaluatingAsFloats) {
        push_double(Math.PI * 3.0 / 4.0);
      } else {
        push_rational(3, 4);
        push_symbol(PI);
        multiply();
      }
      restore();
      return;
    }
    if (!isrational(p1)) {
      push_symbol(ARCCOS);
      push(p1);
      list(2);
      restore();
      return;
    }
    push(p1);
    push_integer(2);
    multiply();
    n = pop_integer();
    switch (n) {
      case -2:
        if (evaluatingAsFloats) {
          push_double(Math.PI);
        } else {
          push_symbol(PI);
        }
        break;
      case -1:
        if (evaluatingAsFloats) {
          push_double(Math.PI * 2.0 / 3.0);
        } else {
          push_rational(2, 3);
          push_symbol(PI);
          multiply();
        }
        break;
      case 0:
        if (evaluatingAsFloats) {
          push_double(Math.PI / 2.0);
        } else {
          push_rational(1, 2);
          push_symbol(PI);
          multiply();
        }
        break;
      case 1:
        if (evaluatingAsFloats) {
          push_double(Math.PI / 3.0);
        } else {
          push_rational(1, 3);
          push_symbol(PI);
          multiply();
        }
        break;
      case 2:
        if (evaluatingAsFloats) {
          push_double(0.0);
        } else {
          push(zero);
        }
        break;
      default:
        push_symbol(ARCCOS);
        push(p1);
        list(2);
    }
    return restore();
  };

  Eval_arccosh = function() {
    push(cadr(p1));
    Eval();
    return arccosh();
  };

  arccosh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COSH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      if (d < 1.0) {
        stop("arccosh function argument is less than 1.0");
      }
      d = Math.log(d + Math.sqrt(d * d - 1.0));
      push_double(d);
      restore();
      return;
    }
    if (isplusone(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCCOSH);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arcsin = function() {
    push(cadr(p1));
    Eval();
    return arcsin();
  };

  arcsin = function() {
    var d, errno, n;
    n = 0;
    d = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.asin(p1.d);
      if (errno) {
        stop("arcsin function argument is not in the interval [-1,1]");
      }
      push_double(d);
      restore();
      return;
    }
    if ((isoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {
      push_rational(1, 4);
      push_symbol(PI);
      multiply();
      restore();
      return;
    }
    if ((isminusoneoversqrttwo(p1)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {
      if (evaluatingAsFloats) {
        push_double(-Math.PI / 4.0);
      } else {
        push_rational(-1, 4);
        push_symbol(PI);
        multiply();
      }
      restore();
      return;
    }
    if (!isrational(p1)) {
      push_symbol(ARCSIN);
      push(p1);
      list(2);
      restore();
      return;
    }
    push(p1);
    push_integer(2);
    multiply();
    n = pop_integer();
    switch (n) {
      case -2:
        if (evaluatingAsFloats) {
          push_double(-Math.PI / 2.0);
        } else {
          push_rational(-1, 2);
          push_symbol(PI);
          multiply();
        }
        break;
      case -1:
        if (evaluatingAsFloats) {
          push_double(-Math.PI / 6.0);
        } else {
          push_rational(-1, 6);
          push_symbol(PI);
          multiply();
        }
        break;
      case 0:
        if (evaluatingAsFloats) {
          push_double(0.0);
        } else {
          push(zero);
        }
        break;
      case 1:
        if (evaluatingAsFloats) {
          push_double(Math.PI / 6.0);
        } else {
          push_rational(1, 6);
          push_symbol(PI);
          multiply();
        }
        break;
      case 2:
        if (evaluatingAsFloats) {
          push_double(Math.PI / 2.0);
        } else {
          push_rational(1, 2);
          push_symbol(PI);
          multiply();
        }
        break;
      default:
        push_symbol(ARCSIN);
        push(p1);
        list(2);
    }
    return restore();
  };

  Eval_arcsinh = function() {
    push(cadr(p1));
    Eval();
    return arcsinh();
  };

  arcsinh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(SINH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      d = Math.log(d + Math.sqrt(d * d + 1.0));
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCSINH);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arctan = function() {
    push(cadr(p1));
    Eval();
    return arctan();
  };

  arctan = function() {
    var d, errno;
    d = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(TAN)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      errno = 0;
      d = Math.atan(p1.d);
      if (errno) {
        stop("arctan function error");
      }
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      arctan();
      negate();
      restore();
      return;
    }
    if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {
      push(p1);
      numerator();
      p2 = pop();
      push(p1);
      denominator();
      p3 = pop();
      if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {
        push(cadr(p2));
        restore();
        return;
      }
    }
    if ((car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2)) || (car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2))) {
      push_rational(1, 6);
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push(symbol(PI));
      }
      multiply();
      restore();
      return;
    }
    if (equaln(p1, 1)) {
      push_rational(1, 4);
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push(symbol(PI));
      }
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {
      push_rational(1, 3);
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push(symbol(PI));
      }
      multiply();
      restore();
      return;
    }
    push_symbol(ARCTAN);
    push(p1);
    list(2);
    return restore();
  };

  Eval_arctanh = function() {
    push(cadr(p1));
    Eval();
    return arctanh();
  };

  arctanh = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    if (car(p1) === symbol(TANH)) {
      push(cadr(p1));
      restore();
      return;
    }
    if (isdouble(p1)) {
      d = p1.d;
      if (d < -1.0 || d > 1.0) {
        stop("arctanh function argument is not in the interval [-1,1]");
      }
      d = Math.log((1.0 + d) / (1.0 - d)) / 2.0;
      push_double(d);
      restore();
      return;
    }
    if (iszero(p1)) {
      push(zero);
      restore();
      return;
    }
    push_symbol(ARCTANH);
    push(p1);
    list(2);
    return restore();
  };


  /*
   Argument (angle) of complex z

  	z		arg(z)
  	-		------

  	a		0

  	-a		-pi			See note 3 below

  	(-1)^a		a pi

  	exp(a + i b)	b

  	a b		arg(a) + arg(b)

  	a + i b		arctan(b/a)

  Result by quadrant

  	z		arg(z)
  	-		------

  	1 + i		1/4 pi

  	1 - i		-1/4 pi

  	-1 + i		3/4 pi

  	-1 - i		-3/4 pi

  Notes

  	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)

  	2. Symbols in z are assumed to be positive and real.

  	3. Negative direction adds -pi to angle.

  	   Example: z = (-1)^(1/3), mag(z) = 1/3 pi, mag(-z) = -2/3 pi

  	4. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then

  		arg(numerator(z)) - arg(denominator(z))

  	   must be used to get the correct answer. Now the operation is
  	   automatic.
   */

  Eval_arg = function() {
    push(cadr(p1));
    Eval();
    return arg();
  };

  arg = function() {
    save();
    p1 = pop();
    push(p1);
    numerator();
    yyarg();
    push(p1);
    denominator();
    yyarg();
    subtract();
    return restore();
  };

  yyarg = function() {
    save();
    p1 = pop();
    if (isnegativenumber(p1)) {
      if (isdouble(p1) || evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push(symbol(PI));
      }
      negate();
    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push(symbol(PI));
      }
      push(caddr(p1));
      multiply();
    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
      push(caddr(p1));
      imag();
    } else if (car(p1) === symbol(MULTIPLY)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        arg();
        add();
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      rect();
      p1 = pop();
      push(p1);
      real();
      p2 = pop();
      push(p1);
      imag();
      p3 = pop();
      if (iszero(p2)) {
        if (evaluatingAsFloats) {
          push_double(Math.PI);
        } else {
          push(symbol(PI));
        }
        if (isnegative(p3)) {
          negate();
        }
      } else {
        push(p3);
        push(p2);
        divide();
        arctan();
        if (isnegative(p2)) {
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          if (isnegative(p3)) {
            subtract();
          } else {
            add();
          }
        }
      }
    } else {
      push_integer(0);
    }
    return restore();
  };

  bake = function() {
    var h, s, t, x, y, z;
    h = 0;
    s = 0;
    t = 0;
    x = 0;
    y = 0;
    z = 0;
    expanding++;
    save();
    p1 = pop();
    s = ispoly(p1, symbol(SYMBOL_S));
    t = ispoly(p1, symbol(SYMBOL_T));
    x = ispoly(p1, symbol(SYMBOL_X));
    y = ispoly(p1, symbol(SYMBOL_Y));
    z = ispoly(p1, symbol(SYMBOL_Z));
    if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_S);
      bake_poly();
    } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_T);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {
      p2 = symbol(SYMBOL_X);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {
      p2 = symbol(SYMBOL_Y);
      bake_poly();
    } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {
      p2 = symbol(SYMBOL_Z);
      bake_poly();
    } else if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        bake();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else {
      push(p1);
    }
    restore();
    return expanding--;
  };

  polyform = function() {
    var h;
    h = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (ispoly(p1, p2)) {
      bake_poly();
    } else if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        polyform();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else {
      push(p1);
    }
    return restore();
  };

  bake_poly = function() {
    var a, h, i, k, n, o, ref;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    a = tos;
    push(p1);
    push(p2);
    k = coeff();
    h = tos;
    for (i = o = ref = k - 1; o >= 0; i = o += -1) {
      p1 = stack[a + i];
      bake_poly_term(i);
    }
    n = tos - h;
    if (n > 1) {
      list(n);
      push(symbol(ADD));
      swap();
      cons();
    }
    p1 = pop();
    tos -= k;
    return push(p1);
  };

  bake_poly_term = function(k) {
    var h, n;
    h = 0;
    n = 0;
    if (iszero(p1)) {
      return;
    }
    if (k === 0) {
      if (car(p1) === symbol(ADD)) {
        p1 = cdr(p1);
        while (iscons(p1)) {
          push(car(p1));
          p1 = cdr(p1);
        }
      } else {
        push(p1);
      }
      return;
    }
    h = tos;
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else if (!equaln(p1, 1)) {
      push(p1);
    }
    if (k === 1) {
      push(p2);
    } else {
      push(symbol(POWER));
      push(p2);
      push_integer(k);
      list(3);
    }
    n = tos - h;
    if (n > 1) {
      list(n);
      push(symbol(MULTIPLY));
      swap();
      return cons();
    }
  };


  /*
   Bessel J function

  	1st arg		x

  	2nd arg		n

  Recurrence relation

  	besselj(x,n) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n-2)

  	besselj(x,1/2) = sqrt(2/pi/x) sin(x)

  	besselj(x,-1/2) = sqrt(2/pi/x) cos(x)

  For negative n, reorder the recurrence relation as

  	besselj(x,n-2) = (2/x) (n-1) besselj(x,n-1) - besselj(x,n)

  Substitute n+2 for n to obtain

  	besselj(x,n) = (2/x) (n+1) besselj(x,n+1) - besselj(x,n+2)

  Examples

  	besselj(x,3/2) = (1/x) besselj(x,1/2) - besselj(x,-1/2)

  	besselj(x,-3/2) = -(1/x) besselj(x,-1/2) - besselj(x,1/2)
   */

  Eval_besselj = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return besselj();
  };

  besselj = function() {
    save();
    yybesselj();
    return restore();
  };

  yybesselj = function() {
    var d, n;
    d = 0.0;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (isdouble(p1) && n !== 0x80000000) {
      d = jn(n, p1.d);
      push_double(d);
      return;
    }
    if (iszero(p1) && iszero(p2)) {
      push_integer(1);
      return;
    }
    if (iszero(p1) && n !== 0x80000000) {
      push_integer(0);
      return;
    }
    if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {
      if (MEQUAL(p2.q.a, 1)) {
        if (evaluatingAsFloats) {
          push_double(2.0 / Math.PI);
        } else {
          push_integer(2);
          push_symbol(PI);
          divide();
        }
        push(p1);
        divide();
        push_rational(1, 2);
        power();
        push(p1);
        sine();
        multiply();
        return;
      }
      if (MEQUAL(p2.q.a, -1)) {
        if (evaluatingAsFloats) {
          push_double(2.0 / Math.PI);
        } else {
          push_integer(2);
          push_symbol(PI);
          divide();
        }
        push(p1);
        divide();
        push_rational(1, 2);
        power();
        push(p1);
        cosine();
        multiply();
        return;
      }
      push_integer(MSIGN(p2.q.a));
      p3 = pop();
      push_integer(2);
      push(p1);
      divide();
      push(p2);
      push(p3);
      subtract();
      multiply();
      push(p1);
      push(p2);
      push(p3);
      subtract();
      besselj();
      multiply();
      push(p1);
      push(p2);
      push_integer(2);
      push(p3);
      multiply();
      subtract();
      besselj();
      subtract();
      return;
    }
    if (isnegativeterm(p1)) {
      push(p1);
      negate();
      push(p2);
      power();
      push(p1);
      push(p2);
      negate();
      power();
      multiply();
      push_symbol(BESSELJ);
      push(p1);
      negate();
      push(p2);
      list(3);
      multiply();
      return;
    }
    if (isnegativeterm(p2)) {
      push_integer(-1);
      push(p2);
      power();
      push_symbol(BESSELJ);
      push(p1);
      push(p2);
      negate();
      list(3);
      multiply();
      return;
    }
    push(symbol(BESSELJ));
    push(p1);
    push(p2);
    return list(3);
  };

  Eval_bessely = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return bessely();
  };

  bessely = function() {
    save();
    yybessely();
    return restore();
  };

  yybessely = function() {
    var d, n;
    d = 0.0;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (isdouble(p1) && n !== 0x80000000) {
      d = yn(n, p1.d);
      push_double(d);
      return;
    }
    if (isnegativeterm(p2)) {
      push_integer(-1);
      push(p2);
      power();
      push_symbol(BESSELY);
      push(p1);
      push(p2);
      negate();
      list(3);
      multiply();
      return;
    }
    push_symbol(BESSELY);
    push(p1);
    push(p2);
    list(3);
  };

  MP_MIN_SIZE = 2;

  MP_MAX_FREE = 1000;

  mtotal = 0;

  free_stack = [];

  mint = function(a) {
    return bigInt(a);
  };

  setSignTo = function(a, b) {
    if (a.isPositive()) {
      if (b < 0) {
        return a.multiply(bigInt(-1));
      }
    } else {
      if (b > 0) {
        return a.multiply(bigInt(-1));
      }
    }
    return a;
  };

  makeSignSameAs = function(a, b) {
    if (a.isPositive()) {
      if (b.isNegative()) {
        return a.multiply(bigInt(-1));
      }
    } else {
      if (b.isPositive()) {
        return a.multiply(bigInt(-1));
      }
    }
    return a;
  };

  makePositive = function(a) {
    if (a.isNegative()) {
      return a.multiply(bigInt(-1));
    }
    return a;
  };


  /*
  mnew = (n) ->
  	if (n < MP_MIN_SIZE)
  		n = MP_MIN_SIZE
  	if (n == MP_MIN_SIZE && mfreecount)
  		p = free_stack[--mfreecount]
  	else
  		p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))
  		#if (p == 0)
  		 *	stop("malloc failure")
  	p[0] = n
  	mtotal += n
  	return p[3]
   */


  /*
  mfree = (array, p) ->
  	p -= 3
  	mtotal -= array[p]
  	if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)
  		free_stack[mfreecount++] = p
  	else
  		free(p)
   */


  /*
  mint = (n) ->
  	p = mnew(1)
  	if (n < 0)
  		 * !!! this is FU
  		 * MSIGN(p) = -1
  		fu = true
  	else
  		 * !!! this is FU
  		#MSIGN(p) = 1
  		fu = true
  	 * !!! this is FU
  	#MLENGTH(p) = 1
  	p[0] = Math.abs(n)
  	return p
   */


  /*
  mcopy = (a) ->
  	#unsigned int *b

  	b = mnew(MLENGTH(a))

  	 * !!! fu
  	#MSIGN(b) = MSIGN(a)
  	#MLENGTH(b) = MLENGTH(a)

  	for i in [0...MLENGTH(a)]
  		b[i] = a[i]

  	return b
   */


  /*
   *
   * ge not invoked from anywhere - is you need ge
   * just use the bigNum's ge implementation
   * leaving it here just in case I decide to backport to C
   *
   * a >= b ?
   * and and b arrays of ints, len is an int
  ge = (a, b, len) ->
  	i = 0
  	for i in [0...len]
  		if (a[i] == b[i])
  			continue
  		else
  			break
  	if (a[i] >= b[i])
  		return 1
  	else
  		return 0
   */

  add_numbers = function() {
    var a, b, theResult;
    a = 1.0;
    b = 1.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qadd();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    theResult = a + b;
    push_double(theResult);
    return restore();
  };

  subtract_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qsub();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a - b);
    return restore();
  };

  multiply_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qmul();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a * b);
    return restore();
  };

  divide_numbers = function() {
    var a, b;
    a = 0.0;
    b = 0.0;
    if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
      qdiv();
      return;
    }
    save();
    p2 = pop();
    p1 = pop();
    if (iszero(p2)) {
      stop("divide by zero");
    }
    if (isdouble(p1)) {
      a = p1.d;
    } else {
      a = convert_rational_to_double(p1);
    }
    if (isdouble(p2)) {
      b = p2.d;
    } else {
      b = convert_rational_to_double(p2);
    }
    push_double(a / b);
    return restore();
  };

  invert_number = function() {
    var a, b;
    save();
    p1 = pop();
    if (iszero(p1)) {
      stop("divide by zero");
    }
    if (isdouble(p1)) {
      push_double(1 / p1.d);
      restore();
      return;
    }
    a = bigInt(p1.q.a);
    b = bigInt(p1.q.b);
    b = makeSignSameAs(b, a);
    a = setSignTo(a, 1);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = b;
    p1.q.b = a;
    push(p1);
    return restore();
  };

  compare_rationals = function(a, b) {
    var ab, ba, t;
    t = 0;
    ab = mmul(a.q.a, b.q.b);
    ba = mmul(a.q.b, b.q.a);
    t = mcmp(ab, ba);
    return t;
  };

  compare_numbers = function(a, b) {
    var x, y;
    x = 0.0;
    y = 0.0;
    if (isrational(a) && isrational(b)) {
      return compare_rationals(a, b);
    }
    if (isdouble(a)) {
      x = a.d;
    } else {
      x = convert_rational_to_double(a);
    }
    if (isdouble(b)) {
      y = b.d;
    } else {
      y = convert_rational_to_double(b);
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };

  negate_number = function() {
    save();
    p1 = pop();
    if (iszero(p1)) {
      push(p1);
      restore();
      return;
    }
    switch (p1.k) {
      case NUM:
        p2 = new U();
        p2.k = NUM;
        p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));
        p2.q.b = bigInt(p1.q.b);
        push(p2);
        break;
      case DOUBLE:
        push_double(-p1.d);
        break;
      default:
        stop("bug caught in mp_negate_number");
    }
    return restore();
  };

  bignum_truncate = function() {
    var a;
    save();
    p1 = pop();
    a = mdiv(p1.q.a, p1.q.b);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  mp_numerator = function() {
    save();
    p1 = pop();
    if (p1.k !== NUM) {
      push(one);
      restore();
      return;
    }
    p2 = new U();
    p2.k = NUM;
    p2.q.a = bigInt(p1.q.a);
    p2.q.b = bigInt(1);
    push(p2);
    return restore();
  };

  mp_denominator = function() {
    save();
    p1 = pop();
    if (p1.k !== NUM) {
      push(one);
      restore();
      return;
    }
    p2 = new U();
    p2.k = NUM;
    p2.q.a = bigInt(p1.q.b);
    p2.q.b = bigInt(1);
    push(p2);
    return restore();
  };

  bignum_power_number = function(expo) {
    var a, b, t;
    save();
    p1 = pop();
    a = mpow(p1.q.a, Math.abs(expo));
    b = mpow(p1.q.b, Math.abs(expo));
    if (expo < 0) {
      t = a;
      a = b;
      b = t;
      a = makeSignSameAs(a, b);
      b = setSignTo(b, 1);
    }
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = b;
    push(p1);
    return restore();
  };

  convert_bignum_to_double = function(p) {
    return p.toJSNumber();
  };

  convert_rational_to_double = function(p) {
    var quotientAndRemainder, result;
    if (p.q == null) {
      debugger;
    }
    quotientAndRemainder = p.q.a.divmod(p.q.b);
    result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();
    return result;
  };

  push_integer = function(n) {
    if (DEBUG) {
      console.log("pushing integer " + n);
    }
    save();
    p1 = new U();
    p1.k = NUM;
    p1.q.a = bigInt(n);
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  push_double = function(d) {
    save();
    p1 = new U();
    p1.k = DOUBLE;
    p1.d = d;
    push(p1);
    return restore();
  };

  push_rational = function(a, b) {

    /*
    	save()
    	p1 = new U()
    	p1.k = NUM
    	p1.q.a = bigInt(a)
    	p1.q.b = bigInt(b)
    	## FIXME -- normalize ##
    	push(p1)
    	restore()
     */
    var p;
    p = new U();
    p.k = NUM;
    p.q.a = bigInt(a);
    p.q.b = bigInt(b);
    return push(p);
  };

  pop_integer = function() {
    var n;
    n = 0;
    save();
    p1 = pop();
    switch (p1.k) {
      case NUM:
        if (isinteger(p1) && p1.q.a.isSmall) {
          n = p1.q.a.toJSNumber();
        } else {
          n = 0x80000000;
        }
        break;
      case DOUBLE:
        n = Math.floor(p1.q.a);
        break;
      default:
        n = 0x80000000;
    }
    restore();
    return n;
  };

  print_double = function(p, flag) {
    var buf;
    buf = "";
    buf = "" + doubleToReasonableString(p.d);
    if (flag === 1 && buf === '-') {
      return print_str(buf + 1);
    } else {
      return print_str(buf);
    }
  };

  bignum_scan_integer = function(s) {
    var a, scounter, sign_;
    save();
    scounter = 0;
    sign_ = s[scounter];
    if (sign_ === '+' || sign_ === '-') {
      scounter++;
    }
    a = bigInt(s.substring(scounter));
    p1 = new U();
    p1.k = NUM;
    p1.q.a = a;
    p1.q.b = bigInt(1);
    push(p1);
    if (sign_ === '-') {
      negate();
    }
    return restore();
  };

  bignum_scan_float = function(s) {
    return push_double(parseFloat(s));
  };

  print_number = function(p, signed, accumulator) {
    var aAsString, buf, denominatorString, topLevelCall;
    topLevelCall = false;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    denominatorString = "";
    buf = "";
    switch (p.k) {
      case NUM:
        aAsString = p.q.a.toString();
        if (!signed) {
          if (aAsString[0] === "-") {
            aAsString = aAsString.substring(1);
          }
        }
        if (latexMode && isfraction(p)) {
          aAsString = "\\frac{" + aAsString + "}{";
        }
        accumulator += aAsString;
        stringToBePrinted += aAsString;
        if (isfraction(p)) {
          if (!latexMode) {
            accumulator += "/";
          }
          if (!latexMode) {
            stringToBePrinted += "/";
          }
          denominatorString = p.q.b.toString();
          if (latexMode) {
            denominatorString += "}";
          }
          accumulator += denominatorString;
          stringToBePrinted += denominatorString;
        }
        break;
      case DOUBLE:
        aAsString = "" + doubleToReasonableString(p.d);
        if (!signed) {
          if (aAsString[0] === "-") {
            aAsString = aAsString.substring(1);
          }
        }
        accumulator += aAsString;
        stringToBePrinted += aAsString;
    }
    return accumulator;
  };

  gcd_numbers = function() {
    save();
    p2 = pop();
    p1 = pop();
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mgcd(p1.q.a, p2.q.a);
    p3.q.b = mgcd(p1.q.b, p2.q.b);
    p3.q.a = setSignTo(p3.q.a, 1);
    push(p3);
    return restore();
  };

  pop_double = function() {
    var d;
    d = 0.0;
    save();
    p1 = pop();
    switch (p1.k) {
      case NUM:
        d = convert_rational_to_double(p1);
        break;
      case DOUBLE:
        d = p1.d;
        break;
      default:
        d = 0.0;
    }
    restore();
    return d;
  };

  bignum_float = function() {
    var d;
    d = 0.0;
    d = convert_rational_to_double(pop());
    return push_double(d);
  };

  bignum_factorial = function(n) {
    save();
    p1 = new U();
    p1.k = NUM;
    p1.q.a = __factorial(n);
    p1.q.b = bigInt(1);
    push(p1);
    return restore();
  };

  __factorial = function(n) {
    var a, b, i, o, ref, t;
    i = 0;
    if (n === 0 || n === 1) {
      a = bigInt(1);
      return a;
    }
    a = bigInt(2);
    b = bigInt(0);
    if (3 <= n) {
      for (i = o = 3, ref = n; 3 <= ref ? o <= ref : o >= ref; i = 3 <= ref ? ++o : --o) {
        b = bigInt(i);
        t = mmul(a, b);
        a = t;
      }
    }
    return a;
  };

  mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

  mp_set_bit = function(x, k) {
    console.log("not implemented yet");
    debugger;
    return x[k / 32] |= mask[k % 32];
  };

  mp_clr_bit = function(x, k) {
    console.log("not implemented yet");
    debugger;
    return x[k / 32] &= ~mask[k % 32];
  };

  mshiftright = function(a) {
    return a = a.shiftRight();
  };

  Eval_binomial = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return binomial();
  };

  binomial = function() {
    save();
    ybinomial();
    return restore();
  };

  ybinomial = function() {
    p2 = pop();
    p1 = pop();
    if (BINOM_check_args() === 0) {
      push(zero);
      return;
    }
    push(p1);
    factorial();
    push(p2);
    factorial();
    divide();
    push(p1);
    push(p2);
    subtract();
    factorial();
    return divide();
  };

  BINOM_check_args = function() {
    if (isnum(p1) && lessp(p1, zero)) {
      return 0;
    } else if (isnum(p2) && lessp(p2, zero)) {
      return 0;
    } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
      return 0;
    } else {
      return 1;
    }
  };

  Eval_ceiling = function() {
    push(cadr(p1));
    Eval();
    return ceiling();
  };

  ceiling = function() {
    save();
    yyceiling();
    return restore();
  };

  yyceiling = function() {
    var d, doNothing;
    d = 0.0;
    p1 = pop();
    if (!isnum(p1)) {
      push_symbol(CEILING);
      push(p1);
      list(2);
      return;
    }
    if (isdouble(p1)) {
      d = Math.ceil(p1.d);
      push_double(d);
      return;
    }
    if (isinteger(p1)) {
      push(p1);
      return;
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mdiv(p1.q.a, p1.q.b);
    p3.q.b = mint(1);
    push(p3);
    if (isnegativenumber(p1)) {
      return doNothing = 1;
    } else {
      push_integer(1);
      return add();
    }
  };

  Eval_choose = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return choose();
  };

  choose = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (choose_check_args() === 0) {
      push_integer(0);
      restore();
      return;
    }
    push(p1);
    factorial();
    push(p2);
    factorial();
    divide();
    push(p1);
    push(p2);
    subtract();
    factorial();
    divide();
    return restore();
  };

  choose_check_args = function() {
    if (isnum(p1) && lessp(p1, zero)) {
      return 0;
    } else if (isnum(p2) && lessp(p2, zero)) {
      return 0;
    } else if (isnum(p1) && isnum(p2) && lessp(p1, p2)) {
      return 0;
    } else {
      return 1;
    }
  };

  Eval_circexp = function() {
    push(cadr(p1));
    Eval();
    circexp();
    return Eval();
  };

  circexp = function() {
    var h, i, o, ref;
    i = 0;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      expcos();
      restore();
      return;
    }
    if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      expsin();
      restore();
      return;
    }
    if (car(p1) === symbol(TAN)) {
      p1 = cadr(p1);
      push(imaginaryunit);
      push(p1);
      multiply();
      exponential();
      p2 = pop();
      push(imaginaryunit);
      push(p1);
      multiply();
      negate();
      exponential();
      p3 = pop();
      push(p3);
      push(p2);
      subtract();
      push(imaginaryunit);
      multiply();
      push(p2);
      push(p3);
      add();
      divide();
      restore();
      return;
    }
    if (car(p1) === symbol(COSH)) {
      p1 = cadr(p1);
      push(p1);
      exponential();
      push(p1);
      negate();
      exponential();
      add();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(SINH)) {
      p1 = cadr(p1);
      push(p1);
      exponential();
      push(p1);
      negate();
      exponential();
      subtract();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    if (car(p1) === symbol(TANH)) {
      p1 = cadr(p1);
      push(p1);
      push_integer(2);
      multiply();
      exponential();
      p1 = pop();
      push(p1);
      push_integer(1);
      subtract();
      push(p1);
      push_integer(1);
      add();
      divide();
      restore();
      return;
    }
    if (iscons(p1)) {
      h = tos;
      while (iscons(p1)) {
        push(car(p1));
        circexp();
        p1 = cdr(p1);
      }
      list(tos - h);
      restore();
      return;
    }
    if (p1.k === TENSOR) {
      push(p1);
      copy_tensor();
      p1 = pop();
      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        push(p1.tensor.elem[i]);
        circexp();
        p1.tensor.elem[i] = pop();
      }
      push(p1);
      restore();
      return;
    }
    push(p1);
    return restore();
  };

  Eval_clear = function() {
    if (test_flag === 0) {
      clear_term();
    }
    clear_symbols();
    defn();
    return push(symbol(NIL));
  };

  clear = function() {
    return run("clear");
  };


  /*
  	Clear all substitution rules
   */

  Eval_clearsubstrules = function() {
    userSimplificationsInListForm = [];
    return push_symbol(NIL);
  };


  /*
   Convert complex z to clock form

  	Input:		push	z

  	Output:		Result on stack

  	clock(z) = mag(z) * (-1) ^ (arg(z) / pi)

  	For example, clock(exp(i pi/3)) gives the result (-1)^(1/3)
   */

  Eval_clock = function() {
    push(cadr(p1));
    Eval();
    return clockform();
  };

  clockform = function() {
    save();
    p1 = pop();
    push(p1);
    mag();
    push_integer(-1);
    push(p1);
    arg();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push(symbol(PI));
    }
    divide();
    power();
    multiply();

    /*
    	p1 = pop()
    	push(p1)
    	mag()
    	push(symbol(E))
    	push(p1)
    	arg()
    	push(imaginaryunit)
    	multiply()
    	power()
    	multiply()
     */
    return restore();
  };

  Eval_coeff = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (p3 === symbol(NIL)) {
      p3 = p2;
      p2 = symbol(SYMBOL_X);
    }
    push(p1);
    push(p2);
    push(p3);
    power();
    divide();
    push(p2);
    return filter();
  };

  coeff = function() {
    var h, n, prev_expanding;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    while (1) {
      push(p1);
      push(p2);
      push(zero);
      subst();
      Eval();
      p3 = pop();
      push(p3);
      push(p1);
      push(p3);
      subtract();
      p1 = pop();
      if (equal(p1, zero)) {
        n = tos - h;
        restore();
        return n;
      }
      push(p1);
      push(p2);
      prev_expanding = expanding;
      expanding = 1;
      divide();
      expanding = prev_expanding;
      p1 = pop();
    }
  };

  Eval_cofactor = function() {
    var doNothing, i, j, n;
    i = 0;
    j = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    p2 = pop();
    if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {
      doNothing = 1;
    } else {
      stop("cofactor: 1st arg: square matrix expected");
    }
    n = p2.tensor.dim[0];
    push(caddr(p1));
    Eval();
    i = pop_integer();
    if (i < 1 || i > n) {
      stop("cofactor: 2nd arg: row index expected");
    }
    push(cadddr(p1));
    Eval();
    j = pop_integer();
    if (j < 1 || j > n) {
      stop("cofactor: 3rd arg: column index expected");
    }
    return cofactor(p2, n, i - 1, j - 1);
  };

  cofactor = function(p, n, row, col) {
    var ac, i, j, o, ref, ref1;
    i = 0;
    j = 0;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        if (i !== row && j !== col) {
          push(p.tensor.elem[n * i + j]);
        }
      }
    }
    determinant(n - 1);
    if ((row + col) % 2) {
      return negate();
    }
  };

  Eval_condense = function() {
    push(cadr(p1));
    Eval();
    return Condense();
  };

  Condense = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 0;
    save();
    yycondense();
    restore();
    return expanding = prev_expanding;
  };

  yycondense = function() {
    p1 = pop();
    if (car(p1) !== symbol(ADD)) {
      push(p1);
      return;
    }
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    inverse();
    p2 = pop();
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    yyexpand();
    push(p2);
    return divide();
  };

  Eval_conj = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    push(p1);
    if (!Find(p1, imaginaryunit)) {
      polar();
      conjugate();
      return clockform();
    } else {
      return conjugate();
    }
  };

  conjugate = function() {
    push(imaginaryunit);
    push(imaginaryunit);
    negate();
    subst();
    return Eval();
  };

  consCount = 0;

  cons = function() {
    var p;
    consCount++;
    if (DEBUG) {
      console.log("cons tos: " + tos + " # " + consCount);
    }
    p = new U();
    p.k = CONS;
    p.cons.cdr = pop();
    if (p === p.cons.cdr) {
      debugger;
      console.log("something wrong p == its cdr");
    }
    p.cons.car = pop();

    /*
    	console.log "cons new cdr.k = " + p.cons.cdr.k + "\nor more in detail:"
    	print1 p.cons.cdr
    	console.log "cons new car.k = " + p.cons.car.k + "\nor more in detail:"
    	print1 p.cons.car
     */
    return push(p);
  };

  Eval_contract = function() {
    push(cadr(p1));
    Eval();
    if (cddr(p1) === symbol(NIL)) {
      push_integer(1);
      push_integer(2);
    } else {
      push(caddr(p1));
      Eval();
      push(cadddr(p1));
      Eval();
    }
    return contract();
  };

  contract = function() {
    save();
    yycontract();
    return restore();
  };

  yycontract = function() {
    var a, ac, ad, ae, af, ag, ah, ai, an, b, h, i, j, k, l, m, n, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    n = 0;
    ndim = 0;
    nelem = 0;
    ai = [];
    an = [];
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (!istensor(p1)) {
      if (!iszero(p1)) {
        stop("contract: tensor expected, 1st arg is not a tensor");
      }
      push(zero);
      return;
    }
    push(p2);
    l = pop_integer();
    push(p3);
    m = pop_integer();
    ndim = p1.tensor.ndim;
    if (l < 1 || l > ndim || m < 1 || m > ndim || l === m || p1.tensor.dim[l - 1] !== p1.tensor.dim[m - 1]) {
      stop("contract: index out of range");
    }
    l--;
    m--;
    n = p1.tensor.dim[l];
    nelem = 1;
    for (i = o = 0, ref = ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (i !== l && i !== m) {
        nelem *= p1.tensor.dim[i];
      }
    }
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim - 2;
    j = 0;
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (i !== l && i !== m) {
        p2.tensor.dim[j++] = p1.tensor.dim[i];
      }
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    for (i = ad = 0, ref2 = ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      ai[i] = 0;
      an[i] = p1.tensor.dim[i];
    }
    for (i = ae = 0, ref3 = nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      push(zero);
      for (j = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; j = 0 <= ref4 ? ++af : --af) {
        ai[l] = j;
        ai[m] = j;
        h = 0;
        for (k = ag = 0, ref5 = ndim; 0 <= ref5 ? ag < ref5 : ag > ref5; k = 0 <= ref5 ? ++ag : --ag) {
          h = (h * an[k]) + ai[k];
        }
        push(a[h]);
        add();
      }
      b[i] = pop();
      for (j = ah = ref6 = ndim - 1; ref6 <= 0 ? ah <= 0 : ah >= 0; j = ref6 <= 0 ? ++ah : --ah) {
        if (j === l || j === m) {
          continue;
        }
        if (++ai[j] < an[j]) {
          break;
        }
        ai[j] = 0;
      }
    }
    if (nelem === 1) {
      return push(b[0]);
    } else {
      return push(p2);
    }
  };

  Eval_cos = function() {
    push(cadr(p1));
    Eval();
    return cosine();
  };

  cosine = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      cosine_of_angle_sum();
    } else {
      cosine_of_angle();
    }
    return restore();
  };

  cosine_of_angle_sum = function() {
    p2 = cdr(p1);
    while (iscons(p2)) {
      p4 = car(p2);
      if (isnpi(p4)) {
        push(p1);
        push(p4);
        subtract();
        p3 = pop();
        push(p3);
        cosine();
        push(p4);
        cosine();
        multiply();
        push(p3);
        sine();
        push(p4);
        sine();
        multiply();
        subtract();
        return;
      }
      p2 = cdr(p2);
    }
    return cosine_of_angle();
  };

  cosine_of_angle = function() {
    var d, n;
    if (car(p1) === symbol(ARCCOS)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.cos(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      p1 = pop();
    }
    if (car(p1) === symbol(ARCTAN)) {
      push_integer(1);
      push(cadr(p1));
      push_integer(2);
      power();
      add();
      push_rational(-1, 2);
      power();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push_symbol(PI);
    }
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(COS));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 90:
      case 270:
        return push_integer(0);
      case 60:
      case 300:
        return push_rational(1, 2);
      case 120:
      case 240:
        return push_rational(-1, 2);
      case 45:
      case 315:
        push_rational(1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 135:
      case 225:
        push_rational(-1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 30:
      case 330:
        push_rational(1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 150:
      case 210:
        push_rational(-1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 0:
        return push_integer(1);
      case 180:
        return push_integer(-1);
      default:
        push(symbol(COS));
        push(p1);
        return list(2);
    }
  };

  Eval_cosh = function() {
    push(cadr(p1));
    Eval();
    return ycosh();
  };

  ycosh = function() {
    save();
    yycosh();
    return restore();
  };

  yycosh = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCCOSH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.cosh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(one);
      return;
    }
    push_symbol(COSH);
    push(p1);
    return list(2);
  };

  Eval_decomp = function() {
    var h;
    save();
    console.log("Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!");
    h = tos;
    push(symbol(NIL));
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    decomp(false);
    list(tos - h);
    return restore();
  };

  decomp = function(generalTransform) {
    save();
    p2 = pop();
    p1 = pop();
    if (DEBUG) {
      console.log("DECOMPOSING " + p1);
    }
    if (generalTransform) {
      if (!iscons(p1)) {
        if (DEBUG) {
          console.log("ground thing: " + p1);
        }
        push(p1);
        restore();
        return;
      }
    } else {
      if (Find(p1, p2) === 0) {
        if (DEBUG) {
          console.log("entire expression is constant");
        }
        push(p1);
        restore();
        return;
      }
    }
    if (isadd(p1)) {
      decomp_sum(generalTransform);
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      decomp_product(generalTransform);
      restore();
      return;
    }
    if (DEBUG) {
      console.log("naive decomp");
    }
    p3 = cdr(p1);
    if (DEBUG) {
      console.log("startig p3: " + p3);
    }
    while (iscons(p3)) {
      if (DEBUG) {
        console.log("recursive decomposition");
      }
      push(car(p3));
      if (generalTransform) {
        push(car(p3));
      }
      if (DEBUG) {
        console.log("car(p3): " + car(p3));
      }
      push(p2);
      if (DEBUG) {
        console.log("p2: " + p2);
      }
      decomp(generalTransform);
      p3 = cdr(p3);
    }
    return restore();
  };

  decomp_sum = function(generalTransform) {
    var h;
    h = 0;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2)) {
        push(car(p3));
        push(p2);
        decomp(generalTransform);
      }
      p3 = cdr(p3);
    }
    h = tos;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2) === 0) {
        push(car(p3));
      }
      p3 = cdr(p3);
    }
    if (tos - h) {
      add_all(tos - h);
      p3 = pop();
      push(p3);
      push(p3);
      return negate();
    }
  };

  decomp_product = function(generalTransform) {
    var h;
    h = 0;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2)) {
        push(car(p3));
        push(p2);
        decomp(generalTransform);
      }
      p3 = cdr(p3);
    }
    h = tos;
    p3 = cdr(p1);
    while (iscons(p3)) {
      if (Find(car(p3), p2) === 0) {
        push(car(p3));
      }
      p3 = cdr(p3);
    }
    if (tos - h) {
      return multiply_all(tos - h);
    }
  };

  define_user_function = function() {
    p3 = caadr(p1);
    p4 = cdadr(p1);
    p5 = caddr(p1);
    if (!issymbol(p3)) {
      stop("function name?");
    }
    if (car(p5) === symbol(EVAL)) {
      push(cadr(p5));
      Eval();
      p5 = pop();
    }
    push_symbol(FUNCTION);
    push(p5);
    push(p4);
    list(3);
    p5 = pop();
    set_binding(p3, p5);
    return push_symbol(NIL);
  };

  Eval_function_reference = function() {
    return push(p1);
  };

  Eval_defint = function() {
    push(cadr(p1));
    Eval();
    p2 = pop();
    p1 = cddr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p3 = pop();
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p4 = pop();
      push(car(p1));
      p1 = cdr(p1);
      Eval();
      p5 = pop();
      push(p2);
      push(p3);
      integral();
      p2 = pop();
      push(p2);
      push(p3);
      push(p5);
      subst();
      Eval();
      push(p2);
      push(p3);
      push(p4);
      subst();
      Eval();
      subtract();
      p2 = pop();
    }
    return push(p2);
  };

  Eval_degree = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    return degree();
  };

  degree = function() {
    save();
    p2 = pop();
    p1 = pop();
    p3 = zero;
    yydegree(p1);
    push(p3);
    return restore();
  };

  yydegree = function(p) {
    var results;
    if (equal(p, p2)) {
      if (iszero(p3)) {
        return p3 = one;
      }
    } else if (car(p) === symbol(POWER)) {
      if (equal(cadr(p), p2) && isnum(caddr(p)) && lessp(p3, caddr(p))) {
        return p3 = caddr(p);
      }
    } else if (iscons(p)) {
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        yydegree(car(p));
        results.push(p = cdr(p));
      }
      return results;
    }
  };

  Eval_denominator = function() {
    push(cadr(p1));
    Eval();
    return denominator();
  };

  denominator = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(p1);
      rationalize();
      p1 = pop();
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        denominator();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
    } else if (isrational(p1)) {
      push(p1);
      mp_denominator();
    } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(p1);
      reciprocate();
    } else {
      push(one);
    }
    return restore();
  };

  Eval_derivative = function() {
    var ac, doNothing, i, n, o, ref, ref1;
    i = 0;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
      push(symbol(NIL));
    } else if (isnum(p2)) {
      guess();
      push(p2);
    } else {
      push(p2);
      p1 = cdr(p1);
      push(car(p1));
      Eval();
    }
    p5 = pop();
    p4 = pop();
    p3 = pop();
    while (1.) {
      if (isnum(p5)) {
        push(p5);
        n = pop_integer();
        if (n === 0x80000000) {
          stop("nth derivative: check n");
        }
      } else {
        n = 1;
      }
      push(p3);
      if (n >= 0) {
        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          push(p4);
          derivative();
        }
      } else {
        n = -n;
        for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
          push(p4);
          integral();
        }
      }
      p3 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
        if (p5 === symbol(NIL)) {
          break;
        }
        if (isnum(p5)) {
          doNothing = 1;
        } else {
          p4 = p5;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p5 = pop();
        }
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    }
    return push(p3);
  };

  derivative = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (isnum(p2)) {
      stop("undefined function");
    }
    if (istensor(p1)) {
      if (istensor(p2)) {
        d_tensor_tensor();
      } else {
        d_tensor_scalar();
      }
    } else {
      if (istensor(p2)) {
        d_scalar_tensor();
      } else {
        d_scalar_scalar();
      }
    }
    return restore();
  };

  d_scalar_scalar = function() {
    if (issymbol(p2)) {
      return d_scalar_scalar_1();
    } else {
      push(p1);
      push(p2);
      push(symbol(SECRETX));
      subst();
      push(symbol(SECRETX));
      derivative();
      push(symbol(SECRETX));
      push(p2);
      return subst();
    }
  };

  d_scalar_scalar_1 = function() {
    if (equal(p1, p2)) {
      push(one);
      return;
    }
    if (!iscons(p1)) {
      push(zero);
      return;
    }
    if (isadd(p1)) {
      dsum();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      dproduct();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      dpower();
      return;
    }
    if (car(p1) === symbol(DERIVATIVE)) {
      dd();
      return;
    }
    if (car(p1) === symbol(LOG)) {
      dlog();
      return;
    }
    if (car(p1) === symbol(SIN)) {
      dsin();
      return;
    }
    if (car(p1) === symbol(COS)) {
      dcos();
      return;
    }
    if (car(p1) === symbol(TAN)) {
      dtan();
      return;
    }
    if (car(p1) === symbol(ARCSIN)) {
      darcsin();
      return;
    }
    if (car(p1) === symbol(ARCCOS)) {
      darccos();
      return;
    }
    if (car(p1) === symbol(ARCTAN)) {
      darctan();
      return;
    }
    if (car(p1) === symbol(SINH)) {
      dsinh();
      return;
    }
    if (car(p1) === symbol(COSH)) {
      dcosh();
      return;
    }
    if (car(p1) === symbol(TANH)) {
      dtanh();
      return;
    }
    if (car(p1) === symbol(ARCSINH)) {
      darcsinh();
      return;
    }
    if (car(p1) === symbol(ARCCOSH)) {
      darccosh();
      return;
    }
    if (car(p1) === symbol(ARCTANH)) {
      darctanh();
      return;
    }
    if (car(p1) === symbol(ABS)) {
      dabs();
      return;
    }
    if (car(p1) === symbol(SGN)) {
      dsgn();
      return;
    }
    if (car(p1) === symbol(HERMITE)) {
      dhermite();
      return;
    }
    if (car(p1) === symbol(ERF)) {
      derf();
      return;
    }
    if (car(p1) === symbol(ERFC)) {
      derfc();
      return;
    }
    if (car(p1) === symbol(BESSELJ)) {
      if (iszero(caddr(p1))) {
        dbesselj0();
      } else {
        dbesseljn();
      }
      return;
    }
    if (car(p1) === symbol(BESSELY)) {
      if (iszero(caddr(p1))) {
        dbessely0();
      } else {
        dbesselyn();
      }
      return;
    }
    if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {
      derivative_of_integral();
      return;
    }
    return dfunction();
  };

  dsum = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      derivative();
      p1 = cdr(p1);
    }
    return add_all(tos - h);
  };

  dproduct = function() {
    var ac, i, j, n, o, ref, ref1;
    i = 0;
    j = 0;
    n = 0;
    n = length(p1) - 1;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p3 = cdr(p1);
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        push(car(p3));
        if (i === j) {
          push(p2);
          derivative();
        }
        p3 = cdr(p3);
      }
      multiply_all(n);
    }
    return add_all(n);
  };

  dpower = function() {
    push(caddr(p1));
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(p2);
    derivative();
    multiply();
    push(cadr(p1));
    logarithm();
    push(caddr(p1));
    push(p2);
    derivative();
    multiply();
    add();
    push(p1);
    return multiply();
  };

  dlog = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    return divide();
  };

  dd = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    p3 = pop();
    if (car(p3) === symbol(DERIVATIVE)) {
      push_symbol(DERIVATIVE);
      push_symbol(DERIVATIVE);
      push(cadr(p3));
      if (lessp(caddr(p3), caddr(p1))) {
        push(caddr(p3));
        list(3);
        push(caddr(p1));
      } else {
        push(caddr(p1));
        list(3);
        push(caddr(p3));
      }
      return list(3);
    } else {
      push(p3);
      push(caddr(p1));
      return derivative();
    }
  };

  dfunction = function() {
    p3 = cdr(p1);
    if (p3 === symbol(NIL) || Find(p3, p2)) {
      push_symbol(DERIVATIVE);
      push(p1);
      push(p2);
      return list(3);
    } else {
      return push(zero);
    }
  };

  dsin = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    cosine();
    return multiply();
  };

  dcos = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    sine();
    multiply();
    return negate();
  };

  dtan = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    cosine();
    push_integer(-2);
    power();
    return multiply();
  };

  darcsin = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darccos = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    push_rational(-1, 2);
    power();
    multiply();
    return negate();
  };

  darctan = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    inverse();
    multiply();
    return simplify();
  };

  dsinh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ycosh();
    return multiply();
  };

  dcosh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ysinh();
    return multiply();
  };

  dtanh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    ycosh();
    push_integer(-2);
    power();
    return multiply();
  };

  darcsinh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(1);
    add();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darccosh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    add();
    push_rational(-1, 2);
    power();
    return multiply();
  };

  darctanh = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    subtract();
    inverse();
    return multiply();
  };

  dabs = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    sgn();
    return multiply();
  };

  dsgn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    dirac();
    multiply();
    push_integer(2);
    return multiply();
  };

  dhermite = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push_integer(2);
    push(caddr(p1));
    multiply();
    multiply();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    hermite();
    return multiply();
  };

  derf = function() {
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    multiply();
    exponential();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push_symbol(PI);
    }
    push_rational(-1, 2);
    power();
    multiply();
    push_integer(2);
    multiply();
    push(cadr(p1));
    push(p2);
    derivative();
    return multiply();
  };

  derfc = function() {
    push(cadr(p1));
    push_integer(2);
    power();
    push_integer(-1);
    multiply();
    exponential();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push_symbol(PI);
    }
    push_rational(-1, 2);
    power();
    multiply();
    push_integer(-2);
    multiply();
    push(cadr(p1));
    push(p2);
    derivative();
    return multiply();
  };

  dbesselj0 = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(1);
    besselj();
    multiply();
    push_integer(-1);
    return multiply();
  };

  dbesseljn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    besselj();
    push(caddr(p1));
    push_integer(-1);
    multiply();
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(caddr(p1));
    besselj();
    multiply();
    add();
    return multiply();
  };

  dbessely0 = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push_integer(1);
    besselj();
    multiply();
    push_integer(-1);
    return multiply();
  };

  dbesselyn = function() {
    push(cadr(p1));
    push(p2);
    derivative();
    push(cadr(p1));
    push(caddr(p1));
    push_integer(-1);
    add();
    bessely();
    push(caddr(p1));
    push_integer(-1);
    multiply();
    push(cadr(p1));
    divide();
    push(cadr(p1));
    push(caddr(p1));
    bessely();
    multiply();
    add();
    return multiply();
  };

  derivative_of_integral = function() {
    return push(cadr(p1));
  };

  DET_check_arg = function() {
    if (!istensor(p1)) {
      return 0;
    } else if (p1.tensor.ndim !== 2) {
      return 0;
    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      return 0;
    } else {
      return 1;
    }
  };

  det = function() {
    var a, ac, i, n, o, ref, ref1;
    i = 0;
    n = 0;
    save();
    p1 = pop();
    if (DET_check_arg() === 0) {
      push_symbol(DET);
      push(p1);
      list(2);
      restore();
      return;
    }
    n = p1.tensor.nelem;
    a = p1.tensor.elem;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (!isnum(a[i])) {
        break;
      }
    }
    if (i === n) {
      yydetg();
    } else {
      for (i = ac = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        push(p1.tensor.elem[i]);
      }
      determinant(p1.tensor.dim[0]);
    }
    return restore();
  };

  determinant = function(n) {
    var a, ac, breakFromOutherWhile, h, i, j, k, o, q, ref, ref1, s, sign_, t;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    q = 0;
    s = 0;
    sign_ = 0;
    t = 0;
    a = [];
    h = tos - n * n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      a[i] = i;
      a[i + n] = 0;
      a[i + n + n] = 1;
    }
    sign_ = 1;
    push(zero);
    while (1) {
      if (sign_ === 1) {
        push_integer(1);
      } else {
        push_integer(-1);
      }
      for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        k = n * a[i] + i;
        push(stack[h + k]);
        multiply();
      }
      add();
      j = n - 1;
      s = 0;
      breakFromOutherWhile = false;
      while (1) {
        q = a[n + j] + a[n + n + j];
        if (q < 0) {
          a[n + n + j] = -a[n + n + j];
          j--;
          continue;
        }
        if (q === j + 1) {
          if (j === 0) {
            breakFromOutherWhile = true;
            break;
          }
          s++;
          a[n + n + j] = -a[n + n + j];
          j--;
          continue;
        }
        break;
      }
      if (breakFromOutherWhile) {
        break;
      }
      t = a[j - a[n + j] + s];
      a[j - a[n + j] + s] = a[j - q + s];
      a[j - q + s] = t;
      a[n + j] = q;
      sign_ = -sign_;
    }
    stack[h] = stack[tos - 1];
    return tos = h + 1;
  };

  detg = function() {
    save();
    p1 = pop();
    if (DET_check_arg() === 0) {
      push_symbol(DET);
      push(p1);
      list(2);
      restore();
      return;
    }
    yydetg();
    return restore();
  };

  yydetg = function() {
    var i, n, o, ref;
    i = 0;
    n = 0;
    n = p1.tensor.dim[0];
    for (i = o = 0, ref = n * n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(p1.tensor.elem[i]);
    }
    lu_decomp(n);
    tos -= n * n;
    return push(p1);
  };

  M = function(h, n, i, j) {
    return stack[h + n * i + j];
  };

  setM = function(h, n, i, j, value) {
    return stack[h + n * i + j] = value;
  };

  lu_decomp = function(n) {
    var ac, ad, ae, af, d, h, i, j, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8;
    d = 0;
    h = 0;
    i = 0;
    j = 0;
    h = tos - n * n;
    p1 = one;
    for (d = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {
      if (equal(M(h, n, d, d), zero)) {
        for (i = ac = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
          if (!equal(M(h, n, i, d), zero)) {
            break;
          }
        }
        if (i === n) {
          p1 = zero;
          break;
        }
        for (j = ad = ref3 = d, ref4 = n; ref3 <= ref4 ? ad < ref4 : ad > ref4; j = ref3 <= ref4 ? ++ad : --ad) {
          p2 = M(h, n, d, j);
          setM(h, n, d, j, M(h, n, i, j));
          setM(h, n, i, j, p2);
        }
        push(p1);
        negate();
        p1 = pop();
      }
      push(p1);
      push(M(h, n, d, d));
      multiply();
      p1 = pop();
      for (i = ae = ref5 = d + 1, ref6 = n; ref5 <= ref6 ? ae < ref6 : ae > ref6; i = ref5 <= ref6 ? ++ae : --ae) {
        push(M(h, n, i, d));
        push(M(h, n, d, d));
        divide();
        negate();
        p2 = pop();
        setM(h, n, i, d, zero);
        for (j = af = ref7 = d + 1, ref8 = n; ref7 <= ref8 ? af < ref8 : af > ref8; j = ref7 <= ref8 ? ++af : --af) {
          push(M(h, n, d, j));
          push(p2);
          multiply();
          push(M(h, n, i, j));
          add();
          setM(h, n, i, j, pop());
        }
      }
    }
    push(p1);
    push(M(h, n, n - 1, n - 1));
    multiply();
    return p1 = pop();
  };

  Eval_dirac = function() {
    push(cadr(p1));
    Eval();
    return dirac();
  };

  dirac = function() {
    save();
    ydirac();
    return restore();
  };

  ydirac = function() {
    p1 = pop();
    if (isdouble(p1)) {
      if (p1.d === 0) {
        push_integer(1);
        return;
      } else {
        push_integer(0);
        return;
      }
    }
    if (isrational(p1)) {
      if (MZERO(mmul(p1.q.a, p1.q.b))) {
        push_integer(1);
        return;
      } else {
        push_integer(0);
        return;
      }
    }
    if (car(p1) === symbol(POWER)) {
      push_symbol(DIRAC);
      push(cadr(p1));
      list(2);
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(DIRAC);
      push(p1);
      negate();
      list(2);
      return;
    }
    if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
      push(p1);
      negate();
      p1 = pop();
    }
    push_symbol(DIRAC);
    push(p1);
    return list(2);
  };

  divisors = function() {
    var h, i, n, o, ref, subsetOfStack;
    i = 0;
    h = 0;
    n = 0;
    save();
    h = tos - 1;
    divisors_onstack();
    n = tos - h;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_expr);
    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
    p1 = alloc_tensor(n);
    p1.tensor.ndim = 1;
    p1.tensor.dim[0] = n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    push(p1);
    return restore();
  };

  divisors_onstack = function() {
    var h, i, k, n, o, ref;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    save();
    p1 = pop();
    h = tos;
    if (isnum(p1)) {
      push(p1);
      factor_small_number();
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      __factor_add();
    } else if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      if (isnum(car(p1))) {
        push(car(p1));
        factor_small_number();
        p1 = cdr(p1);
      }
      while (iscons(p1)) {
        p2 = car(p1);
        if (car(p2) === symbol(POWER)) {
          push(cadr(p2));
          push(caddr(p2));
        } else {
          push(p2);
          push(one);
        }
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(POWER)) {
      push(cadr(p1));
      push(caddr(p1));
    } else {
      push(p1);
      push(one);
    }
    k = tos;
    push(one);
    gen(h, k);
    n = tos - k;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      stack[h + i] = stack[k + i];
    }
    tos = h + n;
    return restore();
  };

  gen = function(h, k) {
    var expo, i, o, ref;
    expo = 0;
    i = 0;
    save();
    p1 = pop();
    if (h === k) {
      push(p1);
      restore();
      return;
    }
    p2 = stack[h + 0];
    p3 = stack[h + 1];
    push(p3);
    expo = pop_integer();
    if (expo !== 0x80000000) {
      for (i = o = 0, ref = Math.abs(expo); 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
        push(p1);
        push(p2);
        push_integer(sign(expo) * i);
        power();
        multiply();
        gen(h + 2, k);
      }
    }
    return restore();
  };

  __factor_add = function() {
    save();
    p1 = pop();
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    p2 = pop();
    if (isplusone(p2)) {
      push(p1);
      push(one);
      restore();
      return;
    }
    if (isnum(p2)) {
      push(p2);
      factor_small_number();
    } else if (car(p2) === symbol(MULTIPLY)) {
      p3 = cdr(p2);
      if (isnum(car(p3))) {
        push(car(p3));
        factor_small_number();
      } else {
        push(car(p3));
        push(one);
      }
      p3 = cdr(p3);
      while (iscons(p3)) {
        push(car(p3));
        push(one);
        p3 = cdr(p3);
      }
    } else {
      push(p2);
      push(one);
    }
    push(p2);
    inverse();
    p2 = pop();
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    push(one);
    return restore();
  };

  dpow = function() {
    var a, b, base, expo, result, theta;
    a = 0.0;
    b = 0.0;
    base = 0.0;
    expo = 0.0;
    result = 0.0;
    theta = 0.0;
    expo = pop_double();
    base = pop_double();
    if (base === 0.0 && expo < 0.0) {
      stop("divide by zero");
    }
    if (base >= 0.0 || (expo % 1.0) === 0.0) {
      result = Math.pow(base, expo);
      push_double(result);
      return;
    }
    result = Math.pow(Math.abs(base), expo);
    theta = Math.PI * expo;
    if ((expo % 0.5) === 0.0) {
      a = 0.0;
      b = Math.sin(theta);
    } else {
      a = Math.cos(theta);
      b = Math.sin(theta);
    }
    push_double(a * result);
    push_double(b * result);
    push(imaginaryunit);
    multiply();
    return add();
  };

  EIG_N = 0;

  EIG_yydd = [];

  EIG_yyqq = [];

  Eval_eigen = function() {
    if (EIG_check_arg() === 0) {
      stop("eigen: argument is not a square matrix");
    }
    eigen(EIGEN);
    p1 = usr_symbol("D");
    set_binding(p1, p2);
    p1 = usr_symbol("Q");
    set_binding(p1, p3);
    return push(symbol(NIL));
  };

  Eval_eigenval = function() {
    if (EIG_check_arg() === 0) {
      push_symbol(EIGENVAL);
      push(p1);
      list(2);
      return;
    }
    eigen(EIGENVAL);
    return push(p2);
  };

  Eval_eigenvec = function() {
    if (EIG_check_arg() === 0) {
      push_symbol(EIGENVEC);
      push(p1);
      list(2);
      return;
    }
    eigen(EIGENVEC);
    return push(p3);
  };

  EIG_check_arg = function() {
    var ac, ad, ae, i, j, o, ref, ref1, ref2, ref3, ref4;
    i = 0;
    j = 0;
    push(cadr(p1));
    Eval();
    yyfloat();
    Eval();
    p1 = pop();
    if (!istensor(p1)) {
      return 0;
    }
    if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      stop("eigen: argument is not a square matrix");
    }
    EIG_N = p1.tensor.dim[0];
    for (i = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = EIG_N; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        if (!isdouble(p1.tensor.elem[EIG_N * i + j])) {
          stop("eigen: matrix is not numerical");
        }
      }
    }
    for (i = ad = 0, ref2 = EIG_N - 1; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      for (j = ae = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? ae < ref4 : ae > ref4; j = ref3 <= ref4 ? ++ae : --ae) {
        if (Math.abs(p1.tensor.elem[EIG_N * i + j].d - p1.tensor.elem[EIG_N * j + i].d) > 1e-10) {
          stop("eigen: matrix is not symmetrical");
        }
      }
    }
    return 1;
  };

  eigen = function(op) {
    var ac, ad, ae, af, ag, ah, aj, al, am, i, j, o, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results;
    i = 0;
    j = 0;
    for (i = o = 0, ref = EIG_N * EIG_N; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      EIG_yydd[i] = 0.0;
    }
    for (i = ac = 0, ref1 = EIG_N * EIG_N; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      EIG_yyqq[i] = 0.0;
    }
    for (i = ad = 0, ref2 = EIG_N; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      EIG_yydd[EIG_N * i + i] = p1.tensor.elem[EIG_N * i + i].d;
      for (j = ae = ref3 = i + 1, ref4 = EIG_N; ref3 <= ref4 ? ae < ref4 : ae > ref4; j = ref3 <= ref4 ? ++ae : --ae) {
        EIG_yydd[EIG_N * i + j] = p1.tensor.elem[EIG_N * i + j].d;
        EIG_yydd[EIG_N * j + i] = p1.tensor.elem[EIG_N * i + j].d;
      }
    }
    for (i = af = 0, ref5 = EIG_N; 0 <= ref5 ? af < ref5 : af > ref5; i = 0 <= ref5 ? ++af : --af) {
      EIG_yyqq[EIG_N * i + i] = 1.0;
      for (j = ag = ref6 = i + 1, ref7 = EIG_N; ref6 <= ref7 ? ag < ref7 : ag > ref7; j = ref6 <= ref7 ? ++ag : --ag) {
        EIG_yyqq[EIG_N * i + j] = 0.0;
        EIG_yyqq[EIG_N * j + i] = 0.0;
      }
    }
    for (i = ah = 0; ah < 100; i = ++ah) {
      if (step() === 0) {
        break;
      }
    }
    if (i === 100) {
      printstr("\nnote: eigen did not converge\n");
    }
    if (op === EIGEN || op === EIGENVAL) {
      push(p1);
      copy_tensor();
      p2 = pop();
      for (i = aj = 0, ref8 = EIG_N; 0 <= ref8 ? aj < ref8 : aj > ref8; i = 0 <= ref8 ? ++aj : --aj) {
        for (j = al = 0, ref9 = EIG_N; 0 <= ref9 ? al < ref9 : al > ref9; j = 0 <= ref9 ? ++al : --al) {
          push_double(EIG_yydd[EIG_N * i + j]);
          p2.tensor.elem[EIG_N * i + j] = pop();
        }
      }
    }
    if (op === EIGEN || op === EIGENVEC) {
      push(p1);
      copy_tensor();
      p3 = pop();
      results = [];
      for (i = am = 0, ref10 = EIG_N; 0 <= ref10 ? am < ref10 : am > ref10; i = 0 <= ref10 ? ++am : --am) {
        results.push((function() {
          var ao, ref11, results1;
          results1 = [];
          for (j = ao = 0, ref11 = EIG_N; 0 <= ref11 ? ao < ref11 : ao > ref11; j = 0 <= ref11 ? ++ao : --ao) {
            push_double(EIG_yyqq[EIG_N * i + j]);
            results1.push(p3.tensor.elem[EIG_N * i + j] = pop());
          }
          return results1;
        })());
      }
      return results;
    }
  };

  step = function() {
    var ac, count, i, j, o, ref, ref1, ref2;
    i = 0;
    j = 0;
    count = 0;
    for (i = o = 0, ref = EIG_N - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = ref1 = i + 1, ref2 = EIG_N; ref1 <= ref2 ? ac < ref2 : ac > ref2; j = ref1 <= ref2 ? ++ac : --ac) {
        if (EIG_yydd[EIG_N * i + j] !== 0.0) {
          step2(i, j);
          count++;
        }
      }
    }
    return count;
  };

  step2 = function(p, q) {
    var ac, ad, c, cc, k, o, ref, ref1, ref2, s, ss, t, theta;
    k = 0;
    t = 0.0;
    theta = 0.0;
    c = 0.0;
    cc = 0.0;
    s = 0.0;
    ss = 0.0;
    theta = 0.5 * (EIG_yydd[EIG_N * p + p] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p + q];
    t = 1.0 / (Math.abs(theta) + Math.sqrt(theta * theta + 1.0));
    if (theta < 0.0) {
      t = -t;
    }
    c = 1.0 / Math.sqrt(t * t + 1.0);
    s = t * c;
    for (k = o = 0, ref = EIG_N; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
      cc = EIG_yydd[EIG_N * p + k];
      ss = EIG_yydd[EIG_N * q + k];
      EIG_yydd[EIG_N * p + k] = c * cc + s * ss;
      EIG_yydd[EIG_N * q + k] = c * ss - s * cc;
    }
    for (k = ac = 0, ref1 = EIG_N; 0 <= ref1 ? ac < ref1 : ac > ref1; k = 0 <= ref1 ? ++ac : --ac) {
      cc = EIG_yydd[EIG_N * k + p];
      ss = EIG_yydd[EIG_N * k + q];
      EIG_yydd[EIG_N * k + p] = c * cc + s * ss;
      EIG_yydd[EIG_N * k + q] = c * ss - s * cc;
    }
    for (k = ad = 0, ref2 = EIG_N; 0 <= ref2 ? ad < ref2 : ad > ref2; k = 0 <= ref2 ? ++ad : --ad) {
      cc = EIG_yyqq[EIG_N * p + k];
      ss = EIG_yyqq[EIG_N * q + k];
      EIG_yyqq[EIG_N * p + k] = c * cc + s * ss;
      EIG_yyqq[EIG_N * q + k] = c * ss - s * cc;
    }
    EIG_yydd[EIG_N * p + q] = 0.0;
    return EIG_yydd[EIG_N * q + p] = 0.0;
  };

  Eval_erf = function() {
    push(cadr(p1));
    Eval();
    return yerf();
  };

  yerf = function() {
    save();
    yyerf();
    return restore();
  };

  yyerf = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (isdouble(p1)) {
      d = 1.0 - erfc(p1.d);
      push_double(d);
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(ERF);
      push(p1);
      negate();
      list(2);
      negate();
      return;
    }
    push_symbol(ERF);
    push(p1);
    list(2);
  };

  Eval_erfc = function() {
    push(cadr(p1));
    Eval();
    return yerfc();
  };

  yerfc = function() {
    save();
    yyerfc();
    return restore();
  };

  yyerfc = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (isdouble(p1)) {
      d = erfc(p1.d);
      push_double(d);
      return;
    }
    push_symbol(ERFC);
    push(p1);
    list(2);
  };

  erfc = function(x) {
    var ans, t, z;
    t = 0.0;
    z = 0.0;
    ans = 0.0;
    z = Math.abs(x);
    t = 1.0 / (1.0 + 0.5 * z);
    ans = t * Math.exp(-z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277)))))))));
    if (x >= 0.0) {
      return ans;
    } else {
      return 2.0 - ans;
    }
  };


  /*
  	 * commented-out test
  	"float(erfc(1))",
  	"0.157299",
   */

  Eval = function() {
    check_esc_flag();
    save();
    p1 = pop();
    if (p1 == null) {
      debugger;
    }
    switch (p1.k) {
      case CONS:
        Eval_cons();
        break;
      case NUM:
        push(p1);
        break;
      case DOUBLE:
        push(p1);
        break;
      case STR:
        push(p1);
        break;
      case TENSOR:
        Eval_tensor();
        break;
      case SYM:
        Eval_sym();
        break;
      default:
        stop("atom?");
    }
    return restore();
  };

  Eval_sym = function() {
    if (iskeyword(p1)) {
      push(p1);
      push(symbol(LAST));
      list(2);
      Eval();
      return;
    }
    p2 = get_binding(p1);
    push(p2);
    if (p1 !== p2) {
      return Eval();
    }
  };

  Eval_cons = function() {
    if (!issymbol(car(p1))) {
      stop("cons?");
    }
    switch (symnum(car(p1))) {
      case ABS:
        return Eval_abs();
      case ADD:
        return Eval_add();
      case PATTERN:
        return Eval_pattern();
      case ADJ:
        return Eval_adj();
      case AND:
        return Eval_and();
      case ARCCOS:
        return Eval_arccos();
      case ARCCOSH:
        return Eval_arccosh();
      case ARCSIN:
        return Eval_arcsin();
      case ARCSINH:
        return Eval_arcsinh();
      case ARCTAN:
        return Eval_arctan();
      case ARCTANH:
        return Eval_arctanh();
      case ARG:
        return Eval_arg();
      case ATOMIZE:
        return Eval_atomize();
      case BESSELJ:
        return Eval_besselj();
      case BESSELY:
        return Eval_bessely();
      case BINDING:
        return Eval_binding();
      case BINOMIAL:
        return Eval_binomial();
      case CEILING:
        return Eval_ceiling();
      case CHECK:
        return Eval_check();
      case CHOOSE:
        return Eval_choose();
      case CIRCEXP:
        return Eval_circexp();
      case CLEAR:
        return Eval_clear();
      case CLEARSUBSTRULES:
        return Eval_clearsubstrules();
      case CLOCK:
        return Eval_clock();
      case COEFF:
        return Eval_coeff();
      case COFACTOR:
        return Eval_cofactor();
      case CONDENSE:
        return Eval_condense();
      case CONJ:
        return Eval_conj();
      case CONTRACT:
        return Eval_contract();
      case COS:
        return Eval_cos();
      case COSH:
        return Eval_cosh();
      case DECOMP:
        return Eval_decomp();
      case DEGREE:
        return Eval_degree();
      case DEFINT:
        return Eval_defint();
      case DENOMINATOR:
        return Eval_denominator();
      case DERIVATIVE:
        return Eval_derivative();
      case DET:
        return Eval_det();
      case DIM:
        return Eval_dim();
      case DIRAC:
        return Eval_dirac();
      case DISPLAY:
        return Eval_display();
      case DIVISORS:
        return Eval_divisors();
      case DO:
        return Eval_do();
      case DOT:
        return Eval_inner();
      case DRAW:
        return Eval_draw();
      case DSOLVE:
        return Eval_dsolve();
      case EIGEN:
        return Eval_eigen();
      case EIGENVAL:
        return Eval_eigenval();
      case EIGENVEC:
        return Eval_eigenvec();
      case ERF:
        return Eval_erf();
      case ERFC:
        return Eval_erfc();
      case EVAL:
        return Eval_Eval();
      case EXP:
        return Eval_exp();
      case EXPAND:
        return Eval_expand();
      case EXPCOS:
        return Eval_expcos();
      case EXPSIN:
        return Eval_expsin();
      case FACTOR:
        return Eval_factor();
      case FACTORIAL:
        return Eval_factorial();
      case FACTORPOLY:
        return Eval_factorpoly();
      case FILTER:
        return Eval_filter();
      case FLOATF:
        return Eval_float();
      case FLOOR:
        return Eval_floor();
      case FOR:
        return Eval_for();
      case FUNCTION:
        return Eval_function_reference();
      case GAMMA:
        return Eval_gamma();
      case GCD:
        return Eval_gcd();
      case HERMITE:
        return Eval_hermite();
      case HILBERT:
        return Eval_hilbert();
      case IMAG:
        return Eval_imag();
      case INDEX:
        return Eval_index();
      case INNER:
        return Eval_inner();
      case INTEGRAL:
        return Eval_integral();
      case INV:
        return Eval_inv();
      case INVG:
        return Eval_invg();
      case ISINTEGER:
        return Eval_isinteger();
      case ISPRIME:
        return Eval_isprime();
      case LAGUERRE:
        return Eval_laguerre();
      case LCM:
        return Eval_lcm();
      case LEADING:
        return Eval_leading();
      case LEGENDRE:
        return Eval_legendre();
      case LOG:
        return Eval_log();
      case LOOKUP:
        return Eval_lookup();
      case MAG:
        return Eval_mag();
      case MOD:
        return Eval_mod();
      case MULTIPLY:
        return Eval_multiply();
      case NOT:
        return Eval_not();
      case NROOTS:
        return Eval_nroots();
      case NUMBER:
        return Eval_number();
      case NUMERATOR:
        return Eval_numerator();
      case OPERATOR:
        return Eval_operator();
      case OR:
        return Eval_or();
      case OUTER:
        return Eval_outer();
      case POLAR:
        return Eval_polar();
      case POWER:
        return Eval_power();
      case PRIME:
        return Eval_prime();
      case PRINT:
        return Eval_display();
      case PRINTLATEX:
        return Eval_printlatex();
      case PRINTLIST:
        return Eval_printlist();
      case PRODUCT:
        return Eval_product();
      case QUOTE:
        return Eval_quote();
      case QUOTIENT:
        return Eval_quotient();
      case RANK:
        return Eval_rank();
      case RATIONALIZE:
        return Eval_rationalize();
      case REAL:
        return Eval_real();
      case YYRECT:
        return Eval_rect();
      case ROOTS:
        return Eval_roots();
      case SETQ:
        return Eval_setq();
      case SGN:
        return Eval_sgn();
      case SIMPLIFY:
        return Eval_simplify();
      case SIN:
        return Eval_sin();
      case SINH:
        return Eval_sinh();
      case SHAPE:
        return Eval_shape();
      case SQRT:
        return Eval_sqrt();
      case STOP:
        return Eval_stop();
      case SUBST:
        return Eval_subst();
      case SUM:
        return Eval_sum();
      case TAN:
        return Eval_tan();
      case TANH:
        return Eval_tanh();
      case TAYLOR:
        return Eval_taylor();
      case TEST:
        return Eval_test();
      case TESTEQ:
        return Eval_testeq();
      case TESTGE:
        return Eval_testge();
      case TESTGT:
        return Eval_testgt();
      case TESTLE:
        return Eval_testle();
      case TESTLT:
        return Eval_testlt();
      case TRANSPOSE:
        return Eval_transpose();
      case UNIT:
        return Eval_unit();
      case ZERO:
        return Eval_zero();
      default:
        return Eval_user_function();
    }
  };

  Eval_binding = function() {
    return push(get_binding(cadr(p1)));
  };

  Eval_check = function() {
    push(cadr(p1));
    Eval_predicate();
    p1 = pop();
    if (iszero(p1)) {
      stop("check(arg): arg is zero");
    }
    return push(symbol(NIL));
  };

  Eval_det = function() {
    push(cadr(p1));
    Eval();
    return det();
  };

  Eval_dim = function() {
    var n;
    push(cadr(p1));
    Eval();
    p2 = pop();
    if (iscons(cddr(p1))) {
      push(caddr(p1));
      Eval();
      n = pop_integer();
    } else {
      n = 1;
    }
    if (!istensor(p2)) {
      return push_integer(1);
    } else if (n < 1 || n > p2.tensor.ndim) {
      return push(p1);
    } else {
      return push_integer(p2.tensor.dim[n - 1]);
    }
  };

  Eval_divisors = function() {
    push(cadr(p1));
    Eval();
    return divisors();
  };

  Eval_do = function() {
    var results;
    push(car(p1));
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      pop();
      push(car(p1));
      Eval();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  Eval_dsolve = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    return dsolve();
  };

  Eval_Eval = function() {
    push(cadr(p1));
    Eval();
    p1 = cddr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      push(cadr(p1));
      Eval();
      subst();
      p1 = cddr(p1);
    }
    return Eval();
  };

  Eval_exp = function() {
    push(cadr(p1));
    Eval();
    return exponential();
  };

  Eval_factorial = function() {
    push(cadr(p1));
    Eval();
    return factorial();
  };

  Eval_factorpoly = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    factorpoly();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      factorpoly();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  Eval_hermite = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return hermite();
  };

  Eval_hilbert = function() {
    push(cadr(p1));
    Eval();
    return hilbert();
  };

  Eval_index = function() {
    var h;
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    return index_function(tos - h);
  };

  Eval_inv = function() {
    push(cadr(p1));
    Eval();
    return inv();
  };

  Eval_invg = function() {
    push(cadr(p1));
    Eval();
    return invg();
  };

  Eval_isinteger = function() {
    var n;
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (isrational(p1)) {
      if (isinteger(p1)) {
        push(one);
      } else {
        push(zero);
      }
      return;
    }
    if (isdouble(p1)) {
      n = Math.floor(p1.d);
      if (n === p1.d) {
        push(one);
      } else {
        push(zero);
      }
      return;
    }
    push_symbol(ISINTEGER);
    push(p1);
    return list(2);
  };

  Eval_multiply = function() {
    var results;
    push(cadr(p1));
    Eval();
    p1 = cddr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      multiply();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  Eval_number = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (p1.k === NUM || p1.k === DOUBLE) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_operator = function() {
    var h;
    h = tos;
    push_symbol(OPERATOR);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    return list(tos - h);
  };

  Eval_print = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      if (equaln(get_binding(symbol(TTY)), 1)) {
        printline(pop());
      } else {
        display(pop());
      }
      p1 = cdr(p1);
    }
    return push(symbol(NIL));
  };

  Eval_quote = function() {
    return push(cadr(p1));
  };

  Eval_rank = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (istensor(p1)) {
      return push_integer(p1.tensor.ndim);
    } else {
      return push(zero);
    }
  };

  Eval_setq = function() {
    if (caadr(p1) === symbol(INDEX)) {
      setq_indexed();
      return;
    }
    if (iscons(cadr(p1))) {
      define_user_function();
      return;
    }
    if (!issymbol(cadr(p1))) {
      stop("symbol assignment: error in symbol");
    }
    push(caddr(p1));
    Eval();
    p2 = pop();
    set_binding(cadr(p1), p2);
    return push(symbol(NIL));
  };

  setq_indexed = function() {
    var h;
    p4 = cadadr(p1);
    if (!issymbol(p4)) {
      stop("indexed assignment: error in symbol");
    }
    h = tos;
    push(caddr(p1));
    Eval();
    p2 = cdadr(p1);
    while (iscons(p2)) {
      push(car(p2));
      Eval();
      p2 = cdr(p2);
    }
    set_component(tos - h);
    p3 = pop();
    set_binding(p4, p3);
    return push(symbol(NIL));
  };

  Eval_sqrt = function() {
    push(cadr(p1));
    Eval();
    push_rational(1, 2);
    return power();
  };

  Eval_stop = function() {
    return stop("user stop");
  };

  Eval_subst = function() {
    push(cadddr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadr(p1));
    Eval();
    subst();
    return Eval();
  };

  Eval_unit = function() {
    var i, n, o, ref;
    i = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    n = pop_integer();
    if (n < 2) {
      push(p1);
      return;
    }
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p1.tensor.elem[n * i + i] = one;
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return push(p1);
  };

  Eval_noexpand = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 0;
    Eval();
    return expanding = prev_expanding;
  };

  Eval_predicate = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(SETQ)) {
      Eval_testeq();
    } else {
      push(p1);
      Eval();
    }
    return restore();
  };

  Eval_expand = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    return expand();
  };

  expand = function() {
    var prev_expanding;
    save();
    p9 = pop();
    p5 = pop();
    if (istensor(p5)) {
      expand_tensor();
      restore();
      return;
    }
    if (car(p5) === symbol(ADD)) {
      push_integer(0);
      p1 = cdr(p5);
      while (iscons(p1)) {
        push(car(p1));
        push(p9);
        expand();
        add();
        p1 = cdr(p1);
      }
      restore();
      return;
    }
    push(p5);
    numerator();
    p3 = pop();
    push(p5);
    denominator();
    p2 = pop();
    remove_negative_exponents();
    push(p3);
    push(p2);
    push(p9);
    if (isone(p3) || isone(p2)) {
      if (!ispoly(p2, p9) || isone(p2)) {
        pop();
        pop();
        pop();
        push(p5);
        restore();
        return;
      }
    }
    divpoly();
    p7 = pop();
    push(p3);
    push(p2);
    push(p7);
    multiply();
    subtract();
    p3 = pop();
    if (iszero(p3)) {
      push(p7);
      restore();
      return;
    }
    push(p2);
    push(p9);
    factorpoly();
    p2 = pop();
    expand_get_C();
    expand_get_B();
    expand_get_A();
    if (istensor(p4)) {
      push(p4);
      prev_expanding = expanding;
      expanding = 1;
      inv();
      expanding = prev_expanding;
      push(p3);
      inner();
      push(p2);
      inner();
    } else {
      push(p3);
      push(p4);
      prev_expanding = expanding;
      expanding = 1;
      divide();
      expanding = prev_expanding;
      push(p2);
      multiply();
    }
    push(p7);
    add();
    return restore();
  };

  expand_tensor = function() {
    var i, o, ref;
    i = 0;
    push(p5);
    copy_tensor();
    p5 = pop();
    for (i = o = 0, ref = p5.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(p5.tensor.elem[i]);
      push(p9);
      expand();
      p5.tensor.elem[i] = pop();
    }
    return push(p5);
  };

  remove_negative_exponents = function() {
    var h, i, j, k, n, o, ref;
    h = 0;
    i = 0;
    j = 0;
    k = 0;
    n = 0;
    h = tos;
    factors(p2);
    factors(p3);
    n = tos - h;
    j = 0;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p1 = stack[h + i];
      if (car(p1) !== symbol(POWER)) {
        continue;
      }
      if (cadr(p1) !== p9) {
        continue;
      }
      push(caddr(p1));
      k = pop_integer();
      if (k === 0x80000000) {
        continue;
      }
      if (k < j) {
        j = k;
      }
    }
    tos = h;
    if (j === 0) {
      return;
    }
    push(p2);
    push(p9);
    push_integer(-j);
    power();
    multiply();
    p2 = pop();
    push(p3);
    push(p9);
    push_integer(-j);
    power();
    multiply();
    return p3 = pop();
  };

  expand_get_C = function() {
    var a, ac, h, i, j, n, o, prev_expanding, ref, ref1;
    h = 0;
    i = 0;
    j = 0;
    n = 0;
    h = tos;
    if (car(p2) === symbol(MULTIPLY)) {
      p1 = cdr(p2);
      while (iscons(p1)) {
        p5 = car(p1);
        expand_get_CF();
        p1 = cdr(p1);
      }
    } else {
      p5 = p2;
      expand_get_CF();
    }
    n = tos - h;
    if (n === 1) {
      p4 = pop();
      return;
    }
    p4 = alloc_tensor(n * n);
    p4.tensor.ndim = 2;
    p4.tensor.dim[0] = n;
    p4.tensor.dim[1] = n;
    a = h;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        push(stack[a + j]);
        push(p9);
        push_integer(i);
        power();
        prev_expanding = expanding;
        expanding = 1;
        divide();
        expanding = prev_expanding;
        push(p9);
        filter();
        p4.tensor.elem[n * i + j] = pop();
      }
    }
    return tos -= n;
  };

  expand_get_CF = function() {
    var d, i, j, n, o, prev_expanding, ref, results;
    d = 0;
    i = 0;
    j = 0;
    n = 0;
    if (!Find(p5, p9)) {
      return;
    }
    prev_expanding = expanding;
    expanding = 1;
    trivial_divide();
    expanding = prev_expanding;
    if (car(p5) === symbol(POWER)) {
      push(caddr(p5));
      n = pop_integer();
      p6 = cadr(p5);
    } else {
      n = 1;
      p6 = p5;
    }
    push(p6);
    push(p9);
    degree();
    d = pop_integer();
    results = [];
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      results.push((function() {
        var ac, ref1, results1;
        results1 = [];
        for (j = ac = 0, ref1 = d; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
          push(p8);
          push(p6);
          push_integer(i);
          power();
          prev_expanding = expanding;
          expanding = 1;
          multiply();
          expanding = prev_expanding;
          push(p9);
          push_integer(j);
          power();
          prev_expanding = expanding;
          expanding = 1;
          multiply();
          results1.push(expanding = prev_expanding);
        }
        return results1;
      })());
    }
    return results;
  };

  trivial_divide = function() {
    var h;
    h = 0;
    if (car(p2) === symbol(MULTIPLY)) {
      h = tos;
      p0 = cdr(p2);
      while (iscons(p0)) {
        if (!equal(car(p0), p5)) {
          push(car(p0));
          Eval();
        }
        p0 = cdr(p0);
      }
      multiply_all(tos - h);
    } else {
      push_integer(1);
    }
    return p8 = pop();
  };

  expand_get_B = function() {
    var i, n, o, prev_expanding, ref;
    i = 0;
    n = 0;
    if (!istensor(p4)) {
      return;
    }
    n = p4.tensor.dim[0];
    p8 = alloc_tensor(n);
    p8.tensor.ndim = 1;
    p8.tensor.dim[0] = n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(p3);
      push(p9);
      push_integer(i);
      power();
      prev_expanding = expanding;
      expanding = 1;
      divide();
      expanding = prev_expanding;
      push(p9);
      filter();
      p8.tensor.elem[i] = pop();
    }
    return p3 = p8;
  };

  expand_get_A = function() {
    var h, i, n, o, ref;
    h = 0;
    i = 0;
    n = 0;
    if (!istensor(p4)) {
      push(p2);
      reciprocate();
      p2 = pop();
      return;
    }
    h = tos;
    if (car(p2) === symbol(MULTIPLY)) {
      p8 = cdr(p2);
      while (iscons(p8)) {
        p5 = car(p8);
        expand_get_AF();
        p8 = cdr(p8);
      }
    } else {
      p5 = p2;
      expand_get_AF();
    }
    n = tos - h;
    p8 = alloc_tensor(n);
    p8.tensor.ndim = 1;
    p8.tensor.dim[0] = n;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p8.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    return p2 = p8;
  };

  expand_get_AF = function() {
    var d, i, j, n, o, ref, results;
    d = 0;
    i = 0;
    j = 0;
    n = 1;
    if (!Find(p5, p9)) {
      return;
    }
    if (car(p5) === symbol(POWER)) {
      push(caddr(p5));
      n = pop_integer();
      p5 = cadr(p5);
    }
    push(p5);
    push(p9);
    degree();
    d = pop_integer();
    results = [];
    for (i = o = ref = n; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {
      results.push((function() {
        var ac, ref1, results1;
        results1 = [];
        for (j = ac = 0, ref1 = d; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
          push(p5);
          push_integer(i);
          power();
          reciprocate();
          push(p9);
          push_integer(j);
          power();
          results1.push(multiply());
        }
        return results1;
      })());
    }
    return results;
  };

  Eval_expcos = function() {
    push(cadr(p1));
    Eval();
    return expcos();
  };

  expcos = function() {
    save();
    p1 = pop();
    push(imaginaryunit);
    push(p1);
    multiply();
    exponential();
    push_rational(1, 2);
    multiply();
    push(imaginaryunit);
    negate();
    push(p1);
    multiply();
    exponential();
    push_rational(1, 2);
    multiply();
    add();
    return restore();
  };

  Eval_expsin = function() {
    push(cadr(p1));
    Eval();
    return expsin();
  };

  expsin = function() {
    save();
    p1 = pop();
    push(imaginaryunit);
    push(p1);
    multiply();
    exponential();
    push(imaginaryunit);
    divide();
    push_rational(1, 2);
    multiply();
    push(imaginaryunit);
    negate();
    push(p1);
    multiply();
    exponential();
    push(imaginaryunit);
    divide();
    push_rational(1, 2);
    multiply();
    subtract();
    return restore();
  };

  Eval_factor = function() {
    var results;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    factor();
    p1 = cdddr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      factor_again();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  factor_again = function() {
    var h, n;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        factor_term();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      push(p2);
      factor_term();
    }
    n = tos - h;
    if (n > 1) {
      multiply_all_noexpand(n);
    }
    return restore();
  };

  factor_term = function() {
    save();
    factorpoly();
    p1 = pop();
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else {
      push(p1);
    }
    return restore();
  };

  factor = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (isinteger(p1)) {
      push(p1);
      factor_number();
    } else {
      push(p1);
      push(p2);
      factorpoly();
    }
    return restore();
  };

  factor_small_number = function() {
    var d, expo, i, n, o, ref;
    i = 0;
    save();
    n = pop_integer();
    if (n === 0x80000000) {
      stop("number too big to factor");
    }
    if (n < 0) {
      n = -n;
    }
    for (i = o = 0, ref = MAXPRIMETAB; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      d = primetab[i];
      if (d > n / d) {
        break;
      }
      expo = 0;
      while (n % d === 0) {
        n /= d;
        expo++;
      }
      if (expo) {
        push_integer(d);
        push_integer(expo);
      }
    }
    if (n > 1) {
      push_integer(n);
      push_integer(1);
    }
    return restore();
  };

  factorial = function() {
    var n;
    n = 0;
    save();
    p1 = pop();
    push(p1);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(FACTORIAL);
      push(p1);
      list(2);
      restore();
      return;
    }
    bignum_factorial(n);
    return restore();
  };

  simplifyfactorials = function() {
    var x;
    x = 0;
    save();
    x = expanding;
    expanding = 0;
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(zero);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        simplifyfactorials();
        add();
        p1 = cdr(p1);
      }
      expanding = x;
      restore();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      sfac_product();
      expanding = x;
      restore();
      return;
    }
    push(p1);
    expanding = x;
    return restore();
  };

  sfac_product = function() {
    var ac, ad, i, j, n, o, ref, ref1, ref2, ref3, s;
    i = 0;
    j = 0;
    n = 0;
    s = tos;
    p1 = cdr(p1);
    n = 0;
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
      n++;
    }
    for (i = o = 0, ref = n - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      if (stack[s + i] === symbol(NIL)) {
        continue;
      }
      for (j = ac = ref1 = i + 1, ref2 = n; ref1 <= ref2 ? ac < ref2 : ac > ref2; j = ref1 <= ref2 ? ++ac : --ac) {
        if (stack[s + j] === symbol(NIL)) {
          continue;
        }
        sfac_product_f(s, i, j);
      }
    }
    push(one);
    for (i = ad = 0, ref3 = n; 0 <= ref3 ? ad < ref3 : ad > ref3; i = 0 <= ref3 ? ++ad : --ad) {
      if (stack[s + i] === symbol(NIL)) {
        continue;
      }
      push(stack[s + i]);
      multiply();
    }
    p1 = pop();
    tos -= n;
    return push(p1);
  };

  sfac_product_f = function(s, a, b) {
    var i, n, o, ref;
    i = 0;
    n = 0;
    p1 = stack[s + a];
    p2 = stack[s + b];
    if (ispower(p1)) {
      p3 = caddr(p1);
      p1 = cadr(p1);
    } else {
      p3 = one;
    }
    if (ispower(p2)) {
      p4 = caddr(p2);
      p2 = cadr(p2);
    } else {
      p4 = one;
    }
    if (isfactorial(p1) && isfactorial(p2)) {
      push(p3);
      push(p4);
      add();
      yyexpand();
      n = pop_integer();
      if (n !== 0) {
        return;
      }
      push(cadr(p1));
      push(cadr(p2));
      subtract();
      yyexpand();
      n = pop_integer();
      if (n === 0 || n === 0x80000000) {
        return;
      }
      if (n < 0) {
        n = -n;
        p5 = p1;
        p1 = p2;
        p2 = p5;
        p5 = p3;
        p3 = p4;
        p4 = p5;
      }
      push(one);
      for (i = o = 1, ref = n; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
        push(cadr(p2));
        push_integer(i);
        add();
        push(p3);
        power();
        multiply();
      }
      stack[s + a] = pop();
      return stack[s + b] = symbol(NIL);
    }
  };

  polycoeff = 0;

  factpoly_expo = 0;

  factorpoly = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (!Find(p1, p2)) {
      push(p1);
      restore();
      return;
    }
    if (!ispoly(p1, p2)) {
      push(p1);
      restore();
      return;
    }
    if (!issymbol(p2)) {
      push(p1);
      restore();
      return;
    }
    push(p1);
    push(p2);
    yyfactorpoly();
    return restore();
  };

  yyfactorpoly = function() {
    var ac, ad, ae, checkingTheDivision, dividend, foundComplexRoot, foundRealRoot, h, i, o, prev_expanding, previousFactorisation, ref, ref1, ref2, ref3, remainingPoly, whichRootsAreWeFinding;
    h = 0;
    i = 0;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    if (isfloating(p1)) {
      stop("floating point numbers in polynomial");
    }
    polycoeff = tos;
    push(p1);
    push(p2);
    factpoly_expo = coeff() - 1;
    rationalize_coefficients(h);
    whichRootsAreWeFinding = "real";
    remainingPoly = null;
    while (factpoly_expo > 0) {
      if (iszero(stack[polycoeff + 0])) {
        push_integer(1);
        p4 = pop();
        push_integer(0);
        p5 = pop();
      } else {
        if (whichRootsAreWeFinding === "real") {
          foundRealRoot = get_factor_from_real_root();
        } else if (whichRootsAreWeFinding === "complex") {
          foundComplexRoot = get_factor_from_complex_root(remainingPoly);
        }
      }
      if (whichRootsAreWeFinding === "real") {
        if (foundRealRoot === 0) {
          whichRootsAreWeFinding = "complex";
          continue;
        } else {
          push(p4);
          push(p2);
          multiply();
          push(p5);
          add();
          p8 = pop();
          if (DEBUG) {
            console.log("success\nFACTOR=" + p8);
          }

          /*
          				if (isnegativeterm(p4))
          					push(p8)
          					negate()
          					p8 = pop()
          					push(p7)
          					negate_noexpand()
          					p7 = pop()
           */
          push(p7);
          push(p8);
          multiply_noexpand();
          p7 = pop();
          yydivpoly();
          while (factpoly_expo && iszero(stack[polycoeff + factpoly_expo])) {
            factpoly_expo--;
          }
          push(zero);
          for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
            push(stack[polycoeff + i]);
            push(p2);
            push_integer(i);
            power();
            multiply();
            add();
          }
          remainingPoly = pop();
        }
      } else if (whichRootsAreWeFinding === "complex") {
        if (foundComplexRoot === 0) {
          break;
        } else {
          push(p4);
          push(p2);
          subtract();
          push(p4);
          conjugate();
          push(p2);
          subtract();
          multiply();
          p8 = pop();
          if (DEBUG) {
            console.log("success\nFACTOR=" + p8);
          }

          /*
          				if (isnegativeterm(p4))
          					push(p8)
          					negate()
          					p8 = pop()
          					push(p7)
          					negate_noexpand()
          					p7 = pop()
           */
          push(p7);
          previousFactorisation = pop();
          push(p7);
          push(p8);
          multiply_noexpand();
          p7 = pop();
          if (remainingPoly == null) {
            push(zero);
            for (i = ac = 0, ref1 = factpoly_expo; 0 <= ref1 ? ac <= ref1 : ac >= ref1; i = 0 <= ref1 ? ++ac : --ac) {
              push(stack[polycoeff + i]);
              push(p2);
              push_integer(i);
              power();
              multiply();
              add();
            }
            remainingPoly = pop();
          }
          dividend = remainingPoly;
          push(dividend);
          push(p8);
          push(p2);
          divpoly();
          remainingPoly = pop();
          push(remainingPoly);
          push(p8);
          multiply();
          checkingTheDivision = pop();
          if (!equal(checkingTheDivision, dividend)) {
            if (DEBUG) {
              console.log("we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting");
            }
            if (DEBUG) {
              console.log("so just returning previousFactorisation times dividend: " + previousFactorisation + " * " + dividend);
            }
            push(previousFactorisation);
            push(dividend);
            prev_expanding = expanding;
            expanding = 0;
            yycondense();
            expanding = prev_expanding;
            multiply_noexpand();
            p7 = pop();
            stack[h] = p7;
            tos = h + 1;
            restore();
            return;
          }

          /*
          				if compare_numbers(startingDegree, remainingDegree)
          					 * ok even if we found a complex root that
          					 * together with the conjugate generates a poly in Z,
          					 * that doesn't mean that the division would end up in Z.
          					 * Example: 1+x^2+x^4+x^6 has +i and -i as one of its roots
          					 * so a factor is 1+x^2 ( = (x+i)*(x-i))
          					 * BUT
           */
          for (i = ad = 0, ref2 = factpoly_expo; 0 <= ref2 ? ad <= ref2 : ad >= ref2; i = 0 <= ref2 ? ++ad : --ad) {
            pop();
          }
          push(remainingPoly);
          push(p2);
          coeff();
          factpoly_expo -= 2;
        }
      }
    }
    push(zero);
    for (i = ae = 0, ref3 = factpoly_expo; 0 <= ref3 ? ae <= ref3 : ae >= ref3; i = 0 <= ref3 ? ++ae : --ae) {
      push(stack[polycoeff + i]);
      push(p2);
      push_integer(i);
      power();
      multiply();
      add();
    }
    p1 = pop();
    if (DEBUG) {
      console.log("POLY=" + p1);
    }
    push(p1);
    prev_expanding = expanding;
    expanding = 0;
    yycondense();
    expanding = prev_expanding;
    p1 = pop();
    if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {
      push(p1);
      negate();
      p1 = pop();
      push(p7);
      negate_noexpand();
      p7 = pop();
    }
    push(p7);
    push(p1);
    multiply_noexpand();
    p7 = pop();
    if (DEBUG) {
      console.log("RESULT=" + p7);
    }
    stack[h] = p7;
    tos = h + 1;
    return restore();
  };

  rationalize_coefficients = function(h) {
    var ac, i, o, ref, ref1, ref2, ref3;
    i = 0;
    p7 = one;
    for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {
      push(stack[i]);
      denominator();
      push(p7);
      lcm();
      p7 = pop();
    }
    for (i = ac = ref2 = h, ref3 = tos; ref2 <= ref3 ? ac < ref3 : ac > ref3; i = ref2 <= ref3 ? ++ac : --ac) {
      push(p7);
      push(stack[i]);
      multiply();
      stack[i] = pop();
    }
    push(p7);
    reciprocate();
    p7 = pop();
    if (DEBUG) {
      return console.log("rationalize_coefficients result");
    }
  };

  get_factor_from_real_root = function() {
    var a0, ac, ad, ae, af, an, h, i, j, na0, nan, o, ref, ref1, ref2, ref3, ref4, rootsTries_i, rootsTries_j;
    i = 0;
    j = 0;
    h = 0;
    a0 = 0;
    an = 0;
    na0 = 0;
    nan = 0;
    if (DEBUG) {
      push(zero);
      for (i = o = 0, ref = factpoly_expo; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
        push(stack[polycoeff + i]);
        push(p2);
        push_integer(i);
        power();
        multiply();
        add();
      }
      p1 = pop();
      console.log("POLY=" + p1);
    }
    h = tos;
    an = tos;
    push(stack[polycoeff + factpoly_expo]);
    divisors_onstack();
    nan = tos - an;
    a0 = tos;
    push(stack[polycoeff + 0]);
    divisors_onstack();
    na0 = tos - a0;
    if (DEBUG) {
      console.log("divisors of base term");
      for (i = ac = 0, ref1 = na0; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        console.log(", " + stack[a0 + i]);
      }
      console.log("divisors of leading term");
      for (i = ad = 0, ref2 = nan; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
        console.log(", " + stack[an + i]);
      }
    }
    for (rootsTries_i = ae = 0, ref3 = nan; 0 <= ref3 ? ae < ref3 : ae > ref3; rootsTries_i = 0 <= ref3 ? ++ae : --ae) {
      for (rootsTries_j = af = 0, ref4 = na0; 0 <= ref4 ? af < ref4 : af > ref4; rootsTries_j = 0 <= ref4 ? ++af : --af) {
        p4 = stack[an + rootsTries_i];
        p5 = stack[a0 + rootsTries_j];
        push(p5);
        push(p4);
        divide();
        negate();
        p3 = pop();
        Evalpoly();
        if (DEBUG) {
          console.log("try A=" + p4);
          console.log(", B=" + p5);
          console.log(", root " + p2);
          console.log("=-B/A=" + p3);
          console.log(", POLY(" + p3);
          console.log(")=" + p6);
        }
        if (iszero(p6)) {
          tos = h;
          if (DEBUG) {
            console.log("get_factor_from_real_root returning 1");
          }
          return 1;
        }
        push(p5);
        negate();
        p5 = pop();
        push(p3);
        negate();
        p3 = pop();
        Evalpoly();
        if (DEBUG) {
          console.log("try A=" + p4);
          console.log(", B=" + p5);
          console.log(", root " + p2);
          console.log("=-B/A=" + p3);
          console.log(", POLY(" + p3);
          console.log(")=" + p6);
        }
        if (iszero(p6)) {
          tos = h;
          if (DEBUG) {
            console.log("get_factor_from_real_root returning 1");
          }
          return 1;
        }
      }
    }
    tos = h;
    if (DEBUG) {
      console.log("get_factor_from_real_root returning 0");
    }
    return 0;
  };

  get_factor_from_complex_root = function(remainingPoly) {
    var a0, ac, an, h, i, j, na0, nan, o, rootsTries_i, rootsTries_j;
    i = 0;
    j = 0;
    h = 0;
    a0 = 0;
    an = 0;
    na0 = 0;
    nan = 0;
    if (factpoly_expo <= 2) {
      if (DEBUG) {
        console.log("no more factoring via complex roots to be found in polynomial of degree <= 2");
      }
      return 0;
    }
    p1 = remainingPoly;
    if (DEBUG) {
      console.log("complex root finding for POLY=" + p1);
    }
    h = tos;
    an = tos;
    push_integer(-1);
    push_rational(2, 3);
    power();
    rect();
    p4 = pop();
    if (DEBUG) {
      console.log("complex root finding: trying with " + p4);
    }
    push(p4);
    p3 = pop();
    push(p3);
    Evalpoly();
    if (DEBUG) {
      console.log("complex root finding result: " + p6);
    }
    if (iszero(p6)) {
      tos = h;
      if (DEBUG) {
        console.log("get_factor_from_complex_root returning 1");
      }
      return 1;
    }
    push_integer(1);
    push_rational(2, 3);
    power();
    rect();
    p4 = pop();
    if (DEBUG) {
      console.log("complex root finding: trying with " + p4);
    }
    push(p4);
    p3 = pop();
    push(p3);
    Evalpoly();
    if (DEBUG) {
      console.log("complex root finding result: " + p6);
    }
    if (iszero(p6)) {
      tos = h;
      if (DEBUG) {
        console.log("get_factor_from_complex_root returning 1");
      }
      return 1;
    }
    for (rootsTries_i = o = -10; o <= 10; rootsTries_i = ++o) {
      for (rootsTries_j = ac = 1; ac <= 5; rootsTries_j = ++ac) {
        push_integer(rootsTries_i);
        push_integer(rootsTries_j);
        push(imaginaryunit);
        multiply();
        add();
        rect();
        p4 = pop();
        push(p4);
        p3 = pop();
        push(p3);
        Evalpoly();
        if (iszero(p6)) {
          tos = h;
          if (DEBUG) {
            console.log("found complex root: " + p6);
          }
          return 1;
        }
      }
    }
    tos = h;
    if (DEBUG) {
      console.log("get_factor_from_complex_root returning 0");
    }
    return 0;
  };

  yydivpoly = function() {
    var i, o, ref;
    i = 0;
    p6 = zero;
    for (i = o = ref = factpoly_expo; ref <= 0 ? o < 0 : o > 0; i = ref <= 0 ? ++o : --o) {
      push(stack[polycoeff + i]);
      stack[polycoeff + i] = p6;
      push(p4);
      divide();
      p6 = pop();
      push(stack[polycoeff + i - 1]);
      push(p6);
      push(p5);
      multiply();
      subtract();
      stack[polycoeff + i - 1] = pop();
    }
    stack[polycoeff + 0] = p6;
    if (DEBUG) {
      return console.log("yydivpoly Q:");
    }
  };

  Evalpoly = function() {
    var i, o, ref;
    i = 0;
    push(zero);
    for (i = o = ref = factpoly_expo; ref <= 0 ? o <= 0 : o >= 0; i = ref <= 0 ? ++o : --o) {
      push(p3);
      multiply();
      push(stack[polycoeff + i]);
      if (DEBUG) {
        console.log("Evalpoly top of stack:");
        print1(stack[tos - i]);
      }
      add();
    }
    return p6 = pop();
  };

  factors = function(p) {
    var h;
    h = tos;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      while (iscons(p)) {
        push_term_factors(car(p));
        p = cdr(p);
      }
    } else {
      push_term_factors(p);
    }
    return tos - h;
  };

  push_term_factors = function(p) {
    var results;
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        push(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      return push(p);
    }
  };


  /*
  Remove terms that involve a given symbol or expression. For example...

  	filter(x^2 + x + 1, x)		=>	1

  	filter(x^2 + x + 1, x^2)	=>	x + 1
   */

  Eval_filter = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      filter();
      results.push(p1 = cdr(p1));
    }
    return results;
  };


  /*
   For example...

  	push(F)
  	push(X)
  	filter()
  	F = pop()
   */

  filter = function() {
    save();
    p2 = pop();
    p1 = pop();
    filter_main();
    return restore();
  };

  filter_main = function() {
    if (car(p1) === symbol(ADD)) {
      return filter_sum();
    } else if (istensor(p1)) {
      return filter_tensor();
    } else if (Find(p1, p2)) {
      return push_integer(0);
    } else {
      return push(p1);
    }
  };

  filter_sum = function() {
    var results;
    push_integer(0);
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      filter();
      add();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  filter_tensor = function() {
    var ac, i, n, o, ref, ref1;
    i = 0;
    n = 0;
    n = p1.tensor.nelem;
    p3 = alloc_tensor(n);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = o = 0, ref = p1.tensor.ndim; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1.tensor.elem[i]);
      push(p2);
      filter();
      p3.tensor.elem[i] = pop();
    }
    return push(p3);
  };

  Eval_float = function() {
    evaluatingAsFloats++;
    push(cadr(p1));
    Eval();
    yyfloat();
    Eval();
    return evaluatingAsFloats--;
  };

  checkFloatHasWorkedOutCompletely = function(nodeToCheck) {
    var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;
    numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);
    numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);
    numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);
    numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);
    numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);
    if (DEBUG) {
      console.log("     ... numberOfPowers: " + numberOfPowers);
      console.log("     ... numberOfPIs: " + numberOfPIs);
      console.log("     ... numberOfEs: " + numberOfEs);
      console.log("     ... numberOfMults: " + numberOfMults);
      console.log("     ... numberOfSums: " + numberOfSums);
    }
    if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {
      return stop("float: some unevalued parts in " + nodeToCheck);
    }
  };

  zzfloat = function() {
    save();
    evaluatingAsFloats++;
    Eval();
    yyfloat();
    Eval();
    evaluatingAsFloats--;
    return restore();
  };

  yyfloat = function() {
    var h, i, o, ref;
    i = 0;
    h = 0;
    evaluatingAsFloats++;
    save();
    p1 = pop();
    if (iscons(p1)) {
      h = tos;
      while (iscons(p1)) {
        push(car(p1));
        yyfloat();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else if (p1.k === TENSOR) {
      push(p1);
      copy_tensor();
      p1 = pop();
      for (i = o = 0, ref = p1.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
        push(p1.tensor.elem[i]);
        yyfloat();
        p1.tensor.elem[i] = pop();
      }
      push(p1);
    } else if (p1.k === NUM) {
      push(p1);
      bignum_float();
    } else if (p1 === symbol(PI)) {
      push_double(Math.PI);
    } else if (p1 === symbol(E)) {
      push_double(Math.E);
    } else {
      push(p1);
    }
    restore();
    return evaluatingAsFloats--;
  };

  Eval_floor = function() {
    push(cadr(p1));
    Eval();
    return yfloor();
  };

  yfloor = function() {
    save();
    yyfloor();
    return restore();
  };

  yyfloor = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (!isnum(p1)) {
      push_symbol(FLOOR);
      push(p1);
      list(2);
      return;
    }
    if (isdouble(p1)) {
      d = Math.floor(p1.d);
      push_double(d);
      return;
    }
    if (isinteger(p1)) {
      push(p1);
      return;
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mdiv(p1.q.a, p1.q.b);
    p3.q.b = mint(1);
    push(p3);
    if (isnegativenumber(p1)) {
      push_integer(-1);
      return add();
    }
  };


  /*
  x=0
  y=2
  for(k,1,9,x=sqrt(2+x),y=2*y/x)
  float(y)

  X: k
  B: 1...9
   */

  Eval_for = function() {
    var i, j, k, o, ref, ref1;
    i = 0;
    j = 0;
    k = 0;
    p6 = cadr(p1);
    if (!issymbol(p6)) {
      stop("for: 1st arg?");
    }
    push(caddr(p1));
    Eval();
    j = pop_integer();
    if (j === 0x80000000) {
      stop("for: 2nd arg?");
    }
    push(cadddr(p1));
    Eval();
    k = pop_integer();
    if (k === 0x80000000) {
      stop("for: 3rd arg?");
    }
    p1 = cddddr(p1);
    p4 = get_binding(p6);
    for (i = o = ref = j, ref1 = k; ref <= ref1 ? o <= ref1 : o >= ref1; i = ref <= ref1 ? ++o : --o) {
      push_integer(i);
      p5 = pop();
      set_binding(p6, p5);
      p2 = p1;
      while (iscons(p2)) {
        push(car(p2));
        Eval();
        pop();
        p2 = cdr(p2);
      }
    }
    set_binding(p6, p4);
    return push_symbol(NIL);
  };

  Eval_gamma = function() {
    push(cadr(p1));
    Eval();
    return gamma();
  };

  gamma = function() {
    save();
    gammaf();
    return restore();
  };

  gammaf = function() {
    p1 = pop();
    if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push_symbol(PI);
      }
      push_rational(1, 2);
      power();
      return;
    }
    if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push_symbol(PI);
      }
      push_rational(1, 2);
      power();
      push_rational(1, 2);
      multiply();
      return;
    }
    if (isnegativeterm(p1)) {
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push_symbol(PI);
      }
      push_integer(-1);
      multiply();
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push_symbol(PI);
      }
      push(p1);
      multiply();
      sine();
      push(p1);
      multiply();
      push(p1);
      negate();
      gamma();
      multiply();
      divide();
      return;
    }
    if (car(p1) === symbol(ADD)) {
      gamma_of_sum();
      return;
    }
    push_symbol(GAMMA);
    push(p1);
    list(2);
  };

  gamma_of_sum = function() {
    p3 = cdr(p1);
    if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {
      push(cadr(p3));
      push(cadr(p3));
      gamma();
      return multiply();
    } else {
      if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {
        push(cadr(p3));
        gamma();
        push(cadr(p3));
        push_integer(-1);
        add();
        return divide();
      } else {
        push_symbol(GAMMA);
        push(p1);
        list(2);
      }
    }
  };

  Eval_gcd = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      gcd();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  gcd = function() {
    var prev_expanding;
    prev_expanding = expanding;
    save();
    gcd_main();
    restore();
    return expanding = prev_expanding;
  };

  gcd_main = function() {
    expanding = 1;
    p2 = pop();
    p1 = pop();
    if (equal(p1, p2)) {
      push(p1);
      return;
    }
    if (isrational(p1) && isrational(p2)) {
      push(p1);
      push(p2);
      gcd_numbers();
      return;
    }
    if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {
      gcd_expr_expr();
      return;
    }
    if (car(p1) === symbol(ADD)) {
      gcd_expr(p1);
      p1 = pop();
    }
    if (car(p2) === symbol(ADD)) {
      gcd_expr(p2);
      p2 = pop();
    }
    if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {
      gcd_term_term();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      gcd_term_factor();
      return;
    }
    if (car(p2) === symbol(MULTIPLY)) {
      gcd_factor_term();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      p3 = caddr(p1);
      p1 = cadr(p1);
    } else {
      p3 = one;
    }
    if (car(p2) === symbol(POWER)) {
      p4 = caddr(p2);
      p2 = cadr(p2);
    } else {
      p4 = one;
    }
    if (!equal(p1, p2)) {
      push(one);
      return;
    }
    if (isnum(p3) && isnum(p4)) {
      push(p1);
      if (lessp(p3, p4)) {
        push(p3);
      } else {
        push(p4);
      }
      power();
      return;
    }
    push(p3);
    push(p4);
    divide();
    p5 = pop();
    if (isnum(p5)) {
      push(p1);
      if (car(p3) === symbol(MULTIPLY) && isnum(cadr(p3))) {
        p5 = cadr(p3);
      } else {
        p5 = one;
      }
      if (car(p4) === symbol(MULTIPLY) && isnum(cadr(p4))) {
        p6 = cadr(p4);
      } else {
        p6 = one;
      }
      if (lessp(p5, p6)) {
        push(p3);
      } else {
        push(p4);
      }
      power();
      return;
    }
    push(p3);
    push(p4);
    subtract();
    p5 = pop();
    if (!isnum(p5)) {
      push(one);
      return;
    }
    push(p1);
    if (isnegativenumber(p5)) {
      push(p3);
    } else {
      push(p4);
    }
    return power();
  };

  gcd_expr_expr = function() {
    if (length(p1) !== length(p2)) {
      push(one);
      return;
    }
    p3 = cdr(p1);
    push(car(p3));
    p3 = cdr(p3);
    while (iscons(p3)) {
      push(car(p3));
      gcd();
      p3 = cdr(p3);
    }
    p3 = pop();
    p4 = cdr(p2);
    push(car(p4));
    p4 = cdr(p4);
    while (iscons(p4)) {
      push(car(p4));
      gcd();
      p4 = cdr(p4);
    }
    p4 = pop();
    push(p1);
    push(p3);
    divide();
    p5 = pop();
    push(p2);
    push(p4);
    divide();
    p6 = pop();
    if (equal(p5, p6)) {
      push(p5);
      push(p3);
      push(p4);
      gcd();
      return multiply();
    } else {
      return push(one);
    }
  };

  gcd_expr = function(p) {
    var results;
    p = cdr(p);
    push(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      push(car(p));
      gcd();
      results.push(p = cdr(p));
    }
    return results;
  };

  gcd_term_term = function() {
    var results;
    push(one);
    p3 = cdr(p1);
    results = [];
    while (iscons(p3)) {
      p4 = cdr(p2);
      while (iscons(p4)) {
        push(car(p3));
        push(car(p4));
        gcd();
        multiply();
        p4 = cdr(p4);
      }
      results.push(p3 = cdr(p3));
    }
    return results;
  };

  gcd_term_factor = function() {
    var results;
    push(one);
    p3 = cdr(p1);
    results = [];
    while (iscons(p3)) {
      push(car(p3));
      push(p2);
      gcd();
      multiply();
      results.push(p3 = cdr(p3));
    }
    return results;
  };

  gcd_factor_term = function() {
    var results;
    push(one);
    p4 = cdr(p2);
    results = [];
    while (iscons(p4)) {
      push(p1);
      push(car(p4));
      gcd();
      multiply();
      results.push(p4 = cdr(p4));
    }
    return results;
  };

  guess = function() {
    var p;
    p = pop();
    push(p);
    if (Find(p, symbol(SYMBOL_X))) {
      return push_symbol(SYMBOL_X);
    } else if (Find(p, symbol(SYMBOL_Y))) {
      return push_symbol(SYMBOL_Y);
    } else if (Find(p, symbol(SYMBOL_Z))) {
      return push_symbol(SYMBOL_Z);
    } else if (Find(p, symbol(SYMBOL_T))) {
      return push_symbol(SYMBOL_T);
    } else if (Find(p, symbol(SYMBOL_S))) {
      return push_symbol(SYMBOL_S);
    } else {
      return push_symbol(SYMBOL_X);
    }
  };

  hermite = function() {
    save();
    yyhermite();
    return restore();
  };

  yyhermite = function() {
    var n;
    n = 0;
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(HERMITE);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    if (issymbol(p1)) {
      return yyhermite2(n);
    } else {
      p3 = p1;
      p1 = symbol(SECRETX);
      yyhermite2(n);
      p1 = p3;
      push(symbol(SECRETX));
      push(p1);
      subst();
      return Eval();
    }
  };

  yyhermite2 = function(n) {
    var i, o, ref, results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p4 = pop();
    results = [];
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p5 = p4;
      p4 = pop();
      push(p1);
      push(p4);
      multiply();
      push_integer(i);
      push(p5);
      multiply();
      subtract();
      push_integer(2);
      results.push(multiply());
    }
    return results;
  };

  hilbert = function() {
    var ac, i, j, n, o, ref, ref1;
    i = 0;
    j = 0;
    n = 0;
    save();
    p2 = pop();
    push(p2);
    n = pop_integer();
    if (n < 2) {
      push_symbol(HILBERT);
      push(p2);
      list(2);
      restore();
      return;
    }
    push_zero_matrix(n, n);
    p1 = pop();
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        push_integer(i + j + 1);
        inverse();
        p1.tensor.elem[i * n + j] = pop();
      }
    }
    push(p1);
    return restore();
  };


  /*
   Returns the coefficient of the imaginary part of complex z

  	z		imag(z)
  	-		-------

  	a + i b		b

  	exp(i a)	sin(a)
   */

  Eval_imag = function() {
    push(cadr(p1));
    Eval();
    return imag();
  };

  imag = function() {
    save();
    rect();
    p1 = pop();
    push(p1);
    push(p1);
    conjugate();
    subtract();
    push_integer(2);
    divide();
    push(imaginaryunit);
    divide();
    return restore();
  };

  index_function = function(n) {
    var ac, ad, ae, af, i, k, m, ndim, nelem, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, s, t;
    i = 0;
    k = 0;
    m = 0;
    ndim = 0;
    nelem = 0;
    t = 0;
    save();
    s = tos - n;
    p1 = stack[s];
    if (!istensor(p1)) {
      tos -= n;
      push(p1);
      restore();
      return;
    }
    ndim = p1.tensor.ndim;
    m = n - 1;
    if (m > ndim) {
      stop("too many indices for tensor");
    }
    k = 0;
    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(stack[s + i + 1]);
      t = pop_integer();
      if (t < 1 || t > p1.tensor.dim[i]) {
        stop("index out of range");
      }
      k = k * p1.tensor.dim[i] + t - 1;
    }
    if (ndim === m) {
      tos -= n;
      push(p1.tensor.elem[k]);
      restore();
      return;
    }
    for (i = ac = ref1 = m, ref2 = ndim; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      k = k * p1.tensor.dim[i] + 0;
    }
    nelem = 1;
    for (i = ad = ref3 = m, ref4 = ndim; ref3 <= ref4 ? ad < ref4 : ad > ref4; i = ref3 <= ref4 ? ++ad : --ad) {
      nelem *= p1.tensor.dim[i];
    }
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim - m;
    for (i = ae = ref5 = m, ref6 = ndim; ref5 <= ref6 ? ae < ref6 : ae > ref6; i = ref5 <= ref6 ? ++ae : --ae) {
      p2.tensor.dim[i - m] = p1.tensor.dim[i];
    }
    for (i = af = 0, ref7 = nelem; 0 <= ref7 ? af < ref7 : af > ref7; i = 0 <= ref7 ? ++af : --af) {
      p2.tensor.elem[i] = p1.tensor.elem[k + i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p2);
    return restore();
  };

  set_component = function(n) {
    var ac, ad, ae, af, ag, i, k, m, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t;
    i = 0;
    k = 0;
    m = 0;
    ndim = 0;
    t = 0;
    save();
    if (n < 3) {
      stop("error in indexed assign");
    }
    s = tos - n;
    p2 = stack[s];
    p1 = stack[s + 1];
    if (!istensor(p1)) {
      stop("error in indexed assign");
    }
    ndim = p1.tensor.ndim;
    m = n - 2;
    if (m > ndim) {
      stop("error in indexed assign");
    }
    k = 0;
    for (i = o = 0, ref = m; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      push(stack[s + i + 2]);
      t = pop_integer();
      if (t < 1 || t > p1.tensor.dim[i]) {
        stop("error in indexed assign\n");
      }
      k = k * p1.tensor.dim[i] + t - 1;
    }
    for (i = ac = ref1 = m, ref2 = ndim; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      k = k * p1.tensor.dim[i] + 0;
    }
    p3 = alloc_tensor(p1.tensor.nelem);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = ad = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? ad < ref3 : ad > ref3; i = 0 <= ref3 ? ++ad : --ad) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = ae = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? ae < ref4 : ae > ref4; i = 0 <= ref4 ? ++ae : --ae) {
      p3.tensor.elem[i] = p1.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p3.tensor.nelem !== p3.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    p1 = p3;
    if (ndim === m) {
      if (istensor(p2)) {
        stop("error in indexed assign");
      }
      p1.tensor.elem[k] = p2;
      if (p1.tensor.nelem !== p1.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
      tos -= n;
      push(p1);
      restore();
      return;
    }
    if (!istensor(p2)) {
      stop("error in indexed assign");
    }
    if (ndim - m !== p2.tensor.ndim) {
      stop("error in indexed assign");
    }
    for (i = af = 0, ref5 = p2.tensor.ndim; 0 <= ref5 ? af < ref5 : af > ref5; i = 0 <= ref5 ? ++af : --af) {
      if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {
        stop("error in indexed assign");
      }
    }
    for (i = ag = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? ag < ref6 : ag > ref6; i = 0 <= ref6 ? ++ag : --ag) {
      p1.tensor.elem[k + i] = p2.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p1);
    return restore();
  };

  Eval_inner = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      inner();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  inner = function() {
    var arg1, arg2, arg3, subtractionResult;
    save();
    p2 = pop();
    p1 = pop();
    if (isnegativeterm(p2) && isnegativeterm(p1)) {
      push(p2);
      negate();
      p2 = pop();
      push(p1);
      negate();
      p1 = pop();
    }
    if (isinnerordot(p1)) {
      arg1 = car(cdr(p1));
      arg2 = car(cdr(cdr(p1)));
      arg3 = p2;
      p1 = arg1;
      push(arg2);
      push(arg3);
      inner();
      p2 = pop();
    }
    if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {
      push(p2);
      restore();
      return;
    } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {
      push(p1);
      restore();
      return;
    }
    if (istensor(p1) && istensor(p2)) {
      inner_f();
    } else {
      push(p1);
      push(p2);
      inv();
      subtract();
      subtractionResult = pop();
      if (iszero(subtractionResult)) {
        push_symbol(SYMBOL_IDENTITY_MATRIX);
        restore();
        return;
      }
      if (expanding && isadd(p1)) {
        p1 = cdr(p1);
        push(zero);
        while (iscons(p1)) {
          push(car(p1));
          push(p2);
          inner();
          add();
          p1 = cdr(p1);
        }
        restore();
        return;
      }
      if (expanding && isadd(p2)) {
        p2 = cdr(p2);
        push(zero);
        while (iscons(p2)) {
          push(p1);
          push(car(p2));
          inner();
          add();
          p2 = cdr(p2);
        }
        restore();
        return;
      }
      push(p1);
      push(p2);
      if (istensor(p1) && isnum(p2)) {
        tensor_times_scalar();
      } else if (isnum(p1) && istensor(p2)) {
        scalar_times_tensor();
      } else {
        if (isnum(p1) || isnum(p2)) {
          multiply();
        } else {
          pop();
          pop();
          push_symbol(INNER);
          push(p1);
          push(p2);
          list(3);
          restore();
          return;
        }
      }
    }
    return restore();
  };

  inner_f = function() {
    var a, ac, ad, ae, af, ag, ah, ak, b, bk, c, i, j, k, n, ndim, o, ref, ref1, ref2, ref3, ref4, ref5, ref6;
    i = 0;
    n = p1.tensor.dim[p1.tensor.ndim - 1];
    if (n !== p2.tensor.dim[0]) {
      debugger;
      stop("inner: tensor dimension check");
    }
    ndim = p1.tensor.ndim + p2.tensor.ndim - 2;
    if (ndim > MAXDIM) {
      stop("inner: rank of result exceeds maximum");
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    ak = 1;
    for (i = o = 0, ref = p1.tensor.ndim - 1; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      ak *= p1.tensor.dim[i];
    }
    bk = 1;
    for (i = ac = 1, ref1 = p2.tensor.ndim; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
      bk *= p2.tensor.dim[i];
    }
    p3 = alloc_tensor(ak * bk);
    c = p3.tensor.elem;
    for (i = ad = 0, ref2 = ak; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      for (j = ae = 0, ref3 = n; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
        if (iszero(a[i * n + j])) {
          continue;
        }
        for (k = af = 0, ref4 = bk; 0 <= ref4 ? af < ref4 : af > ref4; k = 0 <= ref4 ? ++af : --af) {
          push(a[i * n + j]);
          push(b[j * bk + k]);
          multiply();
          push(c[i * bk + k]);
          add();
          c[i * bk + k] = pop();
        }
      }
    }
    if (ndim === 0) {
      return push(p3.tensor.elem[0]);
    } else {
      p3.tensor.ndim = ndim;
      j = 0;
      for (i = ag = 0, ref5 = p1.tensor.ndim - 1; 0 <= ref5 ? ag < ref5 : ag > ref5; i = 0 <= ref5 ? ++ag : --ag) {
        p3.tensor.dim[i] = p1.tensor.dim[i];
      }
      j = p1.tensor.ndim - 1;
      for (i = ah = 0, ref6 = p2.tensor.ndim - 1; 0 <= ref6 ? ah < ref6 : ah > ref6; i = 0 <= ref6 ? ++ah : --ah) {
        p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];
      }
      return push(p3);
    }
  };


  /*
   Table of integrals

  The symbol f is just a dummy symbol for creating a list f(A,B,C,C,...) where

  	A	is the template expression

  	B	is the result expression

  	C	is an optional list of conditional expressions
   */

  itab = ["f(a,a*x)", "f(1/x,log(x))", "f(x^a,x^(a+1)/(a+1))", "f(exp(a*x),1/a*exp(a*x))", "f(exp(a*x+b),1/a*exp(a*x+b))", "f(x*exp(a*x^2),exp(a*x^2)/(2*a))", "f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))", "f(log(a*x),x*log(a*x)-x)", "f(a^x,a^x/log(a),or(not(number(a)),a>0))", "f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))", "f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))", "f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))", "f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))", "f(1/(a+b*x),1/b*log(a+b*x))", "f(1/(a+b*x)^2,-1/(b*(a+b*x)))", "f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)", "f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)", "f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))", "f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))", "f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))", "f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))", "f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))", "f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))", "f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))", "f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))", "f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))", "f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))", "f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))", "f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))", "f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))", "f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))", "f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))", "f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))", "f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))", "f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))", "f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))", "f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))", "f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))", "f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))", "f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))", "f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)", "f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)", "f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))", "f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))", "f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)", "f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)", "f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)", "f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))", "f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))", "f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))", "f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))", "f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))", "f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))", "f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))", "f(x/sqrt(x^2+a),sqrt(x^2+a))", "f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))", "f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))", "f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))", "f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))", "f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))", "f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))", "f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))", "f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))", "f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))", "f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))", "f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))", "f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)", "f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))", "f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))", "f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))", "f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))", "f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))", "f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))", "f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))", "f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))", "f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))", "f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))", "f(x/sqrt(a-x^2),-sqrt(a-x^2))", "f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))", "f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))", "f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))", "f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))", "f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))", "f(sin(a*x),-cos(a*x)/a)", "f(cos(a*x),sin(a*x)/a)", "f(tan(a*x),-log(cos(a*x))/a)", "f(1/tan(a*x),log(sin(a*x))/a)", "f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)", "f(1/sin(a*x),log(tan(a*x/2))/a)", "f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))", "f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))", "f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))", "f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))", "f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))", "f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))", "f(1/sin(a*x)^2,-1/(a*tan(a*x)))", "f(1/cos(a*x)^2,tan(a*x)/a)", "f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))", "f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)", "f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))", "f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)", "f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))", "f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)", "f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)", "f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)", "f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))", "f(sin(a+b*x),-cos(a+b*x)/b)", "f(cos(a+b*x),sin(a+b*x)/b)", "f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)", "f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)", "f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)", "f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)", "f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)", "f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)", "f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)", "f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)", "f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)", "f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)", "f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)", "f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)", "f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)", "f(log(a*x),x*log(a*x)-x)", "f(x*log(a*x),x^2*log(a*x)/2-x^2/4)", "f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)", "f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)", "f(1/x*1/(a+log(x)),log(a+log(x)))", "f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)", "f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)", "f(sinh(x),cosh(x))", "f(cosh(x),sinh(x))", "f(tanh(x),log(cosh(x)))", "f(x*sinh(x),x*cosh(x)-sinh(x))", "f(x*cosh(x),x*sinh(x)-cosh(x))", "f(sinh(x)^2,sinh(2*x)/4-x/2)", "f(tanh(x)^2,x-tanh(x))", "f(cosh(x)^2,sinh(2*x)/4+x/2)", "f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)", "f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)", "f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)", "f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))", "f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)", "f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)", "f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)", "f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))", "f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))", "f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))", "f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))", "f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))", "f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))", 0];

  Eval_integral = function() {
    var ac, doNothing, i, n, o, ref, ref1;
    i = 0;
    n = 0;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
      push(symbol(NIL));
    } else if (isnum(p2)) {
      guess();
      push(p2);
    } else {
      push(p2);
      p1 = cdr(p1);
      push(car(p1));
      Eval();
    }
    p5 = pop();
    p4 = pop();
    p3 = pop();
    while (1.) {
      if (isnum(p5)) {
        push(p5);
        n = pop_integer();
        if (n === 0x80000000) {
          stop("nth integral: check n");
        }
      } else {
        n = 1;
      }
      push(p3);
      if (n >= 0) {
        for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          push(p4);
          integral();
        }
      } else {
        n = -n;
        for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
          push(p4);
          derivative();
        }
      }
      p3 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
        if (p5 === symbol(NIL)) {
          break;
        }
        if (isnum(p5)) {
          doNothing = 1;
        } else {
          p4 = p5;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p5 = pop();
        }
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    }
    return push(p3);
  };

  integral = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      integral_of_sum();
    } else if (car(p1) === symbol(MULTIPLY)) {
      integral_of_product();
    } else {
      integral_of_form();
    }
    p1 = pop();
    if (Find(p1, symbol(INTEGRAL))) {
      stop("integral: sorry, could not find a solution");
    }
    push(p1);
    simplify();
    Eval();
    return restore();
  };

  integral_of_sum = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    push(p2);
    integral();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      integral();
      add();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  integral_of_product = function() {
    push(p1);
    push(p2);
    partition();
    p1 = pop();
    integral_of_form();
    return multiply();
  };

  integral_of_form = function() {
    push(p1);
    push(p2);
    transform(itab, false);
    p3 = pop();
    if (p3 === symbol(NIL)) {
      push_symbol(INTEGRAL);
      push(p1);
      push(p2);
      return list(3);
    } else {
      return push(p3);
    }
  };

  INV_check_arg = function() {
    if (!istensor(p1)) {
      return 0;
    } else if (p1.tensor.ndim !== 2) {
      return 0;
    } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
      return 0;
    } else {
      return 1;
    }
  };

  inv = function() {
    var a, ac, accumulator, eachEntry, i, n, o, ref, ref1;
    i = 0;
    n = 0;
    save();
    p1 = pop();
    if (isinv(p1)) {
      push(car(cdr(p1)));
      restore();
      return;
    }
    if (isidentitymatrix(p1)) {
      push(p1);
      restore();
      return;
    }
    if (expanding && isinnerordot(p1)) {
      p1 = cdr(p1);
      accumulator = [];
      while (iscons(p1)) {
        accumulator.push(car(p1));
        p1 = cdr(p1);
      }
      for (eachEntry = o = ref = accumulator.length - 1; ref <= 0 ? o <= 0 : o >= 0; eachEntry = ref <= 0 ? ++o : --o) {
        push(accumulator[eachEntry]);
        inv();
        if (eachEntry !== accumulator.length - 1) {
          inner();
        }
      }
      restore();
      return;
    }
    if (INV_check_arg() === 0) {
      push_symbol(INV);
      push(p1);
      list(2);
      restore();
      return;
    }
    n = p1.tensor.nelem;
    a = p1.tensor.elem;
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (!isnum(a[i])) {
        break;
      }
    }
    if (i === n) {
      yyinvg();
    } else {
      push(p1);
      adj();
      push(p1);
      det();
      p2 = pop();
      if (iszero(p2)) {
        stop("inverse of singular matrix");
      }
      push(p2);
      divide();
    }
    return restore();
  };

  invg = function() {
    save();
    p1 = pop();
    if (INV_check_arg() === 0) {
      push_symbol(INVG);
      push(p1);
      list(2);
      restore();
      return;
    }
    yyinvg();
    return restore();
  };

  yyinvg = function() {
    var ac, ad, ae, h, i, j, n, o, ref, ref1, ref2, ref3;
    h = 0;
    i = 0;
    j = 0;
    n = 0;
    n = p1.tensor.dim[0];
    h = tos;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      for (j = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; j = 0 <= ref1 ? ++ac : --ac) {
        if (i === j) {
          push(one);
        } else {
          push(zero);
        }
      }
    }
    for (i = ad = 0, ref2 = n * n; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(p1.tensor.elem[i]);
    }
    INV_decomp(n);
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = ae = 0, ref3 = n * n; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos -= 2 * n * n;
    return push(p1);
  };

  INV_decomp = function(n) {
    var a, ac, ad, ae, d, i, j, o, ref, ref1, ref2, ref3, ref4, results, u;
    a = 0;
    d = 0;
    i = 0;
    j = 0;
    u = 0;
    a = tos - n * n;
    u = a - n * n;
    results = [];
    for (d = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; d = 0 <= ref ? ++o : --o) {
      if (equal(stack[a + n * d + d], zero)) {
        for (i = ac = ref1 = d + 1, ref2 = n; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
          if (!equal(stack[a + n * i + d], zero)) {
            break;
          }
        }
        if (i === n) {
          stop("inverse of singular matrix");
        }
        for (j = ad = 0, ref3 = n; 0 <= ref3 ? ad < ref3 : ad > ref3; j = 0 <= ref3 ? ++ad : --ad) {
          p2 = stack[a + n * d + j];
          stack[a + n * d + j] = stack[a + n * i + j];
          stack[a + n * i + j] = p2;
          p2 = stack[u + n * d + j];
          stack[u + n * d + j] = stack[u + n * i + j];
          stack[u + n * i + j] = p2;
        }
      }
      p2 = stack[a + n * d + d];
      for (j = ae = 0, ref4 = n; 0 <= ref4 ? ae < ref4 : ae > ref4; j = 0 <= ref4 ? ++ae : --ae) {
        if (j > d) {
          push(stack[a + n * d + j]);
          push(p2);
          divide();
          stack[a + n * d + j] = pop();
        }
        push(stack[u + n * d + j]);
        push(p2);
        divide();
        stack[u + n * d + j] = pop();
      }
      results.push((function() {
        var af, ref5, results1;
        results1 = [];
        for (i = af = 0, ref5 = n; 0 <= ref5 ? af < ref5 : af > ref5; i = 0 <= ref5 ? ++af : --af) {
          if (i === d) {
            continue;
          }
          p2 = stack[a + n * i + d];
          results1.push((function() {
            var ag, ref6, results2;
            results2 = [];
            for (j = ag = 0, ref6 = n; 0 <= ref6 ? ag < ref6 : ag > ref6; j = 0 <= ref6 ? ++ag : --ag) {
              if (j > d) {
                push(stack[a + n * i + j]);
                push(stack[a + n * d + j]);
                push(p2);
                multiply();
                subtract();
                stack[a + n * i + j] = pop();
              }
              push(stack[u + n * i + j]);
              push(stack[u + n * d + j]);
              push(p2);
              multiply();
              subtract();
              results2.push(stack[u + n * i + j] = pop());
            }
            return results2;
          })());
        }
        return results1;
      })());
    }
    return results;
  };

  iszero = function(p) {
    var i, o, ref;
    i = 0;
    switch (p.k) {
      case NUM:
        if (MZERO(p.q.a)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === 0.0) {
          return 1;
        }
        break;
      case TENSOR:
        for (i = o = 0, ref = p.tensor.nelem; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
          if (!iszero(p.tensor.elem[i])) {
            return 0;
          }
        }
        return 1;
    }
    return 0;
  };

  isnegativenumber = function(p) {
    switch (p.k) {
      case NUM:
        if (MSIGN(p.q.a) === -1) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d < 0.0) {
          return 1;
        }
    }
    return 0;
  };

  isplustwo = function(p) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, 2) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === 2.0) {
          return 1;
        }
    }
    return 0;
  };

  isplusone = function(p) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === 1.0) {
          return 1;
        }
    }
    return 0;
  };

  isminusone = function(p) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === -1.0) {
          return 1;
        }
    }
    return 0;
  };

  isone = function(p) {
    return isplusone(p) || isminusone(p);
  };

  isinteger = function(p) {
    if (p.k === NUM && MEQUAL(p.q.b, 1)) {
      return 1;
    } else {
      return 0;
    }
  };

  isnonnegativeinteger = function(p) {
    if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {
      return 1;
    } else {
      return 0;
    }
  };

  isposint = function(p) {
    if (isinteger(p) && MSIGN(p.q.a) === 1) {
      return 1;
    } else {
      return 0;
    }
  };

  ispoly = function(p, x) {
    if (Find(p, x)) {
      return ispoly_expr(p, x);
    } else {
      return 0;
    }
  };

  ispoly_expr = function(p, x) {
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      while (iscons(p)) {
        if (!ispoly_term(car(p), x)) {
          return 0;
        }
        p = cdr(p);
      }
      return 1;
    } else {
      return ispoly_term(p, x);
    }
  };

  ispoly_term = function(p, x) {
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      while (iscons(p)) {
        if (!ispoly_factor(car(p), x)) {
          return 0;
        }
        p = cdr(p);
      }
      return 1;
    } else {
      return ispoly_factor(p, x);
    }
  };

  ispoly_factor = function(p, x) {
    if (equal(p, x)) {
      return 1;
    }
    if (car(p) === symbol(POWER) && equal(cadr(p), x)) {
      if (isposint(caddr(p))) {
        return 1;
      } else {
        return 0;
      }
    }
    if (Find(p, x)) {
      return 0;
    } else {
      return 1;
    }
  };

  isnegativeterm = function(p) {
    if (isnegativenumber(p)) {
      return 1;
    } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isimaginarynumberdouble = function(p) {
    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isdouble(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit)) {
      return 1;
    } else {
      return 0;
    }
  };

  isimaginarynumber = function(p) {
    if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isnum(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit)) {
      return 1;
    } else {
      return 0;
    }
  };

  iscomplexnumberdouble = function(p) {
    if ((car(p) === symbol(ADD) && length(p) === 3 && isdouble(cadr(p)) && isimaginarynumberdouble(caddr(p))) || isimaginarynumberdouble(p)) {
      return 1;
    } else {
      return 0;
    }
  };

  iscomplexnumber = function(p) {
    if ((car(p) === symbol(ADD) && length(p) === 3 && isnum(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {
      return 1;
    } else {
      return 0;
    }
  };

  iseveninteger = function(p) {
    if (isinteger(p) && p.q.a.isEven()) {
      return 1;
    } else {
      return 0;
    }
  };

  isnegative = function(p) {
    if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {
      return 1;
    } else if (isnegativeterm(p)) {
      return 1;
    } else {
      return 0;
    }
  };

  issymbolic = function(p) {
    if (issymbol(p)) {
      return 1;
    } else {
      while (iscons(p)) {
        if (issymbolic(car(p))) {
          return 1;
        }
        p = cdr(p);
      }
      return 0;
    }
  };

  isintegerfactor = function(p) {
    if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isoneover = function(p) {
    if (car(p) === symbol(POWER) && isminusone(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  isfraction = function(p) {
    if (p.k === NUM && !MEQUAL(p.q.b, 1)) {
      return 1;
    } else {
      return 0;
    }
  };

  equaln = function(p, n) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === n) {
          return 1;
        }
    }
    return 0;
  };

  equalq = function(p, a, b) {
    switch (p.k) {
      case NUM:
        if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {
          return 1;
        }
        break;
      case DOUBLE:
        if (p.d === a / b) {
          return 1;
        }
    }
    return 0;
  };

  isoneovertwo = function(p) {
    if (equalq(p, 1, 2)) {
      return 1;
    } else {
      return 0;
    }
  };

  isminusoneovertwo = function(p) {
    if (equalq(p, -1, 2)) {
      return 1;
    } else {
      return 0;
    }
  };

  isoneoversqrttwo = function(p) {
    if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {
      return 1;
    } else {
      return 0;
    }
  };

  isminusoneoversqrttwo = function(p) {
    if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {
      return 1;
    } else {
      return 0;
    }
  };

  isfloating = function(p) {
    if (p.k === DOUBLE) {
      return 1;
    }
    while (iscons(p)) {
      if (isfloating(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  isimaginaryunit = function(p) {
    if (equal(p, imaginaryunit)) {
      return 1;
    } else {
      return 0;
    }
  };

  isquarterturn = function(p) {
    var minussign, n;
    n = 0;
    minussign = 0;
    if (car(p) !== symbol(MULTIPLY)) {
      return 0;
    }
    if (equal(cadr(p), imaginaryunit)) {
      if (caddr(p) !== symbol(PI)) {
        return 0;
      }
      if (length(p) !== 3) {
        return 0;
      }
      return 2;
    }
    if (!isnum(cadr(p))) {
      return 0;
    }
    if (!equal(caddr(p), imaginaryunit)) {
      return 0;
    }
    if (cadddr(p) !== symbol(PI)) {
      return 0;
    }
    if (length(p) !== 4) {
      return 0;
    }
    push(cadr(p));
    push_integer(2);
    multiply();
    n = pop_integer();
    if (n === 0x80000000) {
      return 0;
    }
    if (n < 1) {
      minussign = 1;
      n = -n;
    }
    switch (n % 4) {
      case 0:
        n = 1;
        break;
      case 1:
        if (minussign) {
          n = 4;
        } else {
          n = 3;
        }
        break;
      case 2:
        n = 2;
        break;
      case 3:
        if (minussign) {
          n = 3;
        } else {
          n = 4;
        }
    }
    return n;
  };

  isnpi = function(p) {
    var doNothing, n;
    n = 0;
    if (p === symbol(PI)) {
      return 2;
    }
    if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {
      doNothing = 0;
    } else {
      return 0;
    }
    push(cadr(p));
    push_integer(2);
    multiply();
    n = pop_integer();
    if (n === 0x80000000) {
      return 0;
    }
    if (n < 0) {
      n = 4 - (-n) % 4;
    } else {
      n = 1 + (n - 1) % 4;
    }
    return n;
  };

  $.iszero = iszero;

  $.isnegativenumber = isnegativenumber;

  $.isplusone = isplusone;

  $.isminusone = isminusone;

  $.isinteger = isinteger;

  $.isnonnegativeinteger = isnonnegativeinteger;

  $.isposint = isposint;

  $.isnegativeterm = isnegativeterm;

  $.isimaginarynumber = isimaginarynumber;

  $.iscomplexnumber = iscomplexnumber;

  $.iseveninteger = iseveninteger;

  $.isnegative = isnegative;

  $.issymbolic = issymbolic;

  $.isintegerfactor = isintegerfactor;

  $.isoneover = isoneover;

  $.isfraction = isfraction;

  $.isoneoversqrttwo = isoneoversqrttwo;

  $.isminusoneoversqrttwo = isminusoneoversqrttwo;

  $.isfloating = isfloating;

  $.isimaginaryunit = isimaginaryunit;

  $.isquarterturn = isquarterturn;

  $.isnpi = isnpi;

  Eval_isprime = function() {
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };


  /*
   Laguerre function

  Example

  	laguerre(x,3)

  Result

  	   1   3    3   2
  	- --- x  + --- x  - 3 x + 1
  	   6        2

  The computation uses the following recurrence relation.

  	L(x,0,k) = 1

  	L(x,1,k) = -x + k + 1

  	n*L(x,n,k) = (2*(n-1)+1-x+k)*L(x,n-1,k) - (n-1+k)*L(x,n-2,k)

  In the "for" loop i = n-1 so the recurrence relation becomes

  	(i+1)*L(x,n,k) = (2*i+1-x+k)*L(x,n-1,k) - (i+k)*L(x,n-2,k)
   */

  Eval_laguerre = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return laguerre();
  };

  laguerre = function() {
    var n;
    n = 0;
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push_symbol(LAGUERRE);
      push(p1);
      push(p2);
      push(p3);
      list(4);
      restore();
      return;
    }
    if (issymbol(p1)) {
      laguerre2(n);
    } else {
      p4 = p1;
      p1 = symbol(SECRETX);
      laguerre2(n);
      p1 = p4;
      push(symbol(SECRETX));
      push(p1);
      subst();
      Eval();
    }
    return restore();
  };

  laguerre2 = function(n) {
    var i, o, ref, results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p6 = pop();
    results = [];
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p5 = p6;
      p6 = pop();
      push_integer(2 * i + 1);
      push(p1);
      subtract();
      push(p3);
      add();
      push(p6);
      multiply();
      push_integer(i);
      push(p3);
      add();
      push(p5);
      multiply();
      subtract();
      push_integer(i + 1);
      results.push(divide());
    }
    return results;
  };

  Eval_lcm = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      lcm();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  lcm = function() {
    var prev_expanding;
    prev_expanding = expanding;
    save();
    yylcm();
    restore();
    return expanding = prev_expanding;
  };

  yylcm = function() {
    expanding = 1;
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    gcd();
    push(p1);
    divide();
    push(p2);
    divide();
    return inverse();
  };


  /*
   Return the leading coefficient of a polynomial.

  Example

  	leading(5x^2+x+1,x)

  Result

  	5

  The result is undefined if P is not a polynomial.
   */

  Eval_leading = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      guess();
    } else {
      push(p1);
    }
    return leading();
  };

  leading = function() {
    save();
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    degree();
    p3 = pop();
    push(p1);
    push(p2);
    push(p3);
    power();
    divide();
    push(p2);
    filter();
    return restore();
  };


  /*
   Legendre function

  Example

  	legendre(x,3,0)

  Result

  	 5   3    3
  	--- x  - --- x
  	 2        2

  The computation uses the following recurrence relation.

  	P(x,0) = 1

  	P(x,1) = x

  	n*P(x,n) = (2*(n-1)+1)*x*P(x,n-1) - (n-1)*P(x,n-2)

  In the "for" loop we have i = n-1 so the recurrence relation becomes

  	(i+1)*P(x,n) = (2*i+1)*x*P(x,n-1) - i*P(x,n-2)

  For m > 0

  	P(x,n,m) = (-1)^m * (1-x^2)^(m/2) * d^m/dx^m P(x,n)
   */

  Eval_legendre = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return legendre();
  };

  legendre = function() {
    save();
    __legendre();
    return restore();
  };

  __legendre = function() {
    var m, n;
    m = 0;
    n = 0;
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p2);
    n = pop_integer();
    push(p3);
    m = pop_integer();
    if (n < 0 || n === 0x80000000 || m < 0 || m === 0x80000000) {
      push_symbol(LEGENDRE);
      push(p1);
      push(p2);
      push(p3);
      list(4);
      return;
    }
    if (issymbol(p1)) {
      __legendre2(n, m);
    } else {
      p4 = p1;
      p1 = symbol(SECRETX);
      __legendre2(n, m);
      p1 = p4;
      push(symbol(SECRETX));
      push(p1);
      subst();
      Eval();
    }
    return __legendre3(m);
  };

  __legendre2 = function(n, m) {
    var ac, i, o, ref, ref1, results;
    i = 0;
    push_integer(1);
    push_integer(0);
    p6 = pop();
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      p5 = p6;
      p6 = pop();
      push_integer(2 * i + 1);
      push(p1);
      multiply();
      push(p6);
      multiply();
      push_integer(i);
      push(p5);
      multiply();
      subtract();
      push_integer(i + 1);
      divide();
    }
    results = [];
    for (i = ac = 0, ref1 = m; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1);
      results.push(derivative());
    }
    return results;
  };

  __legendre3 = function(m) {
    if (m === 0) {
      return;
    }
    if (car(p1) === symbol(COS)) {
      push(cadr(p1));
      sine();
      square();
    } else if (car(p1) === symbol(SIN)) {
      push(cadr(p1));
      cosine();
      square();
    } else {
      push_integer(1);
      push(p1);
      square();
      subtract();
    }
    push_integer(m);
    push_rational(1, 2);
    multiply();
    power();
    multiply();
    if (m % 2) {
      return negate();
    }
  };

  list = function(n) {
    var listIterator, o, ref, results;
    listIterator = 0;
    push(symbol(NIL));
    results = [];
    for (listIterator = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; listIterator = 0 <= ref ? ++o : --o) {
      results.push(cons());
    }
    return results;
  };

  Eval_log = function() {
    push(cadr(p1));
    Eval();
    return logarithm();
  };

  logarithm = function() {
    save();
    yylog();
    return restore();
  };

  yylog = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (p1 === symbol(E)) {
      push_integer(1);
      return;
    }
    if (equaln(p1, 1)) {
      push_integer(0);
      return;
    }
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
      logarithm();
      push(imaginaryunit);
      if (evaluatingAsFloats) {
        push_double(Math.PI);
      } else {
        push_symbol(PI);
      }
      multiply();
      add();
      return;
    }
    if (isdouble(p1)) {
      d = Math.log(p1.d);
      push_double(d);
      return;
    }
    if (isfraction(p1)) {
      push(p1);
      numerator();
      logarithm();
      push(p1);
      denominator();
      logarithm();
      subtract();
      return;
    }
    if (car(p1) === symbol(POWER)) {
      push(caddr(p1));
      push(cadr(p1));
      logarithm();
      multiply();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        logarithm();
        add();
        p1 = cdr(p1);
      }
      return;
    }
    push_symbol(LOG);
    push(p1);
    return list(2);
  };

  Eval_lookup = function() {
    p1 = cadr(p1);
    if (!iscons(p1) && cadr(p1).k === SYM) {
      p1 = get_binding(p1);
    }
    return push(p1);
  };

  madd = function(a, b) {
    return a.add(b);
  };

  msub = function(a, b) {
    return a.subtract(b);
  };

  addf = function(a, b) {
    return a.add(b);
  };

  subf = function(a, b) {
    return a.subtract(b);
  };

  ucmp = function(a, b) {
    return a.compareAbs(b);
  };


  /*
   Magnitude of complex z

  	z		mag(z)
  	-		------

  	a		a

  	-a		a

  	(-1)^a		1

  	exp(a + i b)	exp(a)

  	a b		mag(a) mag(b)

  	a + i b		sqrt(a^2 + b^2)

  Notes

  	1. Handles mixed polar and rectangular forms, e.g. 1 + exp(i pi/3)

  	2. jean-francois.debroux reports that when z=(a+i*b)/(c+i*d) then

  		mag(numerator(z)) / mag(denominator(z))

  	   must be used to get the correct answer. Now the operation is
  	   automatic.
   */

  Eval_mag = function() {
    push(cadr(p1));
    Eval();
    return mag();
  };

  mag = function() {
    save();
    p1 = pop();
    push(p1);
    numerator();
    yymag();
    push(p1);
    denominator();
    yymag();
    divide();
    return restore();
  };

  yymag = function() {
    save();
    p1 = pop();
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
    } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
      push_integer(1);
    } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
      push(caddr(p1));
      real();
      exponential();
    } else if (car(p1) === symbol(MULTIPLY)) {
      push_integer(1);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        mag();
        multiply();
        p1 = cdr(p1);
      }
    } else if (car(p1) === symbol(ADD)) {
      push(p1);
      rect();
      p1 = pop();
      push(p1);
      real();
      push_integer(2);
      power();
      push(p1);
      imag();
      push_integer(2);
      power();
      add();
      push_rational(1, 2);
      power();
      simplify_trig();
    } else {
      push(p1);
    }
    return restore();
  };

  mgcd = function(u, v) {
    return bigInt.gcd(u, v);
  };

  new_string = function(s) {
    save();
    p1 = new U();
    p1.k = STR;
    p1.str = s;
    push(p1);
    return restore();
  };

  out_of_memory = function() {
    return stop("out of memory");
  };

  push_zero_matrix = function(i, j) {
    push(alloc_tensor(i * j));
    stack[tos - 1].tensor.ndim = 2;
    stack[tos - 1].tensor.dim[0] = i;
    return stack[tos - 1].tensor.dim[1] = j;
  };

  push_identity_matrix = function(n) {
    var i, o, ref;
    push_zero_matrix(n, n);
    i = 0;
    for (i = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      stack[tos - 1].tensor.elem[i * n + i] = one;
    }
    if (stack[tos - 1].tensor.nelem !== stack[tos - 1].tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
  };

  push_cars = function(p) {
    var results;
    results = [];
    while (iscons(p)) {
      push(car(p));
      results.push(p = cdr(p));
    }
    return results;
  };

  peek = function() {
    save();
    p1 = pop();
    push(p1);
    printline(p1);
    return restore();
  };

  peek2 = function() {
    print_lisp(stack[tos - 2]);
    return print_lisp(stack[tos - 1]);
  };

  equal = function(p1, p2) {
    if (cmp_expr(p1, p2) === 0) {
      return 1;
    } else {
      return 0;
    }
  };

  lessp = function(p1, p2) {
    if (cmp_expr(p1, p2) < 0) {
      return 1;
    } else {
      return 0;
    }
  };

  sign = function(n) {
    if (n < 0) {
      return -1;
    } else if (n > 0) {
      return 1;
    } else {
      return 0;
    }
  };

  cmp_expr = function(p1, p2) {
    var n;
    n = 0;
    if (p1 === p2) {
      return 0;
    }
    if (p1 === symbol(NIL)) {
      return -1;
    }
    if (p2 === symbol(NIL)) {
      return 1;
    }
    if (isnum(p1) && isnum(p2)) {
      return sign(compare_numbers(p1, p2));
    }
    if (isnum(p1)) {
      return -1;
    }
    if (isnum(p2)) {
      return 1;
    }
    if (isstr(p1) && isstr(p2)) {
      return sign(strcmp(p1.str, p2.str));
    }
    if (isstr(p1)) {
      return -1;
    }
    if (isstr(p2)) {
      return 1;
    }
    if (issymbol(p1) && issymbol(p2)) {
      return sign(strcmp(get_printname(p1), get_printname(p2)));
    }
    if (issymbol(p1)) {
      return -1;
    }
    if (issymbol(p2)) {
      return 1;
    }
    if (istensor(p1) && istensor(p2)) {
      return compare_tensors(p1, p2);
    }
    if (istensor(p1)) {
      return -1;
    }
    if (istensor(p2)) {
      return 1;
    }
    while (iscons(p1) && iscons(p2)) {
      n = cmp_expr(car(p1), car(p2));
      if (n !== 0) {
        return n;
      }
      p1 = cdr(p1);
      p2 = cdr(p2);
    }
    if (iscons(p2)) {
      return -1;
    }
    if (iscons(p1)) {
      return 1;
    }
    return 0;
  };

  length = function(p) {
    var n;
    n = 0;
    while (iscons(p)) {
      p = cdr(p);
      n++;
    }
    return n;
  };

  unique = function(p) {
    save();
    p1 = symbol(NIL);
    p2 = symbol(NIL);
    unique_f(p);
    if (p2 !== symbol(NIL)) {
      p1 = symbol(NIL);
    }
    p = p1;
    restore();
    return p;
  };

  unique_f = function(p) {
    if (isstr(p)) {
      if (p1 === symbol(NIL)) {
        p1 = p;
      } else if (p !== p1) {
        p2 = p;
      }
      return;
    }
    while (iscons(p)) {
      unique_f(car(p));
      if (p2 !== symbol(NIL)) {
        return;
      }
      p = cdr(p);
    }
  };

  ssqrt = function() {
    push_rational(1, 2);
    return power();
  };

  yyexpand = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 1;
    Eval();
    return expanding = prev_expanding;
  };

  exponential = function() {
    push_symbol(E);
    swap();
    return power();
  };

  square = function() {
    push_integer(2);
    return power();
  };

  sort_stack = function(n) {
    var h, subsetOfStack;
    h = tos - n;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_expr);
    return stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
  };

  $.equal = equal;

  $.length = length;

  mmul = function(a, b) {
    return a.multiply(b);
  };

  mdiv = function(a, b) {
    return a.divide(b);
  };


  /*
  static void
  addf(unsigned int *a, unsigned int *b, int len)
  {
  	int i
  	long long t = 0; # can be signed or unsigned
  	for (i = 0; i < len; i++) {
  		t += (long long) a[i] + b[i]
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  }

  // a = a - b

  static void
  subf(unsigned int *a, unsigned int *b, int len)
  {
  	int i
  	long long t = 0; # must be signed
  	for (i = 0; i < len; i++) {
  		t += (long long) a[i] - b[i]
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  }

  // a = b * c

  // 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000

  static void
  mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)
  {
  	int i
  	unsigned long long t = 0; # must be unsigned
  	for (i = 0; i < len; i++) {
  		t += (unsigned long long) b[i] * c
  		a[i] = (unsigned int) t
  		t >>= 32
  	}
  	a[i] = (unsigned int) t
  }
   */

  mmod = function(a, b) {
    return a.mod(b);
  };

  mdivrem = function(a, b) {
    var toReturn;
    toReturn = a.divmod(b);
    return [toReturn.quotient, toReturn.remainder];
  };

  Eval_mod = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return mod();
  };

  mod = function() {
    var n;
    n = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (iszero(p2)) {
      stop("mod function: divide by zero");
    }
    if (!isnum(p1) || !isnum(p2)) {
      push_symbol(MOD);
      push(p1);
      push(p2);
      list(3);
      restore();
      return;
    }
    if (isdouble(p1)) {
      push(p1);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("mod function: cannot convert float value to integer");
      }
      push_integer(n);
      p1 = pop();
    }
    if (isdouble(p2)) {
      push(p2);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("mod function: cannot convert float value to integer");
      }
      push_integer(n);
      p2 = pop();
    }
    if (!isinteger(p1) || !isinteger(p2)) {
      stop("mod function: integer arguments expected");
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = mmod(p1.q.a, p2.q.a);
    p3.q.b = mint(1);
    push(p3);
    return restore();
  };

  mpow = function(a, n) {
    return a.pow(n);
  };

  mprime = function(n) {
    return n.isProbablePrime();
  };

  mroot = function(n, index) {
    var i, j, k, o, ref, x, y;
    n = n.abs();
    i = 0;
    j = 0;
    k = 0;
    if (index === 0) {
      stop("root index is zero");
    }
    k = 0;
    while (n.shiftRight(k) > 0) {
      k++;
    }
    if (k === 0) {
      return mint(0);
    }
    k = Math.floor((k - 1) / index);
    j = Math.floor(k / 32 + 1);
    x = bigInt(j);
    for (i = o = 0, ref = j; 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      x = x.and(bigInt(1).shiftLeft(i).not());
    }
    while (k >= 0) {
      x = x.or(bigInt(1).shiftLeft(k));
      y = mpow(x, index);
      switch (mcmp(y, n)) {
        case 0:
          return x;
        case 1:
          x = x.and(bigInt(1).shiftLeft(k).not());
      }
      k--;
    }
    return 0;
  };

  multiply = function() {
    if (esc_flag) {
      stop("escape key stop");
    }
    if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      return multiply_numbers();
    } else {
      save();
      yymultiply();
      return restore();
    }
  };

  yymultiply = function() {
    var h, i, n, o, ref, ref1;
    h = 0;
    i = 0;
    n = 0;
    p2 = pop();
    p1 = pop();
    h = tos;
    if (iszero(p1) || iszero(p2)) {
      push(zero);
      return;
    }
    if (expanding && isadd(p1)) {
      p1 = cdr(p1);
      push(zero);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        multiply();
        add();
        p1 = cdr(p1);
      }
      return;
    }
    if (expanding && isadd(p2)) {
      p2 = cdr(p2);
      push(zero);
      while (iscons(p2)) {
        push(p1);
        push(car(p2));
        multiply();
        add();
        p2 = cdr(p2);
      }
      return;
    }
    if (!istensor(p1) && istensor(p2)) {
      push(p1);
      push(p2);
      scalar_times_tensor();
      return;
    }
    if (istensor(p1) && !istensor(p2)) {
      push(p1);
      push(p2);
      tensor_times_scalar();
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
    } else {
      push(p1);
      list(1);
      p1 = pop();
    }
    if (car(p2) === symbol(MULTIPLY)) {
      p2 = cdr(p2);
    } else {
      push(p2);
      list(1);
      p2 = pop();
    }
    if (isnum(car(p1)) && isnum(car(p2))) {
      push(car(p1));
      push(car(p2));
      multiply_numbers();
      p1 = cdr(p1);
      p2 = cdr(p2);
    } else if (isnum(car(p1))) {
      push(car(p1));
      p1 = cdr(p1);
    } else if (isnum(car(p2))) {
      push(car(p2));
      p2 = cdr(p2);
    } else {
      push(one);
    }
    parse_p1();
    parse_p2();
    while (iscons(p1) && iscons(p2)) {
      if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
        push_symbol(OPERATOR);
        push(cdar(p1));
        push(cdar(p2));
        append();
        cons();
        p1 = cdr(p1);
        p2 = cdr(p2);
        parse_p1();
        parse_p2();
        continue;
      }
      switch (cmp_expr(p3, p4)) {
        case -1:
          push(car(p1));
          p1 = cdr(p1);
          parse_p1();
          break;
        case 1:
          push(car(p2));
          p2 = cdr(p2);
          parse_p2();
          break;
        case 0:
          combine_factors(h);
          p1 = cdr(p1);
          p2 = cdr(p2);
          parse_p1();
          parse_p2();
          break;
        default:
          stop("internal error 2");
      }
    }
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
    while (iscons(p2)) {
      push(car(p2));
      p2 = cdr(p2);
    }
    __normalize_radical_factors(h);
    if (expanding) {
      for (i = o = ref = h, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {
        if (isadd(stack[i])) {
          multiply_all(tos - h);
          return;
        }
      }
    }
    n = tos - h;
    if (n === 1) {
      return;
    }
    if (isrational(stack[h]) && equaln(stack[h], 1)) {
      if (n === 2) {
        p7 = pop();
        pop();
        push(p7);
      } else {
        stack[h] = symbol(MULTIPLY);
        list(n);
      }
      return;
    }
    list(n);
    p7 = pop();
    push_symbol(MULTIPLY);
    push(p7);
    return cons();
  };

  parse_p1 = function() {
    p3 = car(p1);
    p5 = one;
    if (car(p3) === symbol(POWER)) {
      p5 = caddr(p3);
      return p3 = cadr(p3);
    }
  };

  parse_p2 = function() {
    p4 = car(p2);
    p6 = one;
    if (car(p4) === symbol(POWER)) {
      p6 = caddr(p4);
      return p4 = cadr(p4);
    }
  };

  combine_factors = function(h) {
    push(p4);
    push(p5);
    push(p6);
    add();
    power();
    p7 = pop();
    if (isnum(p7)) {
      push(stack[h]);
      push(p7);
      multiply_numbers();
      return stack[h] = pop();
    } else if (car(p7) === symbol(MULTIPLY)) {
      if (isnum(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
        push(stack[h]);
        push(cadr(p7));
        multiply_numbers();
        stack[h] = pop();
        return push(caddr(p7));
      } else {
        return push(p7);
      }
    } else {
      return push(p7);
    }
  };

  gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];

  combine_gammas = function(h) {
    var n;
    n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
    if (n < 0) {
      n = -n;
      push(stack[h]);
      negate();
      stack[h] = pop();
    }
    if (n > 1) {
      return push(_gamma[n]);
    }
  };

  multiply_noexpand = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 0;
    multiply();
    return expanding = prev_expanding;
  };

  multiply_all = function(n) {
    var h, i, o, ref;
    i = 0;
    if (n === 1) {
      return;
    }
    if (n === 0) {
      push(one);
      return;
    }
    h = tos - n;
    push(stack[h]);
    for (i = o = 1, ref = n; 1 <= ref ? o < ref : o > ref; i = 1 <= ref ? ++o : --o) {
      push(stack[h + i]);
      multiply();
    }
    stack[h] = pop();
    return tos = h + 1;
  };

  multiply_all_noexpand = function(n) {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 0;
    multiply_all(n);
    return expanding = prev_expanding;
  };

  divide = function() {
    if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      return divide_numbers();
    } else {
      inverse();
      return multiply();
    }
  };

  inverse = function() {
    if (isnum(stack[tos - 1])) {
      return invert_number();
    } else {
      push_integer(-1);
      return power();
    }
  };

  reciprocate = function() {
    return inverse();
  };

  negate = function() {
    if (isnum(stack[tos - 1])) {
      return negate_number();
    } else {
      push_integer(-1);
      return multiply();
    }
  };

  negate_expand = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 1;
    negate();
    return expanding = prev_expanding;
  };

  negate_noexpand = function() {
    var prev_expanding;
    prev_expanding = expanding;
    expanding = 0;
    negate();
    return expanding = prev_expanding;
  };

  __normalize_radical_factors = function(h) {
    var ac, ad, i, o, ref, ref1, ref2, ref3, ref4, ref5;
    i = 0;
    if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {
      return;
    }
    for (i = o = ref = h + 1, ref1 = tos; ref <= ref1 ? o < ref1 : o > ref1; i = ref <= ref1 ? ++o : --o) {
      if (__is_radical_number(stack[i])) {
        break;
      }
    }
    if (i === tos) {
      return;
    }
    save();
    push(stack[h]);
    mp_numerator();
    p1 = pop();
    for (i = ac = ref2 = h + 1, ref3 = tos; ref2 <= ref3 ? ac < ref3 : ac > ref3; i = ref2 <= ref3 ? ++ac : --ac) {
      if (isplusone(p1) || isminusone(p1)) {
        break;
      }
      if (!__is_radical_number(stack[i])) {
        continue;
      }
      p3 = cadr(stack[i]);
      p4 = caddr(stack[i]);
      if (!isnegativenumber(p4)) {
        continue;
      }
      push(p1);
      push(p3);
      divide();
      p5 = pop();
      if (!isinteger(p5)) {
        continue;
      }
      p1 = p5;
      push_symbol(POWER);
      push(p3);
      push(one);
      push(p4);
      add();
      list(3);
      stack[i] = pop();
    }
    push(stack[h]);
    mp_denominator();
    p2 = pop();
    for (i = ad = ref4 = h + 1, ref5 = tos; ref4 <= ref5 ? ad < ref5 : ad > ref5; i = ref4 <= ref5 ? ++ad : --ad) {
      if (isplusone(p2)) {
        break;
      }
      if (!__is_radical_number(stack[i])) {
        continue;
      }
      p3 = cadr(stack[i]);
      p4 = caddr(stack[i]);
      if (isnegativenumber(p4)) {
        continue;
      }
      push(p2);
      push(p3);
      divide();
      p5 = pop();
      if (!isinteger(p5)) {
        continue;
      }
      p2 = p5;
      push_symbol(POWER);
      push(p3);
      push(p4);
      push(one);
      subtract();
      if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {
        if (isinteger(p3) && !isinteger[stack[tos - 1]] && isnegativenumber(stack[tos - 1])) {
          pop();
          pop();
          pop();
          push(p1);
          push(p3);
          divide();
          p1 = pop();
          break;
        }
      }
      list(3);
      stack[i] = pop();
    }
    push(p1);
    push(p2);
    divide();
    stack[h] = pop();
    return restore();
  };

  __is_radical_number = function(p) {
    if (car(p) === symbol(POWER) && isnum(cadr(p)) && isnum(caddr(p)) && !isminusone(cadr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  NROOTS_YMAX = 101;

  NROOTS_DELTA = 1.0e-6;

  NROOTS_EPSILON = 1.0e-9;

  NROOTS_ABS = function(z) {
    return Math.sqrt(z.r * z.r + z.i * z.i);
  };

  theRandom = 0.0;

  NROOTS_RANDOM = function() {
    return 4.0 * Math.random() - 2.0;
  };

  numericRootOfPolynomial = (function() {
    function numericRootOfPolynomial() {}

    numericRootOfPolynomial.prototype.r = 0.0;

    numericRootOfPolynomial.prototype.i = 0.0;

    return numericRootOfPolynomial;

  })();

  nroots_a = new numericRootOfPolynomial();

  nroots_b = new numericRootOfPolynomial();

  nroots_x = new numericRootOfPolynomial();

  nroots_y = new numericRootOfPolynomial();

  nroots_fa = new numericRootOfPolynomial();

  nroots_fb = new numericRootOfPolynomial();

  nroots_dx = new numericRootOfPolynomial();

  nroots_df = new numericRootOfPolynomial();

  nroots_c = [];

  for (initNRoots = o = 0, ref = NROOTS_YMAX; 0 <= ref ? o < ref : o > ref; initNRoots = 0 <= ref ? ++o : --o) {
    nroots_c[initNRoots] = new numericRootOfPolynomial();
  }

  Eval_nroots = function() {
    var ac, ad, ae, h, i, k, n, ref1, ref2, ref3;
    h = 0;
    i = 0;
    k = 0;
    n = 0;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p2 = pop();
    p1 = pop();
    if (!ispoly(p1, p2)) {
      stop("nroots: polynomial?");
    }
    h = tos;
    push(p1);
    push(p2);
    n = coeff();
    if (n > NROOTS_YMAX) {
      stop("nroots: degree?");
    }
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(stack[h + i]);
      real();
      yyfloat();
      Eval();
      p1 = pop();
      push(stack[h + i]);
      imag();
      yyfloat();
      Eval();
      p2 = pop();
      if (!isdouble(p1) || !isdouble(p2)) {
        stop("nroots: coefficients?");
      }
      nroots_c[i].r = p1.d;
      nroots_c[i].i = p2.d;
    }
    tos = h;
    monic(n);
    for (k = ad = ref2 = n; ad > 1; k = ad += -1) {
      findroot(k);
      if (Math.abs(nroots_a.r) < NROOTS_DELTA) {
        nroots_a.r = 0.0;
      }
      if (Math.abs(nroots_a.i) < NROOTS_DELTA) {
        nroots_a.i = 0.0;
      }
      push_double(nroots_a.r);
      push_double(nroots_a.i);
      push(imaginaryunit);
      multiply();
      add();
      NROOTS_divpoly(k);
    }
    n = tos - h;
    if (n > 1) {
      sort_stack(n);
      p1 = alloc_tensor(n);
      p1.tensor.ndim = 1;
      p1.tensor.dim[0] = n;
      for (i = ae = 0, ref3 = n; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
        p1.tensor.elem[i] = stack[h + i];
      }
      tos = h;
      return push(p1);
    }
  };

  monic = function(n) {
    var ac, k, ref1, t;
    k = 0;
    t = 0.0;
    nroots_y.r = nroots_c[n - 1].r;
    nroots_y.i = nroots_c[n - 1].i;
    t = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;
    for (k = ac = 0, ref1 = n - 1; 0 <= ref1 ? ac < ref1 : ac > ref1; k = 0 <= ref1 ? ++ac : --ac) {
      nroots_c[k].r = (nroots_c[k].r * nroots_y.r + nroots_c[k].i * nroots_y.i) / t;
      nroots_c[k].i = (nroots_c[k].i * nroots_y.r - nroots_c[k].r * nroots_y.i) / t;
    }
    nroots_c[n - 1].r = 1.0;
    return nroots_c[n - 1].i = 0.0;
  };

  findroot = function(n) {
    var ac, ad, j, k, nrabs, t;
    j = 0;
    k = 0;
    t = 0.0;
    if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {
      nroots_a.r = 0.0;
      nroots_a.i = 0.0;
      return;
    }
    for (j = ac = 0; ac < 100; j = ++ac) {
      nroots_a.r = NROOTS_RANDOM();
      nroots_a.i = NROOTS_RANDOM();
      compute_fa(n);
      nroots_b.r = nroots_a.r;
      nroots_b.i = nroots_a.i;
      nroots_fb.r = nroots_fa.r;
      nroots_fb.i = nroots_fa.i;
      nroots_a.r = NROOTS_RANDOM();
      nroots_a.i = NROOTS_RANDOM();
      for (k = ad = 0; ad < 1000; k = ++ad) {
        compute_fa(n);
        nrabs = NROOTS_ABS(nroots_fa);
        if (DEBUG) {
          console.log("nrabs: " + nrabs);
        }
        if (nrabs < NROOTS_EPSILON) {
          return;
        }
        if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {
          nroots_x.r = nroots_a.r;
          nroots_x.i = nroots_a.i;
          nroots_a.r = nroots_b.r;
          nroots_a.i = nroots_b.i;
          nroots_b.r = nroots_x.r;
          nroots_b.i = nroots_x.i;
          nroots_x.r = nroots_fa.r;
          nroots_x.i = nroots_fa.i;
          nroots_fa.r = nroots_fb.r;
          nroots_fa.i = nroots_fb.i;
          nroots_fb.r = nroots_x.r;
          nroots_fb.i = nroots_x.i;
        }
        nroots_dx.r = nroots_b.r - nroots_a.r;
        nroots_dx.i = nroots_b.i - nroots_a.i;
        nroots_df.r = nroots_fb.r - nroots_fa.r;
        nroots_df.i = nroots_fb.i - nroots_fa.i;
        t = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;
        if (t === 0.0) {
          break;
        }
        nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t;
        nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t;
        nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);
        nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);
      }
    }
    return stop("nroots: convergence error");
  };

  compute_fa = function(n) {
    var ac, k, ref1, results, t;
    k = 0;
    t = 0.0;
    nroots_x.r = nroots_a.r;
    nroots_x.i = nroots_a.i;
    nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;
    nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;
    results = [];
    for (k = ac = 2, ref1 = n; 2 <= ref1 ? ac < ref1 : ac > ref1; k = 2 <= ref1 ? ++ac : --ac) {
      t = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;
      nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;
      nroots_x.r = t;
      nroots_fa.r += nroots_c[k].r * nroots_x.r - nroots_c[k].i * nroots_x.i;
      results.push(nroots_fa.i += nroots_c[k].r * nroots_x.i + nroots_c[k].i * nroots_x.r);
    }
    return results;
  };

  NROOTS_divpoly = function(n) {
    var ac, ad, k, ref1, ref2, results;
    k = 0;
    for (k = ac = ref1 = n - 1; ref1 <= 0 ? ac < 0 : ac > 0; k = ref1 <= 0 ? ++ac : --ac) {
      nroots_c[k - 1].r += nroots_c[k].r * nroots_a.r - nroots_c[k].i * nroots_a.i;
      nroots_c[k - 1].i += nroots_c[k].i * nroots_a.r + nroots_c[k].r * nroots_a.i;
    }
    if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {
      stop("nroots: residual error");
    }
    results = [];
    for (k = ad = 0, ref2 = n - 1; 0 <= ref2 ? ad < ref2 : ad > ref2; k = 0 <= ref2 ? ++ad : --ad) {
      nroots_c[k].r = nroots_c[k + 1].r;
      results.push(nroots_c[k].i = nroots_c[k + 1].i);
    }
    return results;
  };

  Eval_numerator = function() {
    push(cadr(p1));
    Eval();
    return numerator();
  };

  numerator = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push(p1);
      rationalize();
      p1 = pop();
    }
    if (car(p1) === symbol(MULTIPLY)) {
      h = tos;
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        numerator();
        p1 = cdr(p1);
      }
      multiply_all(tos - h);
    } else if (isrational(p1)) {
      push(p1);
      mp_numerator();
    } else if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
      push(one);
    } else {
      push(p1);
    }
    return restore();
  };

  Eval_outer = function() {
    var results;
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    results = [];
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      outer();
      results.push(p1 = cdr(p1));
    }
    return results;
  };

  outer = function() {
    save();
    p2 = pop();
    p1 = pop();
    if (istensor(p1) && istensor(p2)) {
      yyouter();
    } else {
      push(p1);
      push(p2);
      if (istensor(p1)) {
        tensor_times_scalar();
      } else if (istensor(p2)) {
        scalar_times_tensor();
      } else {
        multiply();
      }
    }
    return restore();
  };

  yyouter = function() {
    var ac, ad, ae, af, i, j, k, ndim, nelem, ref1, ref2, ref3, ref4;
    i = 0;
    j = 0;
    k = 0;
    ndim = 0;
    nelem = 0;
    ndim = p1.tensor.ndim + p2.tensor.ndim;
    if (ndim > MAXDIM) {
      stop("outer: rank of result exceeds maximum");
    }
    nelem = p1.tensor.nelem * p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    j = i;
    for (i = ad = 0, ref2 = p2.tensor.ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      p3.tensor.dim[j + i] = p2.tensor.dim[i];
    }
    k = 0;
    for (i = ae = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      for (j = af = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? af < ref4 : af > ref4; j = 0 <= ref4 ? ++af : --af) {
        push(p1.tensor.elem[i]);
        push(p2.tensor.elem[j]);
        multiply();
        p3.tensor.elem[k++] = pop();
      }
    }
    return push(p3);
  };


  /*
   Partition a term

  	Input stack:

  		term (factor or product of factors)

  		free variable

  	Output stack:

  		constant expression

  		variable expression
   */

  partition = function() {
    save();
    p2 = pop();
    p1 = pop();
    push_integer(1);
    p3 = pop();
    p4 = p3;
    p1 = cdr(p1);
    while (iscons(p1)) {
      if (Find(car(p1), p2)) {
        push(p4);
        push(car(p1));
        multiply();
        p4 = pop();
      } else {
        push(p3);
        push(car(p1));
        multiply();
        p3 = pop();
      }
      p1 = cdr(p1);
    }
    push(p3);
    push(p4);
    return restore();
  };


  /*
  Convert complex z to polar form

  	Input:		push	z

  	Output:		Result on stack

  	polar(z) = mag(z) * exp(i * arg(z))
   */

  Eval_polar = function() {
    push(cadr(p1));
    Eval();
    return polar();
  };

  polar = function() {
    save();
    p1 = pop();
    push(p1);
    mag();
    push(imaginaryunit);
    push(p1);
    arg();
    multiply();
    exponential();
    multiply();
    return restore();
  };

  n_factor_number = 0;

  factor_number = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {
      push(p1);
      restore();
      return;
    }
    n_factor_number = p1.q.a;
    h = tos;
    factor_a();
    if (tos - h > 1) {
      list(tos - h);
      push_symbol(MULTIPLY);
      swap();
      cons();
    }
    return restore();
  };

  factor_a = function() {
    var ac, k;
    k = 0;
    if (n_factor_number.isNegative()) {
      n_factor_number = setSignTo(n_factor_number, 1);
      push_integer(-1);
    }
    for (k = ac = 0; ac < 10000; k = ++ac) {
      try_kth_prime(k);
      if (n_factor_number.compare(1) === 0) {
        return;
      }
    }
    return factor_b();
  };

  try_kth_prime = function(k) {
    var count, d, q, r, ref1;
    count = 0;
    d = mint(primetab[k]);
    count = 0;
    while (1.) {
      if (n_factor_number.compare(1) === 0) {
        if (count) {
          push_factor(d, count);
        }
        return;
      }
      ref1 = mdivrem(n_factor_number, d), q = ref1[0], r = ref1[1];
      if (r.isZero()) {
        count++;
        n_factor_number = q;
      } else {
        break;
      }
    }
    if (count) {
      push_factor(d, count);
    }
    if (mcmp(q, d) === -1) {
      push_factor(n_factor_number, 1);
      return n_factor_number = mint(1);
    }
  };

  factor_b = function() {
    var bigint_one, g, k, l, t, x, xprime;
    k = 0;
    l = 0;
    bigint_one = mint(1);
    x = mint(5);
    xprime = mint(2);
    k = 1;
    l = 1;
    while (1.) {
      if (mprime(n_factor_number)) {
        push_factor(n_factor_number, 1);
        return 0;
      }
      while (1.) {
        if (esc_flag) {
          stop("esc");
        }
        t = msub(xprime, x);
        t = setSignTo(t, 1);
        g = mgcd(t, n_factor_number);
        if (MEQUAL(g, 1)) {
          if (--k === 0) {
            xprime = x;
            l *= 2;
            k = l;
          }
          t = mmul(x, x);
          x = madd(t, bigint_one);
          t = mmod(x, n_factor_number);
          x = t;
          continue;
        }
        push_factor(g, 1);
        if (mcmp(g, n_factor_number) === 0) {
          return -1;
        }
        t = mdiv(n_factor_number, g);
        n_factor_number = t;
        t = mmod(x, n_factor_number);
        x = t;
        t = mmod(xprime, n_factor_number);
        xprime = t;
        break;
      }
    }
  };

  push_factor = function(d, count) {
    p1 = new U();
    p1.k = NUM;
    p1.q.a = d;
    p1.q.b = mint(1);
    push(p1);
    if (count > 1) {
      push_symbol(POWER);
      swap();
      p1 = new U();
      p1.k = NUM;
      p1.q.a = mint(count);
      p1.q.b = mint(1);
      push(p1);
      return list(3);
    }
  };


  /* Power function

  	Input:		push	Base

  			push	Exponent

  	Output:		Result on stack
   */

  Eval_power = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    return power();
  };

  power = function() {
    save();
    yypower();
    return restore();
  };

  yypower = function() {
    var n;
    n = 0;
    p2 = pop();
    p1 = pop();
    if (equal(p1, one) || iszero(p2)) {
      push(one);
      return;
    }
    if (equal(p2, one)) {
      push(p1);
      return;
    }
    if (isminusone(p1) && isminusone(p2)) {
      push(one);
      negate();
      return;
    }
    if (isminusone(p1) && (isoneovertwo(p2))) {
      push(imaginaryunit);
      return;
    }
    if (isminusone(p1) && isminusoneovertwo(p2)) {
      push(imaginaryunit);
      negate();
      return;
    }
    if (isrational(p1) && isrational(p2)) {
      push(p1);
      push(p2);
      qpow();
      return;
    }
    if (isnum(p1) && isnum(p2)) {
      push(p1);
      push(p2);
      dpow();
      return;
    }
    if (istensor(p1)) {
      power_tensor();
      return;
    }
    if (p1 === symbol(E) && car(p2) === symbol(LOG)) {
      push(cadr(p2));
      return;
    }
    if (p1 === symbol(E) && isdouble(p2)) {
      push_double(Math.exp(p2.d));
      return;
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      push(car(p1));
      push(p2);
      power();
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        power();
        multiply();
        p1 = cdr(p1);
      }
      return;
    }
    if (car(p1) === symbol(POWER)) {
      push(cadr(p1));
      push(caddr(p1));
      push(p2);
      multiply();
      power();
      return;
    }
    if (expanding && isadd(p1) && isnum(p2)) {
      push(p2);
      n = pop_integer();
      if (n > 1 && n !== 0x80000000) {
        power_sum(n);
        return;
      }
    }
    if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {
      push_integer(1);
      push(cadr(p1));
      cosine();
      push_integer(2);
      power();
      subtract();
      push(p2);
      push_rational(1, 2);
      multiply();
      power();
      return;
    }
    if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {
      push_integer(1);
      push(cadr(p1));
      sine();
      push_integer(2);
      power();
      subtract();
      push(p2);
      push_rational(1, 2);
      multiply();
      power();
      return;
    }
    if (iscomplexnumber(p1)) {
      if (isinteger(p2)) {
        push(p1);
        conjugate();
        p3 = pop();
        push(p3);
        push(p3);
        push(p1);
        multiply();
        divide();
        push(p2);
        negate();
        power();
        return;
      }
      if (isnum(p2)) {
        push(p1);
        mag();
        push(p2);
        power();
        push_integer(-1);
        push(p1);
        arg();
        push(p2);
        multiply();
        if (evaluatingAsFloats || (iscomplexnumberdouble(p1) && isdouble(p2))) {
          push_double(Math.PI);
        } else {
          push(symbol(PI));
        }
        divide();
        power();
        multiply();
        if (avoidCalculatingPowersIntoArctans) {
          if (Find(stack[tos - 1], symbol(ARCTAN))) {
            pop();
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
          }
        }
        return;
      }
    }
    if (simplify_polar()) {
      return;
    }
    push_symbol(POWER);
    push(p1);
    push(p2);
    return list(3);
  };

  power_sum = function(n) {
    var a, ac, ad, ae, i, j, k, ref1, ref2, ref3;
    a = [];
    i = 0;
    j = 0;
    k = 0;
    k = length(p1) - 1;
    push_frame(k * (n + 1));
    p1 = cdr(p1);
    for (i = ac = 0, ref1 = k; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      for (j = ad = 0, ref2 = n; 0 <= ref2 ? ad <= ref2 : ad >= ref2; j = 0 <= ref2 ? ++ad : --ad) {
        push(car(p1));
        push_integer(j);
        power();
        stack[frame + i * (n + 1) + j] = pop();
      }
      p1 = cdr(p1);
    }
    push_integer(n);
    factorial();
    p1 = pop();
    for (i = ae = 0, ref3 = k; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      a[i] = 0;
    }
    push(zero);
    multinomial_sum(k, n, a, 0, n);
    return pop_frame(k * (n + 1));
  };

  multinomial_sum = function(k, n, a, i, m) {
    var ac, ad, ae, j, ref1, ref2, ref3;
    j = 0;
    if (i < k - 1) {
      for (j = ac = 0, ref1 = m; 0 <= ref1 ? ac <= ref1 : ac >= ref1; j = 0 <= ref1 ? ++ac : --ac) {
        a[i] = j;
        multinomial_sum(k, n, a, i + 1, m - j);
      }
      return;
    }
    a[i] = m;
    push(p1);
    for (j = ad = 0, ref2 = k; 0 <= ref2 ? ad < ref2 : ad > ref2; j = 0 <= ref2 ? ++ad : --ad) {
      push_integer(a[j]);
      factorial();
      divide();
    }
    for (j = ae = 0, ref3 = k; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
      push(stack[frame + j * (n + 1) + a[j]]);
      multiply();
    }
    return add();
  };

  simplify_polar = function() {
    var doNothing, n;
    n = 0;
    n = isquarterturn(p2);
    switch (n) {
      case 0:
        doNothing = 1;
        break;
      case 1:
        push_integer(1);
        return 1;
      case 2:
        push_integer(-1);
        return 1;
      case 3:
        push(imaginaryunit);
        return 1;
      case 4:
        push(imaginaryunit);
        negate();
        return 1;
    }
    if (car(p2) === symbol(ADD)) {
      p3 = cdr(p2);
      while (iscons(p3)) {
        n = isquarterturn(car(p3));
        if (n) {
          break;
        }
        p3 = cdr(p3);
      }
      switch (n) {
        case 0:
          return 0;
        case 1:
          push_integer(1);
          break;
        case 2:
          push_integer(-1);
          break;
        case 3:
          push(imaginaryunit);
          break;
        case 4:
          push(imaginaryunit);
          negate();
      }
      push(p2);
      push(car(p3));
      subtract();
      exponential();
      multiply();
      return 1;
    }
    return 0;
  };

  Eval_prime = function() {
    push(cadr(p1));
    Eval();
    return prime();
  };

  prime = function() {
    var n;
    n = 0;
    n = pop_integer();
    if (n < 1 || n > MAXPRIMETAB) {
      stop("prime: Argument out of range.");
    }
    n = primetab[n - 1];
    return push_integer(n);
  };

  power_str = "^";

  stringToBePrinted = "";

  latexMode = false;

  codeGen = false;

  Eval_printlatex = function() {
    latexMode = true;
    Eval_display();
    return latexMode = false;
  };

  Eval_printlist = function() {
    push(car(cdr(p1)));
    Eval();
    p1 = pop();
    print1(p1);
    return push(symbol(NIL));
  };

  Eval_display = function() {
    var beenPrinted, parsedString;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p2 = pop();

      /*
      		if (issymbol(car(p1)) && car(p1) != p2)
      			push_symbol(SETQ);
      			push(car(p1));
      			push(p2);
      			list(3);
      			p2 = pop();
       */
      if (equaln(get_binding(symbol(TTY)), 1)) {
        beenPrinted = printline(p2);
      } else {
        beenPrinted = printline(p2);
      }
      if (latexMode) {
        scan('"' + beenPrinted + '"');
        parsedString = pop();
        set_binding(symbol(LAST_LATEX_PRINT), parsedString);
      }
      p1 = cdr(p1);
    }
    return push(symbol(NIL));
  };

  print_str = function(s) {
    return stringToBePrinted += s;
  };

  print_char = function(c) {
    return stringToBePrinted += c;
  };

  collectPlainResultLine = function(p) {
    stringToBePrinted = "";
    print_expr(p);
    return stringToBePrinted;
  };

  collectLatexResultLine = function(p) {
    stringToBePrinted = "";
    latexMode = true;
    print_expr(p);
    latexMode = false;
    return stringToBePrinted;
  };

  printline = function(p) {
    stringToBePrinted = "";
    print_expr(p);
    console.log(stringToBePrinted);
    return stringToBePrinted;
  };

  print_base_of_denom = function(p1) {
    if (isfraction(p1) || car(p1) === symbol(ADD) || car(p1) === symbol(MULTIPLY) || car(p1) === symbol(POWER) || lessp(p1, zero)) {
      print_char('(');
      print_expr(p1);
      return print_char(')');
    } else {
      return print_expr(p1);
    }
  };

  print_expo_of_denom = function(p2) {
    if (isfraction(p2) || car(p2) === symbol(ADD) || car(p2) === symbol(MULTIPLY) || car(p2) === symbol(POWER)) {
      print_char('(');
      print_expr(p2);
      return print_char(')');
    } else {
      return print_expr(p2);
    }
  };

  print_denom = function(p, d) {
    save();
    p1 = cadr(p);
    p2 = caddr(p);
    if (isminusone(p2)) {
      print_base_of_denom(p1);
      restore();
      return;
    }
    if (d === 1) {
      print_char('(');
    }
    push(p2);
    negate();
    p2 = pop();
    print_power(p1, p2);
    if (d === 1) {
      print_char(')');
    }
    return restore();
  };

  print_a_over_b = function(p) {
    var d, doNothing, n;
    flag = 0;
    n = 0;
    d = 0;
    save();
    n = 0;
    d = 0;
    p1 = cdr(p);
    p2 = car(p1);
    if (isrational(p2)) {
      push(p2);
      mp_numerator();
      absval();
      p3 = pop();
      push(p2);
      mp_denominator();
      p4 = pop();
      if (!isplusone(p3)) {
        n++;
      }
      if (!isplusone(p4)) {
        d++;
      }
      p1 = cdr(p1);
    } else {
      p3 = one;
      p4 = one;
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (is_denominator(p2)) {
        d++;
      } else {
        n++;
      }
      p1 = cdr(p1);
    }
    if (latexMode) {
      print_str('\\frac{');
    }
    if (n === 0) {
      print_char('1');
    } else {
      flag = 0;
      p1 = cdr(p);
      if (isrational(car(p1))) {
        p1 = cdr(p1);
      }
      if (!isplusone(p3)) {
        print_factor(p3);
        flag = 1;
      }
      while (iscons(p1)) {
        p2 = car(p1);
        if (is_denominator(p2)) {
          doNothing = 1;
        } else {
          if (flag) {
            print_multiply_sign();
          }
          print_factor(p2);
          flag = 1;
        }
        p1 = cdr(p1);
      }
    }
    if (latexMode) {
      print_str('}{');
    } else if (test_flag === 0) {
      print_str(" / ");
    } else {
      print_str("/");
    }
    if (d > 1 && !latexMode) {
      print_char('(');
    }
    flag = 0;
    p1 = cdr(p);
    if (isrational(car(p1))) {
      p1 = cdr(p1);
    }
    if (!isplusone(p4)) {
      print_factor(p4);
      flag = 1;
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (is_denominator(p2)) {
        if (flag) {
          print_multiply_sign();
        }
        print_denom(p2, d);
        flag = 1;
      }
      p1 = cdr(p1);
    }
    if (d > 1 && !latexMode) {
      print_char(')');
    }
    if (latexMode) {
      print_str('}');
    }
    return restore();
  };

  print_expr = function(p) {
    var results;
    if (isadd(p)) {
      p = cdr(p);
      if (sign_of_term(car(p)) === '-') {
        print_str("-");
      }
      print_term(car(p));
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        if (sign_of_term(car(p)) === '+') {
          if (test_flag === 0) {
            print_str(" + ");
          } else {
            print_str("+");
          }
        } else {
          if (test_flag === 0) {
            print_str(" - ");
          } else {
            print_str("-");
          }
        }
        print_term(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      if (sign_of_term(p) === '-') {
        print_str("-");
      }
      return print_term(p);
    }
  };

  sign_of_term = function(p) {
    if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && lessp(cadr(p), zero)) {
      return '-';
    } else if (isnum(p) && lessp(p, zero)) {
      return '-';
    } else {
      return '+';
    }
  };

  print_term = function(p) {
    var results;
    if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {
      print_a_over_b(p);
      return;
    }
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      if (isminusone(car(p))) {
        p = cdr(p);
      }
      print_factor(car(p));
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        print_multiply_sign();
        print_factor(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      return print_factor(p);
    }
  };

  print_subexpr = function(p) {
    print_char('(');
    print_expr(p);
    return print_char(')');
  };

  print_factorial_function = function(p) {
    p = cadr(p);
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
      print_subexpr(p);
    } else {
      print_expr(p);
    }
    return print_char('!');
  };

  print_ABS_latex = function(p) {
    print_str("\\left |");
    print_expr(cadr(p));
    return print_str(" \\right |");
  };

  print_BINOMIAL_latex = function(p) {
    print_str("\\binom{");
    print_expr(cadr(p));
    print_str("}{");
    print_expr(caddr(p));
    if (test_flag === 0) {
      return print_str("} ");
    } else {
      return print_str("}");
    }
  };

  print_DOT_latex = function(p) {
    if (test_flag === 0) {
      print_str(" ");
    }
    print_expr(cadr(p));
    if (test_flag === 0) {
      print_str(" \\cdot ");
    } else {
      print_str("\\cdot ");
    }
    print_expr(caddr(p));
    if (test_flag === 0) {
      return print_str(" ");
    }
  };

  print_SQRT_latex = function(p) {
    print_str("\\sqrt{");
    print_expr(cadr(p));
    if (test_flag === 0) {
      return print_str("} ");
    } else {
      return print_str("}");
    }
  };

  print_TRANSPOSE_latex = function(p) {
    print_str("{");
    if (iscons(cadr(p))) {
      print_str("(");
    }
    print_expr(cadr(p));
    if (iscons(cadr(p))) {
      print_str(")");
    }
    print_str("}");
    return print_str("^T");
  };

  print_INV_latex = function(p) {
    print_str("{");
    if (iscons(cadr(p))) {
      print_str("(");
    }
    print_expr(cadr(p));
    if (iscons(cadr(p))) {
      print_str(")");
    }
    print_str("}");
    return print_str("^{-1}");
  };

  print_DEFINT_latex = function(p) {
    var ac, functionBody, i, numberOfIntegrals, originalIntegral, ref1, results, theIntegral, theVariable;
    functionBody = car(cdr(p));
    p = cdr(p);
    originalIntegral = p;
    numberOfIntegrals = 0;
    while (iscons(cdr(cdr(p)))) {
      numberOfIntegrals++;
      theIntegral = cdr(cdr(p));
      print_str("\\int^{");
      print_expr(car(cdr(theIntegral)));
      print_str("}_{");
      print_expr(car(theIntegral));
      if (test_flag === 0) {
        print_str("} \\! ");
      } else {
        print_str("}\\!");
      }
      p = cdr(theIntegral);
    }
    print_expr(functionBody);
    if (test_flag === 0) {
      print_str(" \\,");
    } else {
      print_str("\\,");
    }
    p = originalIntegral;
    results = [];
    for (i = ac = 1, ref1 = numberOfIntegrals; 1 <= ref1 ? ac <= ref1 : ac >= ref1; i = 1 <= ref1 ? ++ac : --ac) {
      theVariable = cdr(p);
      if (test_flag === 0) {
        print_str(" \\mathrm{d} ");
      } else {
        print_str("\\mathrm{d}");
      }
      print_expr(car(theVariable));
      if (i < numberOfIntegrals) {
        if (test_flag === 0) {
          print_str(" \\, ");
        } else {
          print_str("\\,");
        }
      }
      results.push(p = cdr(cdr(theVariable)));
    }
    return results;
  };

  print_tensor = function(p) {
    return print_tensor_inner(p, 0, 0);
  };

  print_tensor_inner = function(p, j, k) {
    var ac, i, ref1;
    i = 0;
    if (codeGen) {
      print_str("[");
    } else {
      print_str("(");
    }
    for (i = ac = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (j + 1 === p.tensor.ndim) {
        print_expr(p.tensor.elem[k]);
        k++;
      } else {
        k = print_tensor_inner(p, j + 1, k);
      }
      if (i + 1 < p.tensor.dim[j]) {
        if (test_flag === 0) {
          print_str(",");
        } else {
          print_str(",");
        }
      }
    }
    if (codeGen) {
      print_str("]");
    } else {
      print_str(")");
    }
    return k;
  };

  print_base = function(p) {
    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {
      print_str("(");
      print_expr(cadr(p));
      return print_str(")");
    } else if (isnum(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {
      print_str("(");
      print_factor(cadr(p));
      return print_str(")");
    } else {
      return print_factor(cadr(p));
    }
  };

  print_exponent = function(p) {
    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isnum(caddr(p)) && lessp(caddr(p), zero))) {
      print_str("(");
      print_expr(caddr(p));
      return print_str(")");
    } else {
      return print_factor(caddr(p));
    }
  };

  print_power = function(base, exponent) {
    var denomExponent, newExponent, numExponent;
    if (codeGen) {
      print_str("Math.pow(");
      print_base_of_denom(base);
      print_str(", ");
      print_expo_of_denom(exponent);
      print_str(")");
      return;
    }
    if ((equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1)) && base === symbol(E)) {
      if (latexMode) {
        print_str("e^{");
        print_expr(exponent);
        print_str("}");
      } else {
        print_str("exp(");
        print_expr(exponent);
        print_str(")");
      }
      return;
    }
    if ((equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0)) || base.printname !== "x") {
      if (base !== symbol(E)) {
        if (isminusone(exponent)) {
          if (latexMode) {
            print_str("\\frac{1}{");
          } else if (test_flag === 0) {
            print_str("1 / ");
          } else {
            print_str("1/");
          }
          if (iscons(base) && !latexMode) {
            print_str("(");
            print_expr(base);
            print_str(")");
          } else {
            print_expr(base);
          }
          if (latexMode) {
            print_str("}");
          }
          return;
        }
        if (isnegativeterm(exponent)) {
          if (latexMode) {
            print_str("\\frac{1}{");
          } else if (test_flag === 0) {
            print_str("1 / ");
          } else {
            print_str("1/");
          }
          push(exponent);
          push_integer(-1);
          multiply();
          newExponent = pop();
          if (iscons(base) && !latexMode) {
            print_str("(");
            print_power(base, newExponent);
            print_str(")");
          } else {
            print_power(base, newExponent);
          }
          if (latexMode) {
            print_str("}");
          }
          return;
        }
      }
      if (isfraction(exponent) && latexMode) {
        print_str("\\sqrt");
        push(exponent);
        denominator();
        denomExponent = pop();
        if (!isplustwo(denomExponent)) {
          print_str("[");
          print_expr(denomExponent);
          print_str("]");
        }
        print_str("{");
        push(exponent);
        numerator();
        numExponent = pop();
        exponent = numExponent;
        print_power(base, exponent);
        print_str("}");
        return;
      }
    }
    if (latexMode && isplusone(exponent)) {
      return print_expr(base);
    } else {
      if (isadd(base) || isnegativenumber(base)) {
        print_str("(");
        print_expr(base);
        print_str(")");
      } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {
        if (!latexMode) {
          print_str("(");
        }
        print_factor(base);
        if (!latexMode) {
          print_str(")");
        }
      } else if (isnum(base) && (lessp(base, zero) || isfraction(base))) {
        print_str("(");
        print_factor(base);
        print_str(")");
      } else {
        print_factor(base);
      }
      if (test_flag === 0) {
        print_str(power_str);
      } else {
        print_str("^");
      }
      if (iscons(exponent) || isfraction(exponent) || (isnum(exponent) && lessp(exponent, zero))) {
        if (latexMode) {
          print_str("{");
        } else {
          print_str("(");
        }
        print_expr(exponent);
        if (latexMode) {
          return print_str("}");
        } else {
          return print_str(")");
        }
      } else {
        return print_factor(exponent);
      }
    }
  };

  print_index_function = function(p) {
    p = cdr(p);
    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {
      print_subexpr(car(p));
    } else {
      print_expr(car(p));
    }
    print_str('[');
    p = cdr(p);
    if (iscons(p)) {
      print_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        print_str(',');
        print_expr(car(p));
        p = cdr(p);
      }
    }
    return print_str(']');
  };

  print_factor = function(p) {
    var base, exponent, fbody, parameters;
    if (isnum(p)) {
      print_number(p, false);
      return;
    }
    if (isstr(p)) {
      print_str("\"");
      print_str(p.str);
      print_str("\"");
      return;
    }
    if (istensor(p)) {
      print_tensor(p);
      return;
    }
    if (car(p) === symbol(MULTIPLY)) {
      if (sign_of_term(p) === '-' || !latexMode) {
        if (latexMode) {
          print_str(" \\left (");
        } else {
          print_str("(");
        }
      }
      print_expr(p);
      if (sign_of_term(p) === '-' || !latexMode) {
        if (latexMode) {
          print_str(" \\right ) ");
        } else {
          print_str("(");
        }
      }
      return;
    } else if (isadd(p)) {
      print_str("(");
      print_expr(p);
      print_str(")");
      return;
    }
    if (car(p) === symbol(POWER)) {
      base = cadr(p);
      exponent = caddr(p);
      print_power(base, exponent);
      return;
    }
    if (car(p) === symbol(FUNCTION)) {
      fbody = cadr(p);
      if (!codeGen) {
        parameters = caddr(p);
        print_str("function ");
        stringToBePrinted = print1(parameters, stringToBePrinted);
        print_str(" -> ");
        print_expr(fbody);
      } else {
        push(fbody);
        eval();
        simplify();
        fbody = pop();
        print_expr(fbody);
      }
      return;
    }
    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
      print_index_function(p);
      return;
    }
    if (car(p) === symbol(FACTORIAL)) {
      print_factorial_function(p);
      return;
    } else if (car(p) === symbol(ABS) && latexMode) {
      print_ABS_latex(p);
      return;
    } else if (car(p) === symbol(SQRT) && latexMode) {
      print_SQRT_latex(p);
      return;
    } else if (car(p) === symbol(TRANSPOSE) && latexMode) {
      print_TRANSPOSE_latex(p);
      return;
    } else if (car(p) === symbol(INV) && latexMode) {
      print_INV_latex(p);
      return;
    } else if (car(p) === symbol(BINOMIAL) && latexMode) {
      print_BINOMIAL_latex(p);
      return;
    } else if (car(p) === symbol(DEFINT) && latexMode) {
      print_DEFINT_latex(p);
      return;
    } else if ((car(p) === symbol(DOT) || car(p) === symbol(INNER)) && latexMode) {
      print_DOT_latex(p);
      return;
    }
    if (iscons(p)) {
      print_factor(car(p));
      p = cdr(p);
      print_str("(");
      if (iscons(p)) {
        print_expr(car(p));
        p = cdr(p);
        while (iscons(p)) {
          if (test_flag === 0) {
            print_str(",");
          } else {
            print_str(",");
          }
          print_expr(car(p));
          p = cdr(p);
        }
      }
      print_str(")");
      return;
    }
    if (p === symbol(DERIVATIVE)) {
      return print_char('d');
    } else if (p === symbol(E)) {
      if (latexMode) {
        return print_str("e");
      } else {
        return print_str("exp(1)");
      }
    } else if (p === symbol(PI)) {
      if (latexMode) {
        return print_str("\\pi");
      } else {
        return print_str("pi");
      }
    } else {
      return print_str(get_printname(p));
    }
  };

  print1 = function(p, accumulator) {
    var topLevelCall;
    topLevelCall = false;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    switch (p.k) {
      case CONS:
        accumulator += "(";
        accumulator = print1(car(p), accumulator);
        if (p === cdr(p) && p !== symbol(NIL)) {
          console.log("oh no recursive!");
          debugger;
        }
        p = cdr(p);
        while (iscons(p)) {
          accumulator += " ";
          accumulator = print1(car(p), accumulator);
          p = cdr(p);
          if (p === cdr(p) && p !== symbol(NIL)) {
            console.log("oh no recursive!");
            debugger;
          }
        }
        if (p !== symbol(NIL)) {
          accumulator += " . ";
          accumulator = print1(p, accumulator);
        }
        accumulator += ")";
        break;
      case STR:
        accumulator += p.str;
        break;
      case NUM:
      case DOUBLE:
        accumulator = print_number(p, true, accumulator);
        break;
      case SYM:
        accumulator += get_printname(p);
        break;
      default:
        accumulator += "<tensor>";
    }
    if (topLevelCall) {
      return console.log(accumulator);
    } else {
      return accumulator;
    }
  };

  print_multiply_sign = function() {
    if (latexMode) {
      if (test_flag === 0) {
        print_str(" ");
      } else {
        return;
      }
    }
    if (test_flag === 0 && !codeGen) {
      return print_str(" ");
    } else {
      return print_str("*");
    }
  };

  is_denominator = function(p) {
    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  any_denominators = function(p) {
    var q;
    p = cdr(p);
    while (iscons(p)) {
      q = car(p);
      if (is_denominator(q)) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  Eval_product = function() {
    var ac, i, j, k, ref1, ref2;
    i = 0;
    j = 0;
    k = 0;
    p6 = cadr(p1);
    if (!issymbol(p6)) {
      stop("product: 1st arg?");
    }
    push(caddr(p1));
    Eval();
    j = pop_integer();
    if (j === 0x80000000) {
      stop("product: 2nd arg?");
    }
    push(cadddr(p1));
    Eval();
    k = pop_integer();
    if (k === 0x80000000) {
      stop("product: 3rd arg?");
    }
    p1 = caddddr(p1);
    p4 = get_binding(p6);
    push_integer(1);
    for (i = ac = ref1 = j, ref2 = k; ref1 <= ref2 ? ac <= ref2 : ac >= ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      push_integer(i);
      p5 = pop();
      set_binding(p6, p5);
      push(p1);
      Eval();
      multiply();
    }
    return set_binding(p6, p4);
  };

  qadd = function() {
    var a, ab, b, ba, c;
    save();
    p2 = pop();
    p1 = pop();
    ab = mmul(p1.q.a, p2.q.b);
    ba = mmul(p1.q.b, p2.q.a);
    a = madd(ab, ba);
    if (MZERO(a)) {
      push(zero);
      restore();
      return;
    }
    b = mmul(p1.q.b, p2.q.b);
    c = mgcd(a, b);
    c = makeSignSameAs(c, b);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(a, c);
    p1.q.b = mdiv(b, c);
    push(p1);
    return restore();
  };

  qdiv = function() {
    var aa, bb, c;
    save();
    p2 = pop();
    p1 = pop();
    if (MZERO(p2.q.a)) {
      stop("divide by zero");
    }
    if (MZERO(p1.q.a)) {
      push(zero);
      restore();
      return;
    }
    aa = mmul(p1.q.a, p2.q.b);
    bb = mmul(p1.q.b, p2.q.a);
    c = mgcd(aa, bb);
    c = makeSignSameAs(c, bb);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(aa, c);
    p1.q.b = mdiv(bb, c);
    push(p1);
    return restore();
  };

  qmul = function() {
    var aa, bb, c;
    save();
    p2 = pop();
    p1 = pop();
    if (MZERO(p1.q.a) || MZERO(p2.q.a)) {
      push(zero);
      restore();
      return;
    }
    aa = mmul(p1.q.a, p2.q.a);
    bb = mmul(p1.q.b, p2.q.b);
    c = mgcd(aa, bb);
    c = makeSignSameAs(c, bb);
    p1 = new U();
    p1.k = NUM;
    p1.q.a = mdiv(aa, c);
    p1.q.b = mdiv(bb, c);
    push(p1);
    return restore();
  };

  qpow = function() {
    save();
    qpowf();
    return restore();
  };

  qpowf = function() {
    var a, b, expo, t, x, y;
    expo = 0;
    p2 = pop();
    p1 = pop();
    if (isplusone(p1) || iszero(p2)) {
      push_integer(1);
      return;
    }
    if (iszero(p1)) {
      if (isnegativenumber(p2)) {
        debugger;
        stop("divide by zero");
      }
      push(zero);
      return;
    }
    if (isplusone(p2)) {
      push(p1);
      return;
    }
    if (isinteger(p2)) {
      push(p2);
      expo = pop_integer();
      if (expo === 0x80000000) {
        push_symbol(POWER);
        push(p1);
        push(p2);
        list(3);
        return;
      }
      x = mpow(p1.q.a, Math.abs(expo));
      y = mpow(p1.q.b, Math.abs(expo));
      if (expo < 0) {
        t = x;
        x = y;
        y = t;
        x = makeSignSameAs(x, y);
        y = makePositive(y);
      }
      p3 = new U();
      p3.k = NUM;
      p3.q.a = x;
      p3.q.b = y;
      push(p3);
      return;
    }
    if (isminusone(p1)) {
      push(p2);
      normalize_angle();
      return;
    }
    if (isnegativenumber(p1)) {
      push(p1);
      negate();
      push(p2);
      qpow();
      push_integer(-1);
      push(p2);
      qpow();
      multiply();
      return;
    }
    if (!isinteger(p1)) {
      push(p1);
      mp_numerator();
      push(p2);
      qpow();
      push(p1);
      mp_denominator();
      push(p2);
      negate();
      qpow();
      multiply();
      return;
    }
    if (is_small_integer(p1)) {
      push(p1);
      push(p2);
      quickfactor();
      return;
    }
    if (!p2.q.a.isSmall || !p2.q.b.isSmall) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    a = p2.q.a;
    b = p2.q.b;
    x = mroot(p1.q.a, b);
    if (x === 0) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    y = mpow(x, a);
    p3 = new U();
    p3.k = NUM;
    if (p2.q.a.isNegative()) {
      p3.q.a = bigInt(1);
      p3.q.b = y;
    } else {
      p3.q.a = y;
      p3.q.b = bigInt(1);
    }
    return push(p3);
  };

  normalize_angle = function() {
    save();
    p1 = pop();
    if (isinteger(p1)) {
      if (p1.q.a.isOdd()) {
        push_integer(-1);
      } else {
        push_integer(1);
      }
      restore();
      return;
    }
    push(p1);
    bignum_truncate();
    p2 = pop();
    if (isnegativenumber(p1)) {
      push(p2);
      push_integer(-1);
      add();
      p2 = pop();
    }
    push(p1);
    push(p2);
    subtract();
    p3 = pop();
    push_symbol(POWER);
    push_integer(-1);
    push(p3);
    list(3);
    if (p2.q.a.isOdd()) {
      negate();
    }
    return restore();
  };

  is_small_integer = function(p) {
    return p.q.a.isSmall;
  };

  quickfactor = function() {
    var ac, h, i, n, ref1, stackIndex;
    i = 0;
    save();
    p2 = pop();
    p1 = pop();
    h = tos;
    push(p1);
    factor_small_number();
    n = tos - h;
    stackIndex = h;
    for (i = ac = 0, ref1 = n; ac < ref1; i = ac += 2) {
      push(stack[stackIndex + i]);
      push(stack[stackIndex + i + 1]);
      push(p2);
      multiply();
      quickpower();
    }
    multiply_all(tos - h - n);
    p1 = pop();
    tos = h;
    push(p1);
    return restore();
  };

  quickpower = function() {
    var expo;
    expo = 0;
    save();
    p2 = pop();
    p1 = pop();
    push(p2);
    bignum_truncate();
    p3 = pop();
    push(p2);
    push(p3);
    subtract();
    p4 = pop();
    if (!iszero(p4)) {
      push_symbol(POWER);
      push(p1);
      push(p4);
      list(3);
    }
    push(p3);
    expo = pop_integer();
    if (expo === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p3);
      list(3);
      restore();
      return;
    }
    if (expo === 0) {
      restore();
      return;
    }
    push(p1);
    bignum_power_number(expo);
    return restore();
  };

  Eval_quotient = function() {
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    push(cadddr(p1));
    Eval();
    p1 = pop();
    if (p1 === symbol(NIL)) {
      p1 = symbol(SYMBOL_X);
    }
    push(p1);
    return divpoly();
  };

  divpoly = function() {
    var ac, dividend, divisor, h, i, m, n, ref1, x;
    h = 0;
    i = 0;
    m = 0;
    n = 0;
    x = 0;
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    h = tos;
    dividend = tos;
    push(p1);
    push(p3);
    m = coeff() - 1;
    divisor = tos;
    push(p2);
    push(p3);
    n = coeff() - 1;
    x = m - n;
    push_integer(0);
    p5 = pop();
    while (x >= 0) {
      push(stack[dividend + m]);
      push(stack[divisor + n]);
      divide();
      p4 = pop();
      for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac <= ref1 : ac >= ref1; i = 0 <= ref1 ? ++ac : --ac) {
        push(stack[dividend + x + i]);
        push(stack[divisor + i]);
        push(p4);
        multiply();
        subtract();
        stack[dividend + x + i] = pop();
      }
      push(p5);
      push(p4);
      push(p3);
      push_integer(x);
      power();
      multiply();
      add();
      p5 = pop();
      m--;
      x--;
    }
    tos = h;
    push(p5);
    return restore();
  };

  DEBUG = 0;

  Eval_rationalize = function() {
    push(cadr(p1));
    Eval();
    return rationalize();
  };

  rationalize = function() {
    var x;
    x = expanding;
    save();
    yyrationalize();
    restore();
    return expanding = x;
  };

  yyrationalize = function() {
    p1 = pop();
    if (istensor(p1)) {
      __rationalize_tensor();
      return;
    }
    expanding = 0;
    if (car(p1) !== symbol(ADD)) {
      push(p1);
      return;
    }
    if (DEBUG) {
      printf("rationalize: this is the input expr:\n");
      printline(p1);
    }
    push(one);
    multiply_denominators(p1);
    p2 = pop();
    if (DEBUG) {
      printf("rationalize: this is the common denominator:\n");
      printline(p2);
    }
    push(zero);
    p3 = cdr(p1);
    while (iscons(p3)) {
      push(p2);
      push(car(p3));
      multiply();
      add();
      p3 = cdr(p3);
    }
    if (DEBUG) {
      printf("rationalize: original expr times common denominator:\n");
      printline(stack[tos - 1]);
    }
    Condense();
    if (DEBUG) {
      printf("rationalize: after factoring:\n");
      printline(stack[tos - 1]);
    }
    push(p2);
    divide();
    if (DEBUG) {
      printf("rationalize: after dividing by common denom. (and we're done):\n");
      return printline(stack[tos - 1]);
    }
  };

  multiply_denominators = function(p) {
    var results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        multiply_denominators_term(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      return multiply_denominators_term(p);
    }
  };

  multiply_denominators_term = function(p) {
    var results;
    if (car(p) === symbol(MULTIPLY)) {
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        multiply_denominators_factor(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      return multiply_denominators_factor(p);
    }
  };

  multiply_denominators_factor = function(p) {
    if (car(p) !== symbol(POWER)) {
      return;
    }
    push(p);
    p = caddr(p);
    if (isnegativenumber(p)) {
      inverse();
      __lcm();
      return;
    }
    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      inverse();
      __lcm();
      return;
    }
    return pop();
  };

  __rationalize_tensor = function() {
    var ac, i, n, ref1;
    i = 0;
    push(p1);
    Eval();
    p1 = pop();
    if (!istensor(p1)) {
      push(p1);
      return;
    }
    n = p1.tensor.nelem;
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1.tensor.elem[i]);
      rationalize();
      p1.tensor.elem[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return push(p1);
  };

  __lcm = function() {
    save();
    p1 = pop();
    p2 = pop();
    push(p1);
    push(p2);
    multiply();
    push(p1);
    push(p2);
    gcd();
    divide();
    return restore();
  };


  /*
   Returns the real part of complex z

  	z		real(z)
  	-		-------

  	a + i b		a

  	exp(i a)	cos(a)
   */

  Eval_real = function() {
    push(cadr(p1));
    Eval();
    return real();
  };

  real = function() {
    save();
    rect();
    p1 = pop();
    push(p1);
    push(p1);
    conjugate();
    add();
    push_integer(2);
    divide();
    return restore();
  };


  /*
  Convert complex z to rectangular form

  	Input:		push	z

  	Output:		Result on stack
   */

  Eval_rect = function() {
    push(cadr(p1));
    Eval();
    return rect();
  };

  rect = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      push_integer(0);
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        rect();
        add();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      mag();
      push(p1);
      arg();
      p1 = pop();
      push(p1);
      cosine();
      push(imaginaryunit);
      push(p1);
      sine();
      multiply();
      add();
      multiply();
    }
    return restore();
  };

  show_power_debug = false;

  performing_roots = false;

  Eval_roots = function() {
    p2 = cadr(p1);
    if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
      push(cadr(p2));
      Eval();
      push(caddr(p2));
      Eval();
      subtract();
    } else {
      push(p2);
      Eval();
      p2 = pop();
      if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
        push(cadr(p2));
        Eval();
        push(caddr(p2));
        Eval();
        subtract();
      } else {
        push(p2);
      }
    }
    push(caddr(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p2 = pop();
    p1 = pop();
    if (!ispoly(p1, p2)) {
      stop("roots: 1st argument is not a polynomial");
    }
    push(p1);
    push(p2);
    return roots();
  };

  hasImaginaryCoeff = function(k) {
    var ac, h, i, imaginaryCoefficients, ref1;
    imaginaryCoefficients = false;
    h = tos;
    for (i = ac = ref1 = k; ac > 0; i = ac += -1) {
      if (iscomplexnumber(stack[tos - i])) {
        imaginaryCoefficients = true;
        break;
      }
    }
    return imaginaryCoefficients;
  };

  isSimpleRoot = function(k) {
    var ac, h, i, isSimpleRootPolynomial, ref1;
    if (k > 2) {
      isSimpleRootPolynomial = true;
      h = tos;
      if (iszero(stack[tos - k])) {
        isSimpleRootPolynomial = false;
      }
      for (i = ac = ref1 = k - 1; ac > 1; i = ac += -1) {
        if (!iszero(stack[tos - i])) {
          isSimpleRootPolynomial = false;
          break;
        }
      }
    } else {
      isSimpleRootPolynomial = false;
    }
    return isSimpleRootPolynomial;
  };

  normalisedCoeff = function() {
    var ac, ad, divideBy, i, k, miniStack, ref1, ref2;
    k = coeff();
    divideBy = stack[tos - 1];
    miniStack = [];
    for (i = ac = 1, ref1 = k; 1 <= ref1 ? ac <= ref1 : ac >= ref1; i = 1 <= ref1 ? ++ac : --ac) {
      miniStack.push(pop());
    }
    for (i = ad = ref2 = k - 1; ref2 <= 0 ? ad <= 0 : ad >= 0; i = ref2 <= 0 ? ++ad : --ad) {
      push(miniStack[i]);
      push(divideBy);
      divide();
    }
    return k;
  };

  roots = function() {
    var ac, h, i, k, lastCoeff, leadingCoeff, n, ref1;
    h = 0;
    i = 0;
    n = 0;
    save();
    if (recursionLevelNestedRadicalsRemoval > 1) {
      pop();
      pop();
      push(symbol(NIL));
      restore();
      return;
    }
    performing_roots = true;
    h = tos - 2;
    if (DEBUG) {
      console.log("checking if " + stack[tos - 1].toString() + " is a case of simple roots");
    }
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    push(p1);
    push(p2);
    k = normalisedCoeff();
    if (isSimpleRoot(k)) {
      if (DEBUG) {
        console.log("yes, " + stack[tos - 1].toString() + " is a case of simple roots");
      }
      lastCoeff = stack[tos - k];
      leadingCoeff = stack[tos - 1];
      tos -= k;
      pop();
      pop();
      getSimpleRoots(k, leadingCoeff, lastCoeff);
    } else {
      tos -= k;
      roots2();
    }
    n = tos - h;
    if (n === 0) {
      stop("roots: the polynomial is not factorable, try nroots");
    }
    if (n === 1) {
      performing_roots = false;
      restore();
      return;
    }
    sort_stack(n);
    p1 = alloc_tensor(n);
    p1.tensor.ndim = 1;
    p1.tensor.dim[0] = n;
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p1.tensor.elem[i] = stack[h + i];
    }
    tos = h;
    push(p1);
    restore();
    return performing_roots = false;
  };

  getSimpleRoots = function(n, leadingCoeff, lastCoeff) {
    var aSol, ac, ad, commonPart, ref1, ref2, rootsOfOne;
    if (DEBUG) {
      console.log("getSimpleRoots");
    }
    save();
    n = n - 1;
    push(lastCoeff);
    push_rational(1, n);
    power();
    push(leadingCoeff);
    push_rational(1, n);
    power();
    divide();
    commonPart = pop();
    if (n % 2 === 0) {
      for (rootsOfOne = ac = 1, ref1 = n; ac <= ref1; rootsOfOne = ac += 2) {
        push(commonPart);
        push_integer(-1);
        push_rational(rootsOfOne, n);
        power();
        multiply();
        aSol = pop();
        push(aSol);
        push(aSol);
        negate();
      }
    } else {
      for (rootsOfOne = ad = 1, ref2 = n; 1 <= ref2 ? ad <= ref2 : ad >= ref2; rootsOfOne = 1 <= ref2 ? ++ad : --ad) {
        push(commonPart);
        push_integer(-1);
        push_rational(rootsOfOne, n);
        power();
        multiply();
        if (rootsOfOne % 2 === 0) {
          negate();
        }
      }
    }
    return restore();
  };

  roots2 = function() {
    var k;
    save();
    p2 = pop();
    p1 = pop();
    push(p1);
    push(p2);
    push(p1);
    push(p2);
    k = normalisedCoeff();
    if (!hasImaginaryCoeff(k)) {
      tos -= k;
      factorpoly();
      p1 = pop();
    } else {
      tos -= k;
      pop();
      pop();
    }
    if (car(p1) === symbol(MULTIPLY)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        roots3();
        p1 = cdr(p1);
      }
    } else {
      push(p1);
      push(p2);
      roots3();
    }
    return restore();
  };

  roots3 = function() {
    var n;
    save();
    p2 = pop();
    p1 = pop();
    if (car(p1) === symbol(POWER) && ispoly(cadr(p1), p2) && isposint(caddr(p1))) {
      push(cadr(p1));
      push(p2);
      n = normalisedCoeff();
      mini_solve(n);
    } else if (ispoly(p1, p2)) {
      push(p1);
      push(p2);
      n = normalisedCoeff();
      mini_solve(n);
    }
    return restore();
  };

  mini_solve = function(n) {
    var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, ac, ad, ae, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, len, len1, len2, one_minus_i_sqrt3, one_plus_i_sqrt3, ref1, ref2, ref3, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;
    save();
    if (n === 2) {
      p3 = pop();
      p4 = pop();
      push(p4);
      push(p3);
      divide();
      negate();
      restore();
      return;
    }
    if (n === 3) {
      p3 = pop();
      p4 = pop();
      p5 = pop();
      push(p4);
      push_integer(2);
      power();
      push_integer(4);
      push(p3);
      multiply();
      push(p5);
      multiply();
      subtract();
      push_rational(1, 2);
      power();
      p6 = pop();
      push(p6);
      push(p4);
      subtract();
      push(p3);
      push_integer(2);
      multiply();
      divide();
      push(p6);
      push(p4);
      add();
      negate();
      push(p3);
      divide();
      push_rational(1, 2);
      multiply();
      restore();
      return;
    }
    if (n === 4 || n === 5) {
      p3 = pop();
      p4 = pop();
      p5 = pop();
      p6 = pop();
      push(p5);
      push(p5);
      multiply();
      R_c2 = pop();
      push(R_c2);
      push(p5);
      multiply();
      R_c3 = pop();
      push(p4);
      push(p4);
      multiply();
      R_b2 = pop();
      push(R_b2);
      push(p4);
      multiply();
      R_b3 = pop();
      push(R_b3);
      push(p6);
      multiply();
      R_b3_d = pop();
      push(R_b3_d);
      push_integer(-4);
      multiply();
      R_m4_b3_d = pop();
      push(R_b3);
      push_integer(2);
      multiply();
      R_2_b3 = pop();
      push(p3);
      push(p3);
      multiply();
      R_a2 = pop();
      push(R_a2);
      push(p3);
      multiply();
      R_a3 = pop();
      push_integer(3);
      push(p3);
      multiply();
      R_3_a = pop();
      push(R_a2);
      push(p6);
      multiply();
      R_a2_d = pop();
      push(R_a2_d);
      push(p6);
      multiply();
      R_a2_d2 = pop();
      push(R_a2_d);
      push_integer(27);
      multiply();
      R_27_a2_d = pop();
      push(R_a2_d2);
      push_integer(-27);
      multiply();
      R_m27_a2_d2 = pop();
      push(R_3_a);
      push_integer(2);
      multiply();
      R_6_a = pop();
      push(p3);
      push(p5);
      multiply();
      R_a_c = pop();
      push(R_a_c);
      push(p4);
      multiply();
      R_a_b_c = pop();
      push(R_a_b_c);
      push(p6);
      multiply();
      R_a_b_c_d = pop();
      push(R_a_c);
      push_integer(3);
      multiply();
      R_3_a_c = pop();
      push_integer(-4);
      push(p3);
      push(R_c3);
      multiply();
      multiply();
      R_m4_a_c3 = pop();
      push(R_a_b_c);
      push_integer(9);
      multiply();
      negate();
      R_m9_a_b_c = pop();
      push(R_a_b_c_d);
      push_integer(18);
      multiply();
      R_18_a_b_c_d = pop();
      push(R_b2);
      push(R_3_a_c);
      subtract();
      R_DELTA0 = pop();
      push(R_b2);
      push(R_c2);
      multiply();
      R_b2_c2 = pop();
      push(p4);
      negate();
      push(R_3_a);
      divide();
      R_m_b_over_3a = pop();
      if (n === 4) {
        if (DEBUG) {
          console.log(">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< ");
        }
        if (DEBUG) {
          console.log("cubic: D0: " + R_DELTA0.toString());
        }
        push(R_DELTA0);
        push_integer(3);
        power();
        push_integer(4);
        multiply();
        R_4_DELTA03 = pop();
        push(R_DELTA0);
        simplify();
        absValFloat();
        R_DELTA0_toBeCheckedIfZero = pop();
        if (DEBUG) {
          console.log("cubic: D0 as float: " + R_DELTA0_toBeCheckedIfZero.toString());
        }
        push(R_18_a_b_c_d);
        push(R_m4_b3_d);
        push(R_b2_c2);
        push(R_m4_a_c3);
        push(R_m27_a2_d2);
        add();
        add();
        add();
        add();
        simplify();
        absValFloat();
        R_determinant = pop();
        if (DEBUG) {
          console.log("cubic: DETERMINANT: " + R_determinant.toString());
        }
        push(R_2_b3);
        push(R_m9_a_b_c);
        push(R_27_a2_d);
        add();
        add();
        R_DELTA1 = pop();
        if (DEBUG) {
          console.log("cubic: D1: " + R_DELTA1.toString());
        }
        push(R_DELTA1);
        push_integer(2);
        power();
        push(R_4_DELTA03);
        subtract();
        push_rational(1, 2);
        power();
        simplify();
        R_Q = pop();
        if (iszero(R_determinant)) {
          if (iszero(R_DELTA0_toBeCheckedIfZero)) {
            if (DEBUG) {
              console.log(" cubic: DETERMINANT IS ZERO and delta0 is zero");
            }
            push(R_m_b_over_3a);
            restore();
            return;
          } else {
            if (DEBUG) {
              console.log(" cubic: DETERMINANT IS ZERO and delta0 is not zero");
            }
            push(p3);
            push(p6);
            push_integer(9);
            multiply();
            multiply();
            push(p4);
            push(p5);
            multiply();
            subtract();
            push(R_DELTA0);
            push_integer(2);
            multiply();
            divide();
            root_solution = pop();
            push(root_solution);
            push(root_solution);
            push(R_a_b_c);
            push_integer(4);
            multiply();
            push(p3);
            push(p3);
            push(p6);
            push_integer(9);
            multiply();
            multiply();
            multiply();
            negate();
            push(R_b3);
            negate();
            add();
            add();
            push(p3);
            push(R_DELTA0);
            multiply();
            divide();
            restore();
            return;
          }
        }
        C_CHECKED_AS_NOT_ZERO = false;
        flipSignOFQSoCIsNotZero = false;
        while (!C_CHECKED_AS_NOT_ZERO) {
          push(R_Q);
          if (flipSignOFQSoCIsNotZero) {
            negate();
          }
          push(R_DELTA1);
          add();
          push_rational(1, 2);
          multiply();
          push_rational(1, 3);
          power();
          simplify();
          R_C = pop();
          if (DEBUG) {
            console.log("cubic: C: " + R_C.toString());
          }
          push(R_C);
          simplify();
          absValFloat();
          R_C_simplified_toCheckIfZero = pop();
          if (DEBUG) {
            console.log("cubic: C as absval and float: " + R_C_simplified_toCheckIfZero.toString());
          }
          if (iszero(R_C_simplified_toCheckIfZero)) {
            if (DEBUG) {
              console.log(" cubic: C IS ZERO flipping the sign");
            }
            flipSignOFQSoCIsNotZero = true;
          } else {
            C_CHECKED_AS_NOT_ZERO = true;
          }
        }
        push(R_C);
        push(R_3_a);
        multiply();
        R_3_a_C = pop();
        push(R_3_a_C);
        push_integer(2);
        multiply();
        R_6_a_C = pop();
        push(imaginaryunit);
        push_integer(3);
        push_rational(1, 2);
        power();
        multiply();
        i_sqrt3 = pop();
        push_integer(1);
        push(i_sqrt3);
        add();
        one_plus_i_sqrt3 = pop();
        push_integer(1);
        push(i_sqrt3);
        subtract();
        one_minus_i_sqrt3 = pop();
        push(R_C);
        push(R_3_a);
        divide();
        R_C_over_3a = pop();
        push(R_m_b_over_3a);
        push(R_C_over_3a);
        negate();
        push(R_DELTA0);
        push(R_3_a_C);
        divide();
        negate();
        add();
        add();
        simplify();
        push(R_m_b_over_3a);
        push(R_C_over_3a);
        push(one_plus_i_sqrt3);
        multiply();
        push_integer(2);
        divide();
        push(one_minus_i_sqrt3);
        push(R_DELTA0);
        multiply();
        push(R_6_a_C);
        divide();
        add();
        add();
        simplify();
        push(R_m_b_over_3a);
        push(R_C_over_3a);
        push(one_minus_i_sqrt3);
        multiply();
        push_integer(2);
        divide();
        push(one_plus_i_sqrt3);
        push(R_DELTA0);
        multiply();
        push(R_6_a_C);
        divide();
        add();
        add();
        simplify();
        restore();
        return;
      }
      if (n === 5) {
        if (DEBUG) {
          console.log(">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< ");
        }
        p7 = pop();
        if (iszero(p4) && iszero(p6) && !iszero(p5) && !iszero(p7)) {
          if (DEBUG) {
            console.log("biquadratic case");
          }
          push(p3);
          push(symbol(SECRETX));
          push_integer(2);
          power();
          multiply();
          push(p5);
          push(symbol(SECRETX));
          multiply();
          push(p7);
          add();
          add();
          push(symbol(SECRETX));
          roots();
          biquadraticSolutions = pop();
          ref1 = biquadraticSolutions.tensor.elem;
          for (ac = 0, len = ref1.length; ac < len; ac++) {
            eachSolution = ref1[ac];
            push(eachSolution);
            push_rational(1, 2);
            power();
            simplify();
            push(eachSolution);
            push_rational(1, 2);
            power();
            negate();
            simplify();
          }
          restore();
          return;
        }
        push(p6);
        push(p6);
        multiply();
        R_d2 = pop();
        push(p7);
        push(p7);
        multiply();
        R_e2 = pop();
        push(R_e2);
        push(p7);
        multiply();
        R_e3 = pop();
        push_integer(256);
        push(R_a3);
        push(R_e3);
        multiply();
        multiply();
        push_integer(-192);
        push(R_a2_d);
        push(R_e2);
        push(p4);
        multiply();
        multiply();
        multiply();
        push_integer(-128);
        push(R_a2);
        push(R_c2);
        push(R_e2);
        multiply();
        multiply();
        multiply();
        push_integer(144);
        push(R_a2_d2);
        push(p5);
        push(p7);
        multiply();
        multiply();
        multiply();
        push(R_m27_a2_d2);
        push(R_d2);
        multiply();
        push_integer(144);
        push(R_a_b_c);
        push(p4);
        push(R_e2);
        multiply();
        multiply();
        multiply();
        push_integer(-6);
        push(p3);
        push(R_b2);
        push(R_d2);
        push(p7);
        multiply();
        multiply();
        multiply();
        multiply();
        push_integer(-80);
        push(R_a_b_c_d);
        push(p5);
        push(p7);
        multiply();
        multiply();
        multiply();
        push_integer(18);
        push(R_a_b_c_d);
        push(R_d2);
        multiply();
        multiply();
        push_integer(16);
        push(R_a_c);
        push(R_c3);
        push(p7);
        multiply();
        multiply();
        multiply();
        push_integer(-4);
        push(R_a_c);
        push(R_c2);
        push(R_d2);
        multiply();
        multiply();
        multiply();
        push_integer(-27);
        push(R_b3);
        push(p4);
        push(R_e2);
        multiply();
        multiply();
        multiply();
        push_integer(18);
        push(R_b3_d);
        push(p5);
        push(p7);
        multiply();
        multiply();
        multiply();
        push(R_m4_b3_d);
        push(R_d2);
        multiply();
        push_integer(-4);
        push(R_b2_c2);
        push(p5);
        push(p7);
        multiply();
        multiply();
        multiply();
        push(R_b2_c2);
        push(R_d2);
        multiply();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        add();
        R_determinant = pop();
        if (DEBUG) {
          console.log("R_determinant: " + R_determinant.toString());
        }
        push(R_c2);
        push_integer(-3);
        push(p4);
        push(p6);
        multiply();
        multiply();
        push_integer(12);
        push(p3);
        push(p7);
        multiply();
        multiply();
        add();
        add();
        R_DELTA0 = pop();
        if (DEBUG) {
          console.log("R_DELTA0: " + R_DELTA0.toString());
        }
        push_integer(2);
        push(R_c3);
        multiply();
        push_integer(-9);
        push(p4);
        push(p5);
        push(p6);
        multiply();
        multiply();
        multiply();
        push_integer(27);
        push(R_b2);
        push(p7);
        multiply();
        multiply();
        push_integer(27);
        push(p3);
        push(R_d2);
        multiply();
        multiply();
        push_integer(-72);
        push(R_a_c);
        push(p7);
        multiply();
        multiply();
        add();
        add();
        add();
        add();
        R_DELTA1 = pop();
        if (DEBUG) {
          console.log("R_DELTA1: " + R_DELTA1.toString());
        }
        push_integer(8);
        push(R_a_c);
        multiply();
        push_integer(-3);
        push(R_b2);
        multiply();
        add();
        push_integer(8);
        push(R_a2);
        multiply();
        divide();
        R_p = pop();
        if (DEBUG) {
          console.log("p: " + R_p.toString());
        }
        push(R_b3);
        push_integer(-4);
        push(R_a_b_c);
        multiply();
        push_integer(8);
        push(R_a2_d);
        multiply();
        add();
        add();
        push_integer(8);
        push(R_a3);
        multiply();
        divide();
        R_q = pop();
        if (DEBUG) {
          console.log("q: " + R_q.toString());
        }
        if (DEBUG) {
          console.log("tos 1 " + tos);
        }
        if (!iszero(p4)) {
          if (DEBUG) {
            console.log("tos 2 " + tos);
          }
          push_integer(8);
          push(p5);
          push(p3);
          multiply();
          multiply();
          push_integer(-3);
          push(p4);
          push_integer(2);
          power();
          multiply();
          add();
          push_integer(8);
          push(p3);
          push_integer(2);
          power();
          multiply();
          divide();
          R_p = pop();
          if (DEBUG) {
            console.log("p for depressed quartic: " + R_p.toString());
          }
          push(p4);
          push_integer(3);
          power();
          push_integer(-4);
          push(p3);
          push(p4);
          push(p5);
          multiply();
          multiply();
          multiply();
          push_integer(8);
          push(p6);
          push(p3);
          push_integer(2);
          power();
          multiply();
          multiply();
          add();
          add();
          push_integer(8);
          push(p3);
          push_integer(3);
          power();
          multiply();
          divide();
          R_q = pop();
          if (DEBUG) {
            console.log("q for depressed quartic: " + R_q.toString());
          }
          push(p4);
          push_integer(4);
          power();
          push_integer(-3);
          multiply();
          push_integer(256);
          push(R_a3);
          push(p7);
          multiply();
          multiply();
          push_integer(-64);
          push(R_a2_d);
          push(p4);
          multiply();
          multiply();
          push_integer(16);
          push(R_b2);
          push(p3);
          push(p5);
          multiply();
          multiply();
          multiply();
          add();
          add();
          add();
          push_integer(256);
          push(p3);
          push_integer(4);
          power();
          multiply();
          divide();
          R_r = pop();
          if (DEBUG) {
            console.log("r for depressed quartic: " + R_r.toString());
          }
          if (DEBUG) {
            console.log("tos 4 " + tos);
          }
          push(symbol(SECRETX));
          push_integer(4);
          power();
          if (DEBUG) {
            console.log("4 * x^4: " + stack[tos - 1].toString());
          }
          push(R_p);
          push(symbol(SECRETX));
          push_integer(2);
          power();
          multiply();
          if (DEBUG) {
            console.log("R_p * x^2: " + stack[tos - 1].toString());
          }
          push(R_q);
          push(symbol(SECRETX));
          multiply();
          if (DEBUG) {
            console.log("R_q * x: " + stack[tos - 1].toString());
          }
          push(R_r);
          if (DEBUG) {
            console.log("R_r: " + stack[tos - 1].toString());
          }
          add();
          add();
          add();
          simplify();
          if (DEBUG) {
            console.log("solving depressed quartic: " + stack[tos - 1].toString());
          }
          push(symbol(SECRETX));
          roots();
          depressedSolutions = pop();
          if (DEBUG) {
            console.log("depressedSolutions: " + depressedSolutions);
          }
          ref2 = depressedSolutions.tensor.elem;
          for (ad = 0, len1 = ref2.length; ad < len1; ad++) {
            eachSolution = ref2[ad];
            push(eachSolution);
            push(p4);
            push_integer(4);
            push(p3);
            multiply();
            divide();
            subtract();
            simplify();
            if (DEBUG) {
              console.log("solution from depressed: " + stack[tos - 1].toString());
            }
          }
          restore();
          return;
        } else {
          R_p = p5;
          R_q = p6;
          R_r = p7;

          /*
          				 * Descartes' solution
          				 * https://en.wikipedia.org/wiki/Quartic_function#Descartes.27_solution
          				 * finding the "u" in the depressed equation

          				push_integer(2)
          				push(R_p)
          				multiply()
          				coeff2 = pop()

          				push_integer(-4)
          				push(R_p)
          				push_integer(2)
          				power()
          				multiply()
          				push(R_r)
          				multiply()
          				coeff3 = pop()

          				push(R_q)
          				push_integer(2)
          				power()
          				negate()
          				coeff4 = pop()

          				 * now build the polynomial
          				push(symbol(SECRETX))
          				push_integer(3)
          				power()

          				push(coeff2)
          				push(symbol(SECRETX))
          				push_integer(2)
          				power()
          				multiply()

          				push(coeff3)
          				push(symbol(SECRETX))
          				multiply()

          				push(coeff4)

          				add()
          				add()
          				add()

          				console.log("Descarte's resolventCubic: " +  stack[tos-1].toString())
          				push(symbol(SECRETX))

          				roots()

          				resolventCubicSolutions = pop()
          				console.log("Descarte's resolventCubic solutions: " +  resolventCubicSolutions)
          				console.log("tos: " +  tos)

          				R_u = null
          				#R_u = resolventCubicSolutions.tensor.elem[1]
          				for eachSolution in resolventCubicSolutions.tensor.elem
          					console.log("examining solution: " +  eachSolution)
          					push(eachSolution)
          					push_integer(2)
          					multiply()
          					push(R_p)
          					add()

          					absValFloat()
          					toBeCheckedIFZero = pop()
          					console.log("abs value is: " +  eachSolution)
          					if !iszero(toBeCheckedIFZero)
          						R_u = eachSolution
          						break

          				console.log("chosen solution: " +  R_u)

          				push(R_u)
          				negate()
          				R_s = pop()

          				push(R_p)
          				push(R_u)
          				push_integer(2)
          				power()
          				push(R_q)
          				push(R_u)
          				divide()
          				add()
          				add()
          				push_integer(2)
          				divide()
          				R_t = pop()

          				push(R_p)
          				push(R_u)
          				push_integer(2)
          				power()
          				push(R_q)
          				push(R_u)
          				divide()
          				subtract()
          				add()
          				push_integer(2)
          				divide()
          				R_v = pop()

          				 * factoring the quartic into two quadratics:

          				 * now build the polynomial
          				push(symbol(SECRETX))
          				push_integer(2)
          				power()

          				push(R_s)
          				push(symbol(SECRETX))
          				multiply()

          				push(R_t)

          				add()
          				add()

          				console.log("factored quartic 1: " + stack[tos-1].toString())

          				push(symbol(SECRETX))
          				push_integer(2)
          				power()

          				push(R_u)
          				push(symbol(SECRETX))
          				multiply()

          				push(R_v)

          				add()
          				add()

          				console.log("factored quartic 2: " + stack[tos-1].toString())
          				pop()

          				restore()
          				return
           */
          push_rational(5, 2);
          push(R_p);
          multiply();
          coeff2 = pop();
          push_integer(2);
          push(R_p);
          push_integer(2);
          power();
          multiply();
          push(R_r);
          subtract();
          coeff3 = pop();
          push(R_p);
          push_integer(3);
          power();
          push_integer(2);
          divide();
          push_rational(-1, 2);
          push(R_p);
          push(R_r);
          multiply();
          multiply();
          push_rational(-1, 8);
          push(R_q);
          push_integer(2);
          power();
          multiply();
          add();
          add();
          coeff4 = pop();
          push(symbol(SECRETX));
          push_integer(3);
          power();
          push(coeff2);
          push(symbol(SECRETX));
          push_integer(2);
          power();
          multiply();
          push(coeff3);
          push(symbol(SECRETX));
          multiply();
          push(coeff4);
          add();
          add();
          add();
          if (DEBUG) {
            console.log("resolventCubic: " + stack[tos - 1].toString());
          }
          push(symbol(SECRETX));
          roots();
          resolventCubicSolutions = pop();
          if (DEBUG) {
            console.log("resolventCubicSolutions: " + resolventCubicSolutions);
          }
          R_m = null;
          ref3 = resolventCubicSolutions.tensor.elem;
          for (ae = 0, len2 = ref3.length; ae < len2; ae++) {
            eachSolution = ref3[ae];
            if (DEBUG) {
              console.log("examining solution: " + eachSolution);
            }
            push(eachSolution);
            push_integer(2);
            multiply();
            push(R_p);
            add();
            absValFloat();
            toBeCheckedIFZero = pop();
            if (DEBUG) {
              console.log("abs value is: " + eachSolution);
            }
            if (!iszero(toBeCheckedIFZero)) {
              R_m = eachSolution;
              break;
            }
          }
          if (DEBUG) {
            console.log("chosen solution: " + R_m);
          }
          push(R_m);
          push_integer(2);
          multiply();
          push(R_p);
          add();
          push_rational(1, 2);
          power();
          simplify();
          sqrtPPlus2M = pop();
          push(R_q);
          push_integer(2);
          multiply();
          push(sqrtPPlus2M);
          divide();
          simplify();
          TwoQOversqrtPPlus2M = pop();
          push(R_p);
          push_integer(3);
          multiply();
          push(R_m);
          push_integer(2);
          multiply();
          add();
          ThreePPlus2M = pop();
          push(sqrtPPlus2M);
          push(ThreePPlus2M);
          push(TwoQOversqrtPPlus2M);
          add();
          negate();
          push_rational(1, 2);
          power();
          simplify();
          add();
          push_integer(2);
          divide();
          push(sqrtPPlus2M);
          push(ThreePPlus2M);
          push(TwoQOversqrtPPlus2M);
          add();
          negate();
          push_rational(1, 2);
          power();
          simplify();
          subtract();
          push_integer(2);
          divide();
          push(sqrtPPlus2M);
          negate();
          push(ThreePPlus2M);
          push(TwoQOversqrtPPlus2M);
          subtract();
          negate();
          push_rational(1, 2);
          power();
          simplify();
          add();
          push_integer(2);
          divide();
          push(sqrtPPlus2M);
          negate();
          push(ThreePPlus2M);
          push(TwoQOversqrtPPlus2M);
          subtract();
          negate();
          push_rational(1, 2);
          power();
          simplify();
          subtract();
          push_integer(2);
          divide();
          restore();
          return;
        }
        push(R_determinant);
        simplify();
        absValFloat();
        R_determinant_simplified_toCheckIfZero = pop();
        push(R_DELTA0);
        simplify();
        absValFloat();
        R_DELTA0_simplified_toCheckIfZero = pop();
        S_CHECKED_AS_NOT_ZERO = false;
        choiceOfRadicalInQSoSIsNotZero = 0;
        while (!S_CHECKED_AS_NOT_ZERO) {
          Q_CHECKED_AS_NOT_ZERO = false;
          flipSignOFRadicalSoQIsNotZero = false;
          while (!Q_CHECKED_AS_NOT_ZERO) {
            push(R_DELTA1);
            push(R_DELTA1);
            push_integer(2);
            power();
            push_integer(-4);
            push(R_DELTA0);
            push_integer(3);
            power();
            multiply();
            add();
            push_rational(1, 2);
            power();
            if (flipSignOFRadicalSoQIsNotZero) {
              negate();
            }
            add();
            push_integer(2);
            divide();
            if (DEBUG) {
              console.log("content of cubic root: " + stack[tos - 1].toString());
            }
            push_rational(1, 3);
            power();
            simplify();
            R_principalCubicRoot = pop();
            if (DEBUG) {
              console.log("principal cubic root: " + R_principalCubicRoot.toString());
            }
            if (DEBUG) {
              console.log("tos : " + tos);
            }
            if (choiceOfRadicalInQSoSIsNotZero === 0) {
              if (DEBUG) {
                console.log("chosing principal cubic root");
              }
              push(R_principalCubicRoot);
            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {
              if (DEBUG) {
                console.log("chosing cubic root beyond principal");
              }
              push(R_principalCubicRoot);
              push_rational(-1, 2);
              multiply();
              push_integer(3);
              push_rational(1, 2);
              power();
              push(imaginaryunit);
              multiply();
              push_rational(-1, 2);
              multiply();
              push(R_principalCubicRoot);
              multiply();
              add();
            } else if (choiceOfRadicalInQSoSIsNotZero === 1) {
              if (DEBUG) {
                console.log("chosing cubic root beyond beyond principal");
              }
              push(R_principalCubicRoot);
              push_rational(-1, 2);
              multiply();
              push_integer(3);
              push_rational(1, 2);
              power();
              push(imaginaryunit);
              multiply();
              push_rational(1, 2);
              multiply();
              push(R_principalCubicRoot);
              multiply();
              add();
            }
            simplify();
            R_Q = pop();
            if (DEBUG) {
              console.log("Q " + R_Q.toString());
            }
            if (DEBUG) {
              console.log("tos: " + tos);
            }
            push(R_Q);
            simplify();
            absValFloat();
            R_Q_simplified_toCheckIfZero = pop();
            if (DEBUG) {
              console.log("Q simplified and abs" + R_Q_simplified_toCheckIfZero.toString());
            }
            if (iszero(R_Q_simplified_toCheckIfZero) && (!iszero(R_determinant_simplified_toCheckIfZero) && iszero(R_DELTA0_simplified_toCheckIfZero))) {
              if (DEBUG) {
                console.log(" *********************************** Q IS ZERO and it matters, flipping the sign");
              }
              flipSignOFRadicalSoQIsNotZero = true;
            } else {
              Q_CHECKED_AS_NOT_ZERO = true;
            }
            if (DEBUG) {
              console.log("tos: " + tos);
            }
          }
          push_rational(-2, 3);
          push(R_p);
          multiply();
          push(R_Q);
          push(R_DELTA0);
          push(R_Q);
          divide();
          add();
          push(R_3_a);
          divide();
          add();
          push_rational(1, 2);
          power();
          push_integer(2);
          divide();
          show_power_debug = true;
          simplify();
          R_S = pop();
          if (DEBUG) {
            console.log("S " + R_S.toString());
          }
          push(R_S);
          simplify();
          absValFloat();
          R_S_simplified_toCheckIfZero = pop();
          if (DEBUG) {
            console.log("S " + R_S_simplified_toCheckIfZero.toString());
          }
          if (iszero(R_S_simplified_toCheckIfZero)) {
            if (DEBUG) {
              console.log(" *********************************** S IS ZERO chosing another cubic root");
            }
            choiceOfRadicalInQSoSIsNotZero++;
          } else {
            S_CHECKED_AS_NOT_ZERO = true;
          }
          if (DEBUG) {
            console.log("tos: " + tos);
          }
        }
        if (DEBUG) {
          console.log("tos: " + tos);
        }
        push(p4);
        negate();
        push(p3);
        push_integer(4);
        multiply();
        divide();
        R_minus_b_over_4a = pop();
        push_integer(-4);
        push(R_S);
        push_integer(2);
        power();
        multiply();
        push_integer(2);
        push(R_p);
        multiply();
        subtract();
        R_minus_4S2_minus_2p = pop();
        push(R_q);
        push(R_S);
        divide();
        R_q_over_S = pop();
        if (DEBUG) {
          console.log("tos before putting together the 4 solutions: " + tos);
        }
        push(R_minus_b_over_4a);
        push(R_S);
        subtract();
        push(R_minus_4S2_minus_2p);
        push(R_q_over_S);
        add();
        push_rational(1, 2);
        power();
        push_integer(2);
        divide();
        add();
        simplify();
        push(R_minus_b_over_4a);
        push(R_S);
        subtract();
        push(R_minus_4S2_minus_2p);
        push(R_q_over_S);
        add();
        push_rational(1, 2);
        power();
        push_integer(2);
        divide();
        subtract();
        simplify();
        push(R_minus_b_over_4a);
        push(R_S);
        add();
        push(R_minus_4S2_minus_2p);
        push(R_q_over_S);
        subtract();
        push_rational(1, 2);
        power();
        push_integer(2);
        divide();
        add();
        simplify();
        push(R_minus_b_over_4a);
        push(R_S);
        add();
        push(R_minus_4S2_minus_2p);
        push(R_q_over_S);
        subtract();
        push_rational(1, 2);
        power();
        push_integer(2);
        divide();
        subtract();
        simplify();
        restore();
        return;
      }
    }
    tos -= n;
    return restore();
  };

  T_INTEGER = 1001;

  T_DOUBLE = 1002;

  T_SYMBOL = 1003;

  T_FUNCTION = 1004;

  T_NEWLINE = 1006;

  T_STRING = 1007;

  T_GTEQ = 1008;

  T_LTEQ = 1009;

  T_EQ = 1010;

  token = "";

  newline_flag = 0;

  meta_mode = 0;

  input_str = 0;

  scan_str = 0;

  token_str = 0;

  token_buf = 0;

  lastFoundSymbol = null;

  symbolsRightOfAssignment = null;

  isSymbolLeftOfAssignment = null;

  scanningParameters = null;

  predefinedSymbolsInGlobalScope_doNotTrackInDependencies = ["rationalize", "mag", "i", "pi", "sin", "cos", "roots", "integral", "derivative", "defint"];

  functionInvokationsScanningStack = null;

  skipRootVariableToBeSolved = false;

  transpose_unicode = 7488;

  dotprod_unicode = 183;

  scanned = "";

  scan = function(s) {
    if (DEBUG) {
      console.log("#### scanning " + s);
    }
    lastFoundSymbol = null;
    symbolsRightOfAssignment = [];
    isSymbolLeftOfAssignment = true;
    scanningParameters = [];
    functionInvokationsScanningStack = [""];
    scanned = s;
    meta_mode = 0;
    expanding++;
    input_str = 0;
    scan_str = 0;
    get_next_token();
    if (token === "") {
      push(symbol(NIL));
      expanding--;
      return 0;
    }
    scan_stmt();
    expanding--;
    return token_str - input_str;
  };

  scan_meta = function(s) {
    scanned = s;
    meta_mode = 1;
    expanding++;
    input_str = 0;
    scan_str = 0;
    get_next_token();
    if (token === "") {
      push(symbol(NIL));
      expanding--;
      return 0;
    }
    scan_stmt();
    expanding--;
    return token_str - input_str;
  };

  scan_stmt = function() {
    var ac, ad, existingDependencies, i, indexOfSymbolLeftOfAssignment, len, len1, symbolLeftOfAssignment;
    scan_relation();
    if (token === '=') {
      symbolLeftOfAssignment = lastFoundSymbol;
      if (DEBUG) {
        console.log("assignment!");
      }
      isSymbolLeftOfAssignment = false;
      get_next_token();
      push_symbol(SETQ);
      swap();
      scan_relation();
      list(3);
      isSymbolLeftOfAssignment = true;
      indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);
      if (indexOfSymbolLeftOfAssignment !== -1) {
        symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);
      }
      if (DEBUG) {
        console.log("locally, " + symbolLeftOfAssignment + " depends on: ");
      }
      for (ac = 0, len = symbolsRightOfAssignment.length; ac < len; ac++) {
        i = symbolsRightOfAssignment[ac];
        if (DEBUG) {
          console.log("	" + i);
        }
      }
      if (symbolsDependencies[symbolLeftOfAssignment] == null) {
        symbolsDependencies[symbolLeftOfAssignment] = [];
      }
      existingDependencies = symbolsDependencies[symbolLeftOfAssignment];
      for (ad = 0, len1 = symbolsRightOfAssignment.length; ad < len1; ad++) {
        i = symbolsRightOfAssignment[ad];
        if (existingDependencies.indexOf(i) === -1) {
          existingDependencies.push(i);
        }
      }
      return symbolsRightOfAssignment = [];
    }
  };

  scan_relation = function() {
    scan_expression();
    switch (token) {
      case T_EQ:
        push_symbol(TESTEQ);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case T_LTEQ:
        push_symbol(TESTLE);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case T_GTEQ:
        push_symbol(TESTGE);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case '<':
        push_symbol(TESTLT);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
      case '>':
        push_symbol(TESTGT);
        swap();
        get_next_token();
        scan_expression();
        return list(3);
    }
  };

  scan_expression = function() {
    var h;
    h = tos;
    switch (token) {
      case '+':
        get_next_token();
        scan_term();
        break;
      case '-':
        get_next_token();
        scan_term();
        negate();
        break;
      default:
        scan_term();
    }
    while (newline_flag === 0 && (token === '+' || token === '-')) {
      if (token === '+') {
        get_next_token();
        scan_term();
      } else {
        get_next_token();
        scan_term();
        negate();
      }
    }
    if (tos - h > 1) {
      list(tos - h);
      push_symbol(ADD);
      swap();
      return cons();
    }
  };

  is_factor = function() {
    if ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {
      return 1;
    }
    switch (token) {
      case '*':
      case '/':
        return 1;
      case '(':
      case T_SYMBOL:
      case T_FUNCTION:
      case T_INTEGER:
      case T_DOUBLE:
      case T_STRING:
        if (newline_flag) {
          scan_str = token_str;
          return 0;
        } else {
          return 1;
        }
    }
    return 0;
  };

  simplify_1_in_products = function(tos, h) {
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      return pop();
    }
  };

  multiply_consecutive_constants = function(tos, h) {
    if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      return multiply();
    }
  };

  scan_term = function() {
    var h;
    h = tos;
    scan_power();
    if (parse_time_simplifications) {
      simplify_1_in_products(tos, h);
    }
    while (is_factor()) {
      if (token === '*') {
        get_next_token();
        scan_power();
      } else if (token === '/') {
        simplify_1_in_products(tos, h);
        get_next_token();
        scan_power();
        inverse();
      } else if ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {
        get_next_token();
        push_symbol(INNER);
        swap();
        scan_power();
        list(3);
      } else {
        scan_power();
      }
      if (parse_time_simplifications) {
        multiply_consecutive_constants(tos, h);
        simplify_1_in_products(tos, h);
      }
    }
    if (h === tos) {
      return push_integer(1);
    } else if (tos - h > 1) {
      list(tos - h);
      push_symbol(MULTIPLY);
      swap();
      return cons();
    }
  };

  scan_power = function() {
    scan_factor();
    if (token === '^') {
      get_next_token();
      push_symbol(POWER);
      swap();
      scan_power();
      return list(3);
    }
  };

  scan_factor = function() {
    var h, results;
    h = tos;
    if (token === '(') {
      scan_subexpr();
    } else if (token === T_SYMBOL) {
      scan_symbol();
    } else if (token === T_FUNCTION) {
      scan_function_call();
    } else if (token === T_INTEGER) {
      bignum_scan_integer(token_buf);
      get_next_token();
    } else if (token === T_DOUBLE) {
      bignum_scan_float(token_buf);
      get_next_token();
    } else if (token === T_STRING) {
      scan_string();
    } else {
      scan_error("syntax error");
    }
    if (token === '[') {
      get_next_token();
      push_symbol(INDEX);
      swap();
      scan_expression();
      while (token === ',') {
        get_next_token();
        scan_expression();
      }
      if (token !== ']') {
        scan_error("] expected");
      }
      get_next_token();
      list(tos - h);
    }
    while (token === '!') {
      get_next_token();
      push_symbol(FACTORIAL);
      swap();
      list(2);
    }
    results = [];
    while ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === transpose_unicode) {
      get_next_token();
      push_symbol(TRANSPOSE);
      swap();
      results.push(list(2));
    }
    return results;
  };

  addSymbolRightOfAssignment = function(theSymbol) {
    var ac, i, prefixVar, ref1;
    if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && !skipRootVariableToBeSolved) {
      if (DEBUG) {
        console.log("... adding symbol: " + theSymbol + " to the set of the symbols right of assignment");
      }
      prefixVar = "";
      for (i = ac = 1, ref1 = functionInvokationsScanningStack.length; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
        if (functionInvokationsScanningStack[i] !== "") {
          prefixVar += functionInvokationsScanningStack[i] + "_" + i + "_";
        }
      }
      theSymbol = prefixVar + theSymbol;
      return symbolsRightOfAssignment.push(theSymbol);
    }
  };

  scan_symbol = function() {
    if (token !== T_SYMBOL) {
      scan_error("symbol expected");
    }
    if (meta_mode && token_buf.length === 1) {
      switch (token_buf[0]) {
        case 'a':
          push(symbol(METAA));
          break;
        case 'b':
          push(symbol(METAB));
          break;
        case 'x':
          push(symbol(METAX));
          break;
        default:
          push(usr_symbol(token_buf));
      }
    } else {
      push(usr_symbol(token_buf));
    }
    if (scanningParameters.length === 0) {
      if (DEBUG) {
        console.log("out of scanning parameters, processing " + token_buf);
      }
      lastFoundSymbol = token_buf;
    } else {
      if (DEBUG) {
        console.log("still scanning parameters, skipping " + token_buf);
      }
      if (isSymbolLeftOfAssignment) {
        addSymbolRightOfAssignment("'" + token_buf);
      }
    }
    if (DEBUG) {
      console.log("found symbol: " + token_buf + " left of assignment: " + isSymbolLeftOfAssignment);
    }
    if (!isSymbolLeftOfAssignment) {
      addSymbolRightOfAssignment(token_buf);
    }
    return get_next_token();
  };

  scan_string = function() {
    new_string(token_buf);
    return get_next_token();
  };

  scan_function_call = function() {
    var ac, functionName, i, n, p, ref1;
    if (DEBUG) {
      console.log("-- scan_function_call start");
    }
    n = 1;
    p = new U();
    p = usr_symbol(token_buf);
    push(p);
    get_next_token();
    functionName = token_buf;
    if (functionName === "roots" || functionName === "defint") {
      functionInvokationsScanningStack.push(token_buf);
    }
    lastFoundSymbol = token_buf;
    if (!isSymbolLeftOfAssignment) {
      addSymbolRightOfAssignment(token_buf);
    }
    get_next_token();
    scanningParameters.push(true);
    if (token !== ')') {
      scan_stmt();
      n++;
      while (token === ',') {
        get_next_token();
        if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("roots") !== -1) {
          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {
            return !(new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf)).test(x);
          });
          skipRootVariableToBeSolved = true;
        }
        if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("defint") !== -1 && (n === 2 || (n > 2 && ((n - 2) % 3 === 0)))) {
          symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {
            return !(new RegExp("defint_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf)).test(x);
          });
          skipRootVariableToBeSolved = true;
        }
        scan_stmt();
        skipRootVariableToBeSolved = false;
        n++;
      }
      if (n === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("roots") !== -1) {
        symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x) {
          return !(new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_" + "x")).test(x);
        });
      }
    }
    scanningParameters.pop();
    for (i = ac = 0, ref1 = symbolsRightOfAssignment.length; 0 <= ref1 ? ac <= ref1 : ac >= ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (symbolsRightOfAssignment[i] != null) {
        if (functionName === "roots") {
          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
        }
        if (functionName === "defint") {
          symbolsRightOfAssignment[i] = symbolsRightOfAssignment[i].replace(new RegExp("defint_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
        }
      }
    }
    if (token !== ')') {
      scan_error(") expected");
    }
    get_next_token();
    list(n);
    if (functionName === "roots" || functionName === "defint") {
      functionInvokationsScanningStack.pop();
    }
    if (DEBUG) {
      return console.log("-- scan_function_call end");
    }
  };

  scan_subexpr = function() {
    var n;
    n = 0;
    if (token !== '(') {
      scan_error("( expected");
    }
    get_next_token();
    scan_stmt();
    if (token === ',') {
      n = 1;
      while (token === ',') {
        get_next_token();
        scan_stmt();
        n++;
      }
      build_tensor(n);
    }
    if (token !== ')') {
      scan_error(") expected");
    }
    return get_next_token();
  };

  scan_error = function(errmsg) {
    errorMessage = "";
    while (input_str !== scan_str) {
      if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
        break;
      }
      errorMessage += scanned[input_str++];
    }
    errorMessage += " ? ";
    while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
      errorMessage += scanned[input_str++];
    }
    errorMessage += '\n';
    return stop(errmsg);
  };

  build_tensor = function(n) {
    var ac, i, ref1;
    i = 0;
    save();
    p2 = alloc_tensor(n);
    p2.tensor.ndim = 1;
    p2.tensor.dim[0] = n;
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p2.tensor.elem[i] = stack[tos - n + i];
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      if (DEBUG) {
        console.log("something wrong in tensor dimensions");
      }
      debugger;
    }
    tos -= n;
    push(p2);
    return restore();
  };

  get_next_token = function() {
    newline_flag = 0;
    while (1.) {
      get_token();
      if (token !== T_NEWLINE) {
        break;
      }
      newline_flag = 1;
    }
    if (DEBUG) {
      return console.log("get_next_token token: " + token);
    }
  };

  get_token = function() {
    while (isspace(scanned[scan_str])) {
      if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        token = T_NEWLINE;
        scan_str++;
        return;
      }
      scan_str++;
    }
    token_str = scan_str;
    if (scan_str === scanned.length) {
      token = "";
      return;
    }
    if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === '.') {
        scan_str++;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
        if (scanned[scan_str] === 'e' && (scanned[scan_str + 1] === '+' || scanned[scan_str + 1] === '-' || isdigit(scanned[scan_str + 1]))) {
          scan_str += 2;
          while (isdigit(scanned[scan_str])) {
            scan_str++;
          }
        }
        token = T_DOUBLE;
      } else {
        token = T_INTEGER;
      }
      update_token_buf(token_str, scan_str);
      return;
    }
    if (isalpha(scanned[scan_str])) {
      while (isalnumorunderscore(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === '(') {
        token = T_FUNCTION;
      } else {
        token = T_SYMBOL;
      }
      update_token_buf(token_str, scan_str);
      return;
    }
    if (scanned[scan_str] === '"') {
      scan_str++;
      while (scanned[scan_str] !== '"') {
        if (scan_str === scanned.length || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
          scan_error("runaway string");
        }
        scan_str++;
      }
      scan_str++;
      token = T_STRING;
      update_token_buf(token_str + 1, scan_str - 1);
      return;
    }
    if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scanned[scan_str + 1] === '-') {
      while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
        scan_str++;
      }
      if (scanned[scan_str]) {
        scan_str++;
      }
      token = T_NEWLINE;
      return;
    }
    if (scanned[scan_str] === '=' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_EQ;
      return;
    }
    if (scanned[scan_str] === '<' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_LTEQ;
      return;
    }
    if (scanned[scan_str] === '>' && scanned[scan_str + 1] === '=') {
      scan_str += 2;
      token = T_GTEQ;
      return;
    }
    return token = scanned[scan_str++];
  };

  update_token_buf = function(a, b) {
    return token_buf = scanned.substring(a, b);
  };

  $.scan = scan;

  Eval_sgn = function() {
    push(cadr(p1));
    Eval();
    return sgn();
  };

  sgn = function() {
    save();
    yysgn();
    return restore();
  };

  yysgn = function() {
    p1 = pop();
    if (isdouble(p1)) {
      if (p1.d > 0) {
        push_integer(1);
        return;
      } else {
        if (p1.d === 0) {
          push_integer(1);
          return;
        } else {
          push_integer(-1);
          return;
        }
      }
    }
    if (isrational(p1)) {
      if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {
        push_integer(-1);
        return;
      } else {
        if (MZERO(mmul(p1.q.a, p1.q.b))) {
          push_integer(0);
          return;
        } else {
          push_integer(1);
          return;
        }
      }
    }
    if (iscomplexnumber(p1)) {
      push_integer(-1);
      push(p1);
      absval();
      power();
      push(p1);
      multiply();
      return;
    }
    if (isnegativeterm(p1)) {
      push_symbol(SGN);
      push(p1);
      negate();
      list(2);
      push_integer(-1);
      multiply();
      return;
    }

    /*
    	push_integer(2)
    	push(p1)
    	heaviside()
    	multiply()
    	push_integer(-1)
    	add()
     */
    push_symbol(SGN);
    push(p1);
    return list(2);
  };

  Eval_shape = function() {
    push(cadr(p1));
    Eval();
    return shape();
  };

  shape = function() {
    var ac, ad, ai, an, i, ndim, ref1, ref2, t;
    i = 0;
    ndim = 0;
    t = 0;
    ai = [];
    an = [];
    for (i = ac = 0, ref1 = MAXDIM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      ai[i] = 0;
      an[i] = 0;
    }
    save();
    p1 = pop();
    if (!istensor(p1)) {
      if (!iszero(p1)) {
        stop("transpose: tensor expected, 1st arg is not a tensor");
      }
      push(zero);
      restore();
      return;
    }
    ndim = p1.tensor.ndim;
    p2 = alloc_tensor(ndim);
    p2.tensor.ndim = 1;
    p2.tensor.dim[0] = ndim;
    for (i = ad = 0, ref2 = ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push_integer(p1.tensor.dim[i]);
      p2.tensor.elem[i] = pop();
    }
    push(p2);
    return restore();
  };


  /*
   Simplify factorials

  The following script

  	F(n,k) = k binomial(n,k)
  	(F(n,k) + F(n,k-1)) / F(n+1,k)

  generates

         k! n!             n! (1 - k + n)!              k! n!
   -------------------- + -------------------- - ----------------------
   (-1 + k)! (1 + n)!     (1 + n)! (-k + n)!     k (-1 + k)! (1 + n)!

  Simplify each term to get

     k       1 - k + n       1
  ------- + ----------- - -------
   1 + n       1 + n       1 + n

  Then simplify the sum to get

     n
  -------
   1 + n
   */

  Eval_simfac = function() {
    push(cadr(p1));
    Eval();
    return simfac();
  };

  simfac = function() {
    var h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      h = tos;
      p1 = cdr(p1);
      while (p1 !== symbol(NIL)) {
        push(car(p1));
        simfac_term();
        p1 = cdr(p1);
      }
      add_all(tos - h);
    } else {
      push(p1);
      simfac_term();
    }
    return restore();
  };


  /*
  void
  simfac(void)
  {
  	int h
  	save()
  	p1 = pop()
  	if (car(p1) == symbol(ADD)) {
  		h = tos
  		p1 = cdr(p1)
  		while (p1 != symbol(NIL)) {
  			push(car(p1))
  			simfac_term()
  			p1 = cdr(p1)
  		}
  		addk(tos - h)
  		p1 = pop()
  		if (find(p1, symbol(FACTORIAL))) {
  			push(p1)
  			if (car(p1) == symbol(ADD)) {
  				Condense()
  				simfac_term()
  			}
  		}
  	} else {
  		push(p1)
  		simfac_term()
  	}
  	restore()
  }

  #endif
   */

  simfac_term = function() {
    var doNothing, h;
    h = 0;
    save();
    p1 = pop();
    if (car(p1) !== symbol(MULTIPLY)) {
      push(p1);
      restore();
      return;
    }
    h = tos;
    p1 = cdr(p1);
    while (p1 !== symbol(NIL)) {
      push(car(p1));
      p1 = cdr(p1);
    }
    while (yysimfac(h)) {
      doNothing = 1;
    }
    multiply_all_noexpand(tos - h);
    return restore();
  };

  yysimfac = function(h) {
    var ac, ad, i, j, ref1, ref2, ref3, ref4;
    i = 0;
    j = 0;
    for (i = ac = ref1 = h, ref2 = tos; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      p1 = stack[i];
      for (j = ad = ref3 = h, ref4 = tos; ref3 <= ref4 ? ad < ref4 : ad > ref4; j = ref3 <= ref4 ? ++ad : --ad) {
        if (i === j) {
          continue;
        }
        p2 = stack[j];
        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {
          push(cadr(p1));
          push(one);
          subtract();
          factorial();
          stack[i] = pop();
          stack[j] = one;
          return 1;
        }
        if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {
          push(p1);
          push_integer(-1);
          add();
          factorial();
          reciprocate();
          stack[i] = pop();
          stack[j] = one;
          return 1;
        }
        if (car(p2) === symbol(FACTORIAL)) {
          push(p1);
          push(cadr(p2));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            push(p1);
            factorial();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
        }
        if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
          push(cadr(p1));
          push(cadr(cadr(p2)));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            push(cadr(p1));
            factorial();
            reciprocate();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
        }
        if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
          push(cadr(p1));
          push(cadr(cadr(p2)));
          subtract();
          p3 = pop();
          if (isplusone(p3)) {
            stack[i] = cadr(p1);
            stack[j] = one;
            return 1;
          }
          if (isminusone(p3)) {
            push(cadr(cadr(p2)));
            reciprocate();
            stack[i] = pop();
            stack[j] = one;
            return 1;
          }
          if (equaln(p3, 2)) {
            stack[i] = cadr(p1);
            push(cadr(p1));
            push_integer(-1);
            add();
            stack[j] = pop();
            return 1;
          }
          if (equaln(p3, -2)) {
            push(cadr(cadr(p2)));
            reciprocate();
            stack[i] = pop();
            push(cadr(cadr(p2)));
            push_integer(-1);
            add();
            reciprocate();
            stack[j] = pop();
            return 1;
          }
        }
      }
    }
    return 0;
  };

  Eval_simplify = function() {
    push(cadr(p1));
    runUserDefinedSimplifications();
    Eval();
    return simplify();
  };

  runUserDefinedSimplifications = function() {
    var additionalSimplifications, originalexpanding, success;
    if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {
      originalexpanding = expanding;
      expanding = false;
      Eval();
      expanding = originalexpanding;
      additionalSimplifications = userSimplificationsInListForm.slice(0);
      additionalSimplifications.push(0);
      success = true;
      p1 = pop();
      push(p1);
      push_symbol(NIL);
      success = transform(additionalSimplifications, true);
      p1 = pop();
      return push(p1);
    }
  };

  simplifyForCodeGeneration = function() {
    save();
    runUserDefinedSimplifications();
    simplify_main();
    return restore();
  };

  simplify = function() {
    save();
    simplify_main();
    return restore();
  };

  simplify_main = function() {
    p1 = pop();
    if (istensor(p1)) {
      simplify_tensor();
      return;
    }
    if (Find(p1, symbol(FACTORIAL))) {
      push(p1);
      simfac();
      p2 = pop();
      push(p1);
      rationalize();
      simfac();
      p3 = pop();
      if (count(p2) < count(p3)) {
        p1 = p2;
      } else {
        p1 = p3;
      }
    }
    f10();
    f1();
    f2();
    f3();
    f4();
    f5();
    f9();
    simplify_polarRect();
    if (do_simplify_nested_radicals) {
      if (simplify_nested_radicals()) {
        if (DEBUG) {
          console.log("de-nesting successful into: " + p1.toString());
        }
        push(p1);
        simplify();
        return;
      }
    }
    return push(p1);
  };

  simplify_tensor = function() {
    var ac, ad, i, ref1, ref2;
    i = 0;
    p2 = alloc_tensor(p1.tensor.nelem);
    p2.tensor.ndim = p1.tensor.ndim;
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(p1.tensor.elem[i]);
      simplify();
      p2.tensor.elem[i] = pop();
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (iszero(p2)) {
      p2 = zero;
    }
    return push(p2);
  };

  count = function(p) {
    var n;
    if (iscons(p)) {
      n = 0;
      while (iscons(p)) {
        n += count(car(p)) + 1;
        p = cdr(p);
      }
    } else {
      n = 1;
    }
    return n;
  };

  countOccurrencesOfSymbol = function(needle, p) {
    var n;
    n = 0;
    if (iscons(p)) {
      while (iscons(p)) {
        n += countOccurrencesOfSymbol(needle, car(p));
        p = cdr(p);
      }
    } else {
      if (equal(needle, p)) {
        n = 1;
      }
    }
    return n;
  };

  f1 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push(p1);
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  f2 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push(p1);
    Condense();
    p2 = pop();
    if (count(p2) <= count(p1)) {
      return p1 = p2;
    }
  };

  f3 = function() {
    push(p1);
    rationalize();
    negate();
    rationalize();
    negate();
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  f10 = function() {
    var a, b, carp1, miao, originalexpanding;
    carp1 = car(p1);
    miao = cdr(p1);
    if (carp1 === symbol(MULTIPLY) || carp1 === symbol(INNER)) {
      if ((car(car(cdr(p1))) === symbol(TRANSPOSE)) && (car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE))) {
        if (DEBUG) {
          console.log("maybe collecting a transpose " + p1);
        }
        a = cadr(car(cdr(p1)));
        b = cadr(car(cdr(cdr(p1))));
        if (carp1 === symbol(MULTIPLY)) {
          push(a);
          push(b);
          multiply();
        } else if (carp1 === symbol(INNER)) {
          push(b);
          push(a);
          inner();
        }
        push_integer(1);
        push_integer(2);
        originalexpanding = expanding;
        expanding = false;
        transpose();
        expanding = originalexpanding;
        p2 = pop();
        if (count(p2) < count(p1)) {
          p1 = p2;
        }
        if (DEBUG) {
          return console.log("collecting a transpose " + p2);
        }
      }
    }
  };

  f4 = function() {
    if (iszero(p1)) {
      return;
    }
    push(p1);
    rationalize();
    inverse();
    rationalize();
    inverse();
    rationalize();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  simplify_trig = function() {
    save();
    p1 = pop();
    f5();
    push(p1);
    return restore();
  };

  f5 = function() {
    if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
      return;
    }
    p2 = p1;
    trigmode = 1;
    push(p2);
    Eval();
    p3 = pop();
    trigmode = 2;
    push(p2);
    Eval();
    p4 = pop();
    trigmode = 0;
    if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {
      p3 = p4;
    }
    if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {
      return p1 = p3;
    }
  };

  f9 = function() {
    if (car(p1) !== symbol(ADD)) {
      return;
    }
    push_integer(0);
    p2 = cdr(p1);
    while (iscons(p2)) {
      push(car(p2));
      simplify();
      add();
      p2 = cdr(p2);
    }
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  simplify_polarRect = function() {
    push(p1);
    polarRectAMinusOneBase();
    Eval();
    p2 = pop();
    if (count(p2) < count(p1)) {
      return p1 = p2;
    }
  };

  polarRectAMinusOneBase = function() {
    var h;
    save();
    p1 = pop();
    if (isimaginaryunit(p1)) {
      push(p1);
      restore();
      return;
    }
    if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {
      push(one);
      negate();
      push(caddr(p1));
      polarRectAMinusOneBase();
      power();
      polar();
      rect();
    } else if (iscons(p1)) {
      h = tos;
      while (iscons(p1)) {
        push(car(p1));
        polarRectAMinusOneBase();
        p1 = cdr(p1);
      }
      list(tos - h);
    } else {
      push(p1);
    }
    restore();
  };

  nterms = function(p) {
    if (car(p) !== symbol(ADD)) {
      return 1;
    } else {
      return length(p) - 1;
    }
  };

  simplify_nested_radicals = function() {
    var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;
    if (recursionLevelNestedRadicalsRemoval > 0) {
      if (DEBUG) {
        console.log("denesting bailing out because of too much recursion");
      }
      return false;
    }
    push(p1);
    somethingSimplified = take_care_of_nested_radicals();
    simplificationWithoutCondense = stack[tos - 1];
    prev_expanding = expanding;
    expanding = 0;
    yycondense();
    expanding = prev_expanding;
    simplificationWithCondense = pop();
    if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {
      push(simplificationWithoutCondense);
    } else {
      push(simplificationWithCondense);
    }
    p1 = pop();
    return somethingSimplified;
  };

  take_care_of_nested_radicals = function() {
    var A, B, C, SOLUTION, ac, ad, ae, af, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h, i, innerbase, innerexponent, len, len1, len2, len3, lowercase_a, lowercase_b, numberOfTerms, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref1, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;
    if (recursionLevelNestedRadicalsRemoval > 0) {
      if (DEBUG) {
        console.log("denesting bailing out because of too much recursion");
      }
      return false;
    }
    save();
    p1 = pop();
    if (equal(car(p1), symbol(POWER))) {
      base = cadr(p1);
      exponent = caddr(p1);
      if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {
        firstTerm = cadr(base);
        push(firstTerm);
        take_care_of_nested_radicals();
        pop();
        secondTerm = caddr(base);
        push(secondTerm);
        take_care_of_nested_radicals();
        pop();
        numberOfTerms = 0;
        countingTerms = base;
        while (cdr(countingTerms) !== symbol(NIL)) {
          numberOfTerms++;
          countingTerms = cdr(countingTerms);
        }
        if (numberOfTerms > 2) {
          push(p1);
          restore();
          return false;
        }
        commonInnerExponent = null;
        commonBases = [];
        termsThatAreNotPowers = [];
        if (car(secondTerm) === symbol(MULTIPLY)) {
          secondTermFactor = cdr(secondTerm);
          if (iscons(secondTermFactor)) {
            while (iscons(secondTermFactor)) {
              potentialPower = car(secondTermFactor);
              if (car(potentialPower) === symbol(POWER)) {
                innerbase = cadr(potentialPower);
                innerexponent = caddr(potentialPower);
                if (equalq(innerexponent, 1, 2)) {
                  if (commonInnerExponent == null) {
                    commonInnerExponent = innerexponent;
                    commonBases.push(innerbase);
                  } else {
                    if (equal(innerexponent, commonInnerExponent)) {
                      commonBases.push(innerbase);
                    } else {

                    }
                  }
                }
              } else {
                termsThatAreNotPowers.push(potentialPower);
              }
              secondTermFactor = cdr(secondTermFactor);
            }
          }
        } else if (car(secondTerm) === symbol(POWER)) {
          innerbase = cadr(secondTerm);
          innerexponent = caddr(secondTerm);
          if ((commonInnerExponent == null) && equalq(innerexponent, 1, 2)) {
            commonInnerExponent = innerexponent;
            commonBases.push(innerbase);
          }
        }
        if (commonBases.length === 0) {
          push(p1);
          restore();
          return false;
        }
        A = firstTerm;
        push_integer(1);
        for (ac = 0, len = commonBases.length; ac < len; ac++) {
          i = commonBases[ac];
          push(i);
          multiply();
        }
        C = pop();
        push_integer(1);
        for (ad = 0, len1 = termsThatAreNotPowers.length; ad < len1; ad++) {
          i = termsThatAreNotPowers[ad];
          push(i);
          multiply();
        }
        B = pop();
        if (equalq(exponent, 1, 3)) {
          push(A);
          negate();
          push(C);
          multiply();
          push(B);
          divide();
          checkSize = pop();
          push(checkSize);
          real();
          yyfloat();
          if (Math.abs(pop().d) > Math.pow(2, 32)) {
            push(p1);
            restore();
            return false;
          }
          push(checkSize);
          push_integer(3);
          push(C);
          multiply();
          checkSize = pop();
          push(checkSize);
          real();
          yyfloat();
          if (Math.abs(pop().d) > Math.pow(2, 32)) {
            pop();
            push(p1);
            restore();
            return false;
          }
          push(checkSize);
          push(symbol(SECRETX));
          multiply();
          push_integer(-3);
          push(A);
          multiply();
          push(B);
          divide();
          checkSize = pop();
          push(checkSize);
          real();
          yyfloat();
          if (Math.abs(pop().d) > Math.pow(2, 32)) {
            pop();
            pop();
            push(p1);
            restore();
            return false;
          }
          push(checkSize);
          push(symbol(SECRETX));
          push_integer(2);
          power();
          multiply();
          push_integer(1);
          push(symbol(SECRETX));
          push_integer(3);
          power();
          multiply();
          add();
          add();
          add();
        } else if (equalq(exponent, 1, 2)) {
          push(C);
          checkSize = pop();
          push(checkSize);
          real();
          yyfloat();
          if (Math.abs(pop().d) > Math.pow(2, 32)) {
            push(p1);
            restore();
            return false;
          }
          push(checkSize);
          push_integer(-2);
          push(A);
          multiply();
          push(B);
          divide();
          checkSize = pop();
          push(checkSize);
          real();
          yyfloat();
          if (Math.abs(pop().d) > Math.pow(2, 32)) {
            pop();
            push(p1);
            restore();
            return false;
          }
          push(checkSize);
          push(symbol(SECRETX));
          multiply();
          push_integer(1);
          push(symbol(SECRETX));
          push_integer(2);
          power();
          multiply();
          add();
          add();
        }
        push(symbol(SECRETX));
        recursionLevelNestedRadicalsRemoval++;
        roots();
        recursionLevelNestedRadicalsRemoval--;
        if (equal(stack[tos - 1], symbol(NIL))) {
          if (DEBUG) {
            console.log("roots bailed out because of too much recursion");
          }
          pop();
          push(p1);
          restore();
          return false;
        }
        possibleSolutions = [];
        ref1 = stack[tos - 1].tensor.elem;
        for (ae = 0, len2 = ref1.length; ae < len2; ae++) {
          eachSolution = ref1[ae];
          if (!Find(eachSolution, symbol(POWER))) {
            possibleSolutions.push(eachSolution);
          }
        }
        pop();
        if (possibleSolutions.length === 0) {
          push(p1);
          restore();
          return false;
        }
        possibleRationalSolutions = [];
        realOfpossibleRationalSolutions = [];
        for (af = 0, len3 = possibleSolutions.length; af < len3; af++) {
          i = possibleSolutions[af];
          push(i);
          real();
          yyfloat();
          possibleRationalSolutions.push(i);
          realOfpossibleRationalSolutions.push(pop().d);
        }
        whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));
        SOLUTION = possibleRationalSolutions[whichRationalSolution];

        /*
        			#possibleNewExpressions = []
        			#realOfPossibleNewExpressions = []
        			 * pick the solution which cubic root has no radicals
        			lowercase_b = null
        			for SOLUTION in possibleSolutions
        				console.log("testing solution: " + SOLUTION.toString())

        				debugger
        				if equalq(exponent,1,3)
        					push(A)
        					push(SOLUTION)
        					push_integer(3)
        					power()
        					push_integer(3)
        					push(C)
        					multiply()
        					push(SOLUTION)
        					multiply()
        					add()
        					divide()
        					console.log("argument of cubic root: " + stack[tos-1].toString())
        					push_rational(1,3)
        					power()
        				else if equalq(exponent,1,2)
        					push(A)
        					push(SOLUTION)
        					push_integer(2)
        					power()
        					push(C)
        					add()
        					divide()
        					console.log("argument of cubic root: " + stack[tos-1].toString())
        					push_rational(1,2)
        					power()
        				console.log("b is: " + stack[tos-1].toString())

        				lowercase_b = pop()

        				if !Find(lowercase_b, symbol(POWER))
        					break
         */
        if (equalq(exponent, 1, 3)) {
          push(A);
          push(SOLUTION);
          push_integer(3);
          power();
          push_integer(3);
          push(C);
          multiply();
          push(SOLUTION);
          multiply();
          add();
          divide();
          push_rational(1, 3);
          power();
        } else if (equalq(exponent, 1, 2)) {
          push(A);
          push(SOLUTION);
          push_integer(2);
          power();
          push(C);
          add();
          divide();
          push_rational(1, 2);
          power();
        }
        lowercase_b = pop();
        if (lowercase_b == null) {
          push(p1);
          restore();
          return false;
        }
        push(lowercase_b);
        push(SOLUTION);
        multiply();
        if (equalq(exponent, 1, 3)) {
          lowercase_a = pop();
          push(lowercase_b);
          push(C);
          push_rational(1, 2);
          power();
          multiply();
          push(lowercase_a);
          add();
          simplify();
        } else if (equalq(exponent, 1, 2)) {
          lowercase_a = pop();
          push(lowercase_b);
          push(C);
          push_rational(1, 2);
          power();
          multiply();
          push(lowercase_a);
          add();
          simplify();
          possibleNewExpression = pop();
          push(possibleNewExpression);
          real();
          yyfloat();
          possibleNewExpressionValue = pop();
          if (!isnegativenumber(possibleNewExpressionValue)) {
            push(possibleNewExpression);
          } else {
            push(lowercase_b);
            negate();
            lowercase_b = pop();
            push(lowercase_a);
            negate();
            lowercase_a = pop();
            push(lowercase_b);
            push(C);
            push_rational(1, 2);
            power();
            multiply();
            push(lowercase_a);
            add();
            simplify();
          }
        }
        p1 = pop();
        push(p1);
        restore();
        return true;
      } else {
        push(p1);
        restore();
        return false;
      }
    } else if (iscons(p1)) {
      h = tos;
      anyRadicalSimplificationWorked = false;
      while (iscons(p1)) {
        push(car(p1));
        anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();
        p1 = cdr(p1);
      }
      list(tos - h);
      restore();
      return anyRadicalSimplificationWorked;
    } else {
      push(p1);
      restore();
      return false;
    }
    throw new Error("control flow should never reach here");
  };

  Eval_sin = function() {
    push(cadr(p1));
    Eval();
    return sine();
  };

  sine = function() {
    save();
    p1 = pop();
    if (car(p1) === symbol(ADD)) {
      sine_of_angle_sum();
    } else {
      sine_of_angle();
    }
    return restore();
  };

  sine_of_angle_sum = function() {
    p2 = cdr(p1);
    while (iscons(p2)) {
      p4 = car(p2);
      if (isnpi(p4)) {
        push(p1);
        push(p4);
        subtract();
        p3 = pop();
        push(p3);
        sine();
        push(p4);
        cosine();
        multiply();
        push(p3);
        cosine();
        push(p4);
        sine();
        multiply();
        add();
        return;
      }
      p2 = cdr(p2);
    }
    return sine_of_angle();
  };

  sine_of_angle = function() {
    var d, n;
    if (car(p1) === symbol(ARCSIN)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.sin(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      sine();
      negate();
      return;
    }
    if (car(p1) === symbol(ARCTAN)) {
      push(cadr(p1));
      push_integer(1);
      push(cadr(p1));
      push_integer(2);
      power();
      add();
      push_rational(-1, 2);
      power();
      multiply();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push_symbol(PI);
    }
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(SIN));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 0:
      case 180:
        return push_integer(0);
      case 30:
      case 150:
        return push_rational(1, 2);
      case 210:
      case 330:
        return push_rational(-1, 2);
      case 45:
      case 135:
        push_rational(1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 225:
      case 315:
        push_rational(-1, 2);
        push_integer(2);
        push_rational(1, 2);
        power();
        return multiply();
      case 60:
      case 120:
        push_rational(1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 240:
      case 300:
        push_rational(-1, 2);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 90:
        return push_integer(1);
      case 270:
        return push_integer(-1);
      default:
        push(symbol(SIN));
        push(p1);
        return list(2);
    }
  };

  Eval_sinh = function() {
    push(cadr(p1));
    Eval();
    return ysinh();
  };

  ysinh = function() {
    save();
    yysinh();
    return restore();
  };

  yysinh = function() {
    var d;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCSINH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.sinh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(zero);
      return;
    }
    push_symbol(SINH);
    push(p1);
    return list(2);
  };


  /*
  	Substitute new expr for old expr in expr.

  	Input:	push	expr

  		push	old expr

  		push	new expr

  	Output:	Result on stack
   */

  subst = function() {
    var ac, ad, i, ref1, ref2;
    i = 0;
    save();
    p3 = pop();
    p2 = pop();
    if (p2 === symbol(NIL) || p3 === symbol(NIL)) {
      restore();
      return;
    }
    p1 = pop();
    if (istensor(p1)) {
      p4 = alloc_tensor(p1.tensor.nelem);
      p4.tensor.ndim = p1.tensor.ndim;
      for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        p4.tensor.dim[i] = p1.tensor.dim[i];
      }
      for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
        push(p1.tensor.elem[i]);
        push(p2);
        push(p3);
        subst();
        p4.tensor.elem[i] = pop();
        if (p4.tensor.nelem !== p4.tensor.elem.length) {
          console.log("something wrong in tensor dimensions");
          debugger;
        }
      }
      push(p4);
    } else if (equal(p1, p2)) {
      push(p3);
    } else if (iscons(p1)) {
      push(car(p1));
      push(p2);
      push(p3);
      subst();
      push(cdr(p1));
      push(p2);
      push(p3);
      subst();
      cons();
    } else {
      push(p1);
    }
    return restore();
  };

  Eval_sum = function() {
    var ac, i, j, k, ref1, ref2;
    i = 0;
    j = 0;
    k = 0;
    p6 = cadr(p1);
    if (!issymbol(p6)) {
      stop("sum: 1st arg?");
    }
    push(caddr(p1));
    Eval();
    j = pop_integer();
    if (j === 0x80000000) {
      stop("sum: 2nd arg?");
    }
    push(cadddr(p1));
    Eval();
    k = pop_integer();
    if (k === 0x80000000) {
      stop("sum: 3rd arg?");
    }
    p1 = caddddr(p1);
    p4 = get_binding(p6);
    push_integer(0);
    for (i = ac = ref1 = j, ref2 = k; ref1 <= ref2 ? ac <= ref2 : ac >= ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      push_integer(i);
      p5 = pop();
      set_binding(p6, p5);
      push(p1);
      Eval();
      add();
    }
    return set_binding(p6, p4);
  };

  Eval_tan = function() {
    push(cadr(p1));
    Eval();
    return tangent();
  };

  tangent = function() {
    save();
    yytangent();
    return restore();
  };

  yytangent = function() {
    var d, n;
    n = 0;
    d = 0.0;
    p1 = pop();
    if (car(p1) === symbol(ARCTAN)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.tan(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (isnegative(p1)) {
      push(p1);
      negate();
      tangent();
      negate();
      return;
    }
    push(p1);
    push_integer(180);
    multiply();
    if (evaluatingAsFloats) {
      push_double(Math.PI);
    } else {
      push_symbol(PI);
    }
    divide();
    n = pop_integer();
    if (n < 0 || n === 0x80000000) {
      push(symbol(TAN));
      push(p1);
      list(2);
      return;
    }
    switch (n % 360) {
      case 0:
      case 180:
        return push_integer(0);
      case 30:
      case 210:
        push_rational(1, 3);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 150:
      case 330:
        push_rational(-1, 3);
        push_integer(3);
        push_rational(1, 2);
        power();
        return multiply();
      case 45:
      case 225:
        return push_integer(1);
      case 135:
      case 315:
        return push_integer(-1);
      case 60:
      case 240:
        push_integer(3);
        push_rational(1, 2);
        return power();
      case 120:
      case 300:
        push_integer(3);
        push_rational(1, 2);
        power();
        return negate();
      default:
        push(symbol(TAN));
        push(p1);
        return list(2);
    }
  };

  Eval_tanh = function() {
    var d;
    d = 0.0;
    push(cadr(p1));
    Eval();
    p1 = pop();
    if (car(p1) === symbol(ARCTANH)) {
      push(cadr(p1));
      return;
    }
    if (isdouble(p1)) {
      d = Math.tanh(p1.d);
      if (Math.abs(d) < 1e-10) {
        d = 0.0;
      }
      push_double(d);
      return;
    }
    if (iszero(p1)) {
      push(zero);
      return;
    }
    push_symbol(TANH);
    push(p1);
    return list(2);
  };


  /*
  Taylor expansion of a function

  	push(F)
  	push(X)
  	push(N)
  	push(A)
  	taylor()
   */

  Eval_taylor = function() {
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      guess();
    } else {
      push(p2);
    }
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(24);
    } else {
      push(p2);
    }
    p1 = cdr(p1);
    push(car(p1));
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push_integer(0);
    } else {
      push(p2);
    }
    return taylor();
  };

  taylor = function() {
    var ac, i, k, ref1;
    i = 0;
    k = 0;
    save();
    p4 = pop();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    push(p3);
    k = pop_integer();
    if (k === 0x80000000) {
      push_symbol(TAYLOR);
      push(p1);
      push(p2);
      push(p3);
      push(p4);
      list(5);
      restore();
      return;
    }
    push(p1);
    push(p2);
    push(p4);
    subst();
    Eval();
    push_integer(1);
    p5 = pop();
    for (i = ac = 1, ref1 = k; 1 <= ref1 ? ac <= ref1 : ac >= ref1; i = 1 <= ref1 ? ++ac : --ac) {
      push(p1);
      push(p2);
      derivative();
      p1 = pop();
      if (iszero(p1)) {
        break;
      }
      push(p5);
      push(p2);
      push(p4);
      subtract();
      multiply();
      p5 = pop();
      push(p1);
      push(p2);
      push(p4);
      subst();
      Eval();
      push(p5);
      multiply();
      push_integer(i);
      factorial();
      divide();
      add();
    }
    return restore();
  };


  /* Tensor =====================================================================

  Tags
  ----
  [[scripting]] [[JS]] [[internal]] [[treenode]] [[generalconcept]]

  General description
  -------------------
  A tensor is...

  Limitations
  -----------
  n.a.

  Implementation info
  -------------------
  Tensors are implemented...
   */

  Eval_tensor = function() {
    var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
    i = 0;
    ndim = 0;
    nelem = 0;
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    nelem = p1.tensor.nelem;
    ndim = p1.tensor.ndim;
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim;
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(a[i]);
      Eval();
      b[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p2);
    return promote_tensor();
  };

  tensor_plus_tensor = function() {
    var a, ac, ad, ae, b, c, i, ndim, nelem, ref1, ref2, ref3;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p1.tensor.ndim;
    if (ndim !== p2.tensor.ndim) {
      push(symbol(NIL));
      restore();
      return;
    }
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {
        push(symbol(NIL));
        restore();
        return;
      }
    }
    nelem = p1.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = ad = 0, ref2 = ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    c = p3.tensor.elem;
    for (i = ae = 0, ref3 = nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      push(a[i]);
      push(b[i]);
      add();
      c[i] = pop();
    }
    push(p3);
    return restore();
  };

  tensor_times_scalar = function() {
    var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p3.tensor.elem;
    for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(a[i]);
      push(p2);
      multiply();
      b[i] = pop();
    }
    push(p3);
    return restore();
  };

  scalar_times_tensor = function() {
    var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
    i = 0;
    ndim = 0;
    nelem = 0;
    save();
    p2 = pop();
    p1 = pop();
    ndim = p2.tensor.ndim;
    nelem = p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p3.tensor.dim[i] = p2.tensor.dim[i];
    }
    a = p2.tensor.elem;
    b = p3.tensor.elem;
    for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(p1);
      push(a[i]);
      multiply();
      b[i] = pop();
    }
    push(p3);
    return restore();
  };

  is_square_matrix = function(p) {
    if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {
      return 1;
    } else {
      return 0;
    }
  };

  d_tensor_tensor = function() {
    var a, ac, ad, ae, b, c, i, j, ndim, nelem, ref1, ref2, ref3;
    i = 0;
    j = 0;
    ndim = 0;
    nelem = 0;
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    if (ndim + 1 >= MAXDIM) {
      push_symbol(DERIVATIVE);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    p3 = alloc_tensor(nelem * p2.tensor.nelem);
    p3.tensor.ndim = ndim + 1;
    for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    p3.tensor.dim[ndim] = p2.tensor.dim[0];
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    c = p3.tensor.elem;
    for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      for (j = ae = 0, ref3 = p2.tensor.nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
        push(a[i]);
        push(b[j]);
        derivative();
        c[i * p2.tensor.nelem + j] = pop();
      }
    }
    return push(p3);
  };

  d_scalar_tensor = function() {
    var a, ac, b, i, ref1;
    p3 = alloc_tensor(p2.tensor.nelem);
    p3.tensor.ndim = 1;
    p3.tensor.dim[0] = p2.tensor.dim[0];
    a = p2.tensor.elem;
    b = p3.tensor.elem;
    for (i = ac = 0, ref1 = p2.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1);
      push(a[i]);
      derivative();
      b[i] = pop();
    }
    return push(p3);
  };

  d_tensor_scalar = function() {
    var a, ac, ad, b, i, ref1, ref2;
    i = 0;
    p3 = alloc_tensor(p1.tensor.nelem);
    p3.tensor.ndim = p1.tensor.ndim;
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    a = p1.tensor.elem;
    b = p3.tensor.elem;
    for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(a[i]);
      push(p2);
      derivative();
      b[i] = pop();
    }
    return push(p3);
  };

  compare_tensors = function(p1, p2) {
    var ac, ad, i, ref1, ref2;
    i = 0;
    if (p1.tensor.ndim < p2.tensor.ndim) {
      return -1;
    }
    if (p1.tensor.ndim > p2.tensor.ndim) {
      return 1;
    }
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
        return -1;
      }
      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
        return 1;
      }
    }
    for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {
        continue;
      }
      if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {
        return -1;
      } else {
        return 1;
      }
    }
    return 0;
  };

  power_tensor = function() {
    var ac, ad, i, k, n, ref1, ref2, results;
    i = 0;
    k = 0;
    n = 0;
    k = p1.tensor.ndim - 1;
    if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    push(p2);
    n = pop_integer();
    if (n === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    if (n === 0) {
      if (p1.tensor.ndim !== 2) {
        stop("power(tensor,0) with tensor rank not equal to 2");
      }
      n = p1.tensor.dim[0];
      p1 = alloc_tensor(n * n);
      p1.tensor.ndim = 2;
      p1.tensor.dim[0] = n;
      p1.tensor.dim[1] = n;
      for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        p1.tensor.elem[n * i + i] = one;
      }
      if (p1.tensor.nelem !== p1.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
      push(p1);
      return;
    }
    if (n < 0) {
      n = -n;
      push(p1);
      inv();
      p1 = pop();
    }
    push(p1);
    results = [];
    for (i = ad = 1, ref2 = n; 1 <= ref2 ? ad < ref2 : ad > ref2; i = 1 <= ref2 ? ++ad : --ad) {
      push(p1);
      inner();
      if (iszero(stack[tos - 1])) {
        break;
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  copy_tensor = function() {
    var ac, ad, i, ref1, ref2;
    i = 0;
    save();
    p1 = pop();
    p2 = alloc_tensor(p1.tensor.nelem);
    p2.tensor.ndim = p1.tensor.ndim;
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      p2.tensor.elem[i] = p1.tensor.elem[i];
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p2);
    return restore();
  };

  promote_tensor = function() {
    var ac, ad, ae, af, ag, i, j, k, ndim, nelem, ref1, ref2, ref3, ref4, ref5;
    i = 0;
    j = 0;
    k = 0;
    nelem = 0;
    ndim = 0;
    save();
    p1 = pop();
    if (!istensor(p1)) {
      push(p1);
      restore();
      return;
    }
    p2 = p1.tensor.elem[0];
    for (i = ac = 1, ref1 = p1.tensor.nelem; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
      if (!compatible(p2, p1.tensor.elem[i])) {
        stop("Cannot promote tensor due to inconsistent tensor components.");
      }
    }
    if (!istensor(p2)) {
      push(p1);
      restore();
      return;
    }
    ndim = p1.tensor.ndim + p2.tensor.ndim;
    if (ndim > MAXDIM) {
      stop("tensor rank > 24");
    }
    nelem = p1.tensor.nelem * p2.tensor.nelem;
    p3 = alloc_tensor(nelem);
    p3.tensor.ndim = ndim;
    for (i = ad = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (j = ae = 0, ref3 = p2.tensor.ndim; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
      p3.tensor.dim[i + j] = p2.tensor.dim[j];
    }
    k = 0;
    for (i = af = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
      p2 = p1.tensor.elem[i];
      for (j = ag = 0, ref5 = p2.tensor.nelem; 0 <= ref5 ? ag < ref5 : ag > ref5; j = 0 <= ref5 ? ++ag : --ag) {
        p3.tensor.elem[k++] = p2.tensor.elem[j];
      }
    }
    if (p2.tensor.nelem !== p2.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    if (p3.tensor.nelem !== p3.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p3);
    return restore();
  };

  compatible = function(p, q) {
    var ac, i, ref1;
    if (!istensor(p) && !istensor(q)) {
      return 1;
    }
    if (!istensor(p) || !istensor(q)) {
      return 0;
    }
    if (p.tensor.ndim !== q.tensor.ndim) {
      return 0;
    }
    for (i = ac = 0, ref1 = p.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (p.tensor.dim[i] !== q.tensor.dim[i]) {
        return 0;
      }
    }
    return 1;
  };

  Eval_test = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      if (cdr(p1) === symbol(NIL)) {
        push(car(p1));
        Eval();
        return;
      }
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (!iszero(p2)) {
        push(cadr(p1));
        Eval();
        return;
      }
      p1 = cddr(p1);
    }
    return push_integer(0);
  };

  Eval_testeq = function() {
    var subtractionResult;
    push(cadr(p1));
    Eval();
    push(caddr(p1));
    Eval();
    subtract();
    subtractionResult = pop();
    if (iszero(subtractionResult)) {
      p1 = subtractionResult;
      return push_integer(1);
    } else {
      push(cadr(p1));
      Eval();
      simplify();
      push(caddr(p1));
      Eval();
      simplify();
      subtract();
      p1 = pop();
      if (iszero(p1)) {
        return push_integer(1);
      } else {
        return push_integer(0);
      }
    }
  };

  Eval_testge = function() {
    if (cmp_args() >= 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testgt = function() {
    if (cmp_args() > 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testle = function() {
    if (cmp_args() <= 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_testlt = function() {
    if (cmp_args() < 0) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_not = function() {
    push(cadr(p1));
    Eval_predicate();
    p1 = pop();
    if (iszero(p1)) {
      return push_integer(1);
    } else {
      return push_integer(0);
    }
  };

  Eval_and = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (iszero(p2)) {
        push_integer(0);
        return;
      }
      p1 = cdr(p1);
    }
    return push_integer(1);
  };

  Eval_or = function() {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      Eval_predicate();
      p2 = pop();
      if (!iszero(p2)) {
        push_integer(1);
        return;
      }
      p1 = cdr(p1);
    }
    return push_integer(0);
  };

  cmp_args = function() {
    var t;
    t = 0;
    push(cadr(p1));
    Eval();
    simplify();
    push(caddr(p1));
    Eval();
    simplify();
    subtract();
    p1 = pop();
    if (p1.k !== NUM && p1.k !== DOUBLE) {
      push(p1);
      yyfloat();
      Eval();
      p1 = pop();
    }
    if (iszero(p1)) {
      return 0;
    }
    switch (p1.k) {
      case NUM:
        if (MSIGN(p1.q.a) === -1) {
          t = -1;
        } else {
          t = 1;
        }
        break;
      case DOUBLE:
        if (p1.d < 0.0) {
          t = -1;
        } else {
          t = 1;
        }
        break;
      default:
        stop("relational operator: cannot determine due to non-numerical comparison");
        t = 0;
    }
    return t;
  };


  /*
  Transform an expression using table look-up

  The expression and free variable are on the stack.

  The argument s is a null terminated list of transform rules.

  For example, see the itab (integrals table)

  Internally, the following symbols are used:

  	F	input expression

  	X	free variable, i.e. F of X

  	A	template expression

  	B	result expression

  	C	list of conditional expressions

  Puts the final expression on top of stack
  (whether it's transformed or not) and returns
  true is successful, false if not.
   */

  transform = function(s, generalTransform) {
    var ac, ad, ae, eachTransformEntry, firstTermSuccess, firstTermTransform, i, len, len1, ref1, secondTermSuccess, secondTermTransform, transform_h, transformationSuccessful;
    transform_h = 0;
    save();
    p1 = null;
    p4 = pop();
    p3 = pop();
    if (DEBUG) {
      console.log("         !!!!!!!!!   transform on: " + p3);
    }
    push(get_binding(symbol(METAA)));
    push(get_binding(symbol(METAB)));
    push(get_binding(symbol(METAX)));
    set_binding(symbol(METAX), p4);
    transform_h = tos;
    push_integer(1);
    push(p3);
    push(p4);
    polyform();
    push(p4);
    decomp(generalTransform);
    if (DEBUG) {
      for (i = ac = 1, ref1 = tos; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
        console.log("stack content at " + i + " " + stack[tos - i]);
      }
    }
    if (generalTransform) {
      for (ad = 0, len = s.length; ad < len; ad++) {
        eachTransformEntry = s[ad];
        if (DEBUG) {
          console.log("scanning table entry " + eachTransformEntry);
        }
        if (eachTransformEntry) {
          push(eachTransformEntry);
          push(symbol(SYMBOL_A_UNDERSCORE));
          push(symbol(METAA));
          subst();
          push(symbol(SYMBOL_B_UNDERSCORE));
          push(symbol(METAB));
          subst();
          push(symbol(SYMBOL_X_UNDERSCORE));
          push(symbol(METAX));
          subst();
          p1 = pop();
          p5 = car(p1);
          p6 = cadr(p1);
          p7 = cddr(p1);

          /*
          				p5 = p1.tensor.elem[0]
          				p6 = p1.tensor.elem[1]
          				for i in [2..(p1.tensor.elem.length-1)]
          					push p1.tensor.elem[i]
          				list(p1.tensor.elem.length - 2)
          				p7 = pop()
           */
          if (f_equals_a(transform_h, generalTransform)) {
            break;
          } else {
            if (iscons(p3)) {
              push(car(p3));
              push_symbol(NIL);
              firstTermSuccess = transform(s, generalTransform);
              firstTermTransform = stack[tos - 1];
              if (DEBUG) {
                console.log("trying to simplify first term: " + car(p3) + " ..." + firstTermSuccess);
              }
              push(cdr(p3));
              push_symbol(NIL);
              if (DEBUG) {
                console.log("testing: " + cdr(p3));
              }
              secondTermSuccess = transform(s, generalTransform);
              secondTermTransform = stack[tos - 1];
              if (DEBUG) {
                console.log("trying to simplify other term: " + cdr(p3) + " ..." + secondTermSuccess);
              }
              tos = transform_h;
              restoreMetaBindings();
              push(firstTermTransform);
              push(secondTermTransform);
              cons();
              restore();
              if (firstTermSuccess || secondTermSuccess) {
                return true;
              } else {
                return false;
              }
            }
          }
        }
      }
    } else {
      for (ae = 0, len1 = s.length; ae < len1; ae++) {
        eachTransformEntry = s[ae];
        if (DEBUG) {
          console.log("scanning table entry " + eachTransformEntry);
        }
        if (eachTransformEntry) {
          scan_meta(eachTransformEntry);
          p1 = pop();
          p5 = cadr(p1);
          p6 = caddr(p1);
          p7 = cdddr(p1);

          /*
          				p5 = p1.tensor.elem[0]
          				p6 = p1.tensor.elem[1]
          				for i in [2..(p1.tensor.elem.length-1)]
          					push p1.tensor.elem[i]
          				list(p1.tensor.elem.length - 2)
          				p7 = pop()
           */
          if (f_equals_a(transform_h, generalTransform)) {
            break;
          }
        }
      }
    }
    tos = transform_h;
    transformationSuccessful = false;
    if (eachTransformEntry) {
      push(p6);
      Eval();
      p1 = pop();
      transformationSuccessful = true;
    } else {
      if (generalTransform) {
        p1 = p3;
      } else {
        p1 = symbol(NIL);
      }
    }
    restoreMetaBindings();
    push(p1);
    restore();
    return transformationSuccessful;
  };

  restoreMetaBindings = function() {
    set_binding(symbol(METAX), pop());
    set_binding(symbol(METAB), pop());
    return set_binding(symbol(METAA), pop());
  };

  f_equals_a = function(h, generalTransform) {
    var ac, ad, fea_i, fea_j, originalexpanding, ref1, ref2, ref3, ref4;
    fea_i = 0;
    fea_j = 0;
    for (fea_i = ac = ref1 = h, ref2 = tos; ref1 <= ref2 ? ac < ref2 : ac > ref2; fea_i = ref1 <= ref2 ? ++ac : --ac) {
      if (generalTransform && isnum(stack[fea_i])) {
        continue;
      }
      set_binding(symbol(METAA), stack[fea_i]);
      if (DEBUG) {
        console.log("binding METAA to " + get_binding(symbol(METAA)));
      }
      for (fea_j = ad = ref3 = h, ref4 = tos; ref3 <= ref4 ? ad < ref4 : ad > ref4; fea_j = ref3 <= ref4 ? ++ad : --ad) {
        if (generalTransform && isnum(stack[fea_j])) {
          continue;
        }
        set_binding(symbol(METAB), stack[fea_j]);
        if (DEBUG) {
          console.log("binding METAB to " + get_binding(symbol(METAB)));
        }
        p1 = p7;
        while (iscons(p1)) {
          push(car(p1));
          Eval();
          p2 = pop();
          if (iszero(p2)) {
            break;
          }
          p1 = cdr(p1);
        }
        if (iscons(p1)) {
          continue;
        }
        push(p3);
        push(p5);
        if (generalTransform) {
          originalexpanding = expanding;
          expanding = false;
        }
        Eval();
        if (generalTransform) {
          expanding = originalexpanding;
        }
        if (DEBUG) {
          console.log("comparing " + stack[tos - 1] + " to: " + stack[tos - 2]);
        }
        subtract();
        p1 = pop();
        if (iszero(p1)) {
          if (DEBUG) {
            console.log("binding METAA to " + get_binding(symbol(METAA)));
            console.log("binding METAB to " + get_binding(symbol(METAB)));
            console.log("comparing " + p3 + " to: " + p5);
          }
          return 1;
        }
      }
    }
    return 0;
  };

  Eval_transpose = function() {
    push(cadr(p1));
    Eval();
    if (cddr(p1) === symbol(NIL)) {
      push_integer(1);
      push_integer(2);
    } else {
      push(caddr(p1));
      Eval();
      push(cadddr(p1));
      Eval();
    }
    return transpose();
  };

  transpose = function() {
    var a, ac, accumulator, ad, ae, af, ag, ah, ai, aj, an, b, eachEntry, i, innerTranspSwitch1, innerTranspSwitch2, j, k, l, m, ndim, nelem, ref1, ref2, ref3, ref4, ref5, ref6, ref7, t;
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    m = 0;
    ndim = 0;
    nelem = 0;
    t = 0;
    ai = [];
    an = [];
    for (i = ac = 0, ref1 = MAXDIM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      ai[i] = 0;
      an[i] = 0;
    }
    save();
    p3 = pop();
    p2 = pop();
    p1 = pop();
    if (isnum(p1)) {
      push(p1);
      restore();
      return;
    }
    if ((isplusone(p2) && isplustwo(p3)) || (isplusone(p3) && isplustwo(p2))) {
      if (isidentitymatrix(p1)) {
        push(p1);
        restore();
        return;
      }
    }
    if (istranspose(p1)) {
      innerTranspSwitch1 = car(cdr(cdr(p1)));
      innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));
      if ((equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2)) || (equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2)) || ((equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL))) && ((isplusone(p3) && isplustwo(p2)) || (isplusone(p2) && isplustwo(p3))))) {
        push(car(cdr(p1)));
        restore();
        return;
      }
    }
    if (expanding && isadd(p1)) {
      p1 = cdr(p1);
      push(zero);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        push(p3);
        transpose();
        add();
        p1 = cdr(p1);
      }
      restore();
      return;
    }
    if (expanding && ismultiply(p1)) {
      p1 = cdr(p1);
      push(one);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        push(p3);
        transpose();
        multiply();
        p1 = cdr(p1);
      }
      restore();
      return;
    }
    if (expanding && isinnerordot(p1)) {
      p1 = cdr(p1);
      accumulator = [];
      while (iscons(p1)) {
        accumulator.push([car(p1), p2, p3]);
        p1 = cdr(p1);
      }
      for (eachEntry = ad = ref2 = accumulator.length - 1; ref2 <= 0 ? ad <= 0 : ad >= 0; eachEntry = ref2 <= 0 ? ++ad : --ad) {
        push(accumulator[eachEntry][0]);
        push(accumulator[eachEntry][1]);
        push(accumulator[eachEntry][2]);
        transpose();
        if (eachEntry !== accumulator.length - 1) {
          inner();
        }
      }
      restore();
      return;
    }
    if (!istensor(p1)) {
      if (!iszero(p1)) {
        push_symbol(TRANSPOSE);
        push(p1);
        if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {
          push(p2);
          push(p3);
          list(4);
        } else {
          list(2);
        }
        restore();
        return;
      }
      push(zero);
      restore();
      return;
    }
    ndim = p1.tensor.ndim;
    nelem = p1.tensor.nelem;
    if (ndim === 1) {
      push(p1);
      restore();
      return;
    }
    push(p2);
    l = pop_integer();
    push(p3);
    m = pop_integer();
    if (l < 1 || l > ndim || m < 1 || m > ndim) {
      stop("transpose: index out of range");
    }
    l--;
    m--;
    p2 = alloc_tensor(nelem);
    p2.tensor.ndim = ndim;
    for (i = ae = 0, ref3 = ndim; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
      p2.tensor.dim[i] = p1.tensor.dim[i];
    }
    p2.tensor.dim[l] = p1.tensor.dim[m];
    p2.tensor.dim[m] = p1.tensor.dim[l];
    a = p1.tensor.elem;
    b = p2.tensor.elem;
    for (i = af = 0, ref4 = ndim; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
      ai[i] = 0;
      an[i] = p1.tensor.dim[i];
    }
    for (i = ag = 0, ref5 = nelem; 0 <= ref5 ? ag < ref5 : ag > ref5; i = 0 <= ref5 ? ++ag : --ag) {
      t = ai[l];
      ai[l] = ai[m];
      ai[m] = t;
      t = an[l];
      an[l] = an[m];
      an[m] = t;
      k = 0;
      for (j = ah = 0, ref6 = ndim; 0 <= ref6 ? ah < ref6 : ah > ref6; j = 0 <= ref6 ? ++ah : --ah) {
        k = (k * an[j]) + ai[j];
      }
      t = ai[l];
      ai[l] = ai[m];
      ai[m] = t;
      t = an[l];
      an[l] = an[m];
      an[m] = t;
      b[k] = a[i];
      for (j = aj = ref7 = ndim - 1; ref7 <= 0 ? aj <= 0 : aj >= 0; j = ref7 <= 0 ? ++aj : --aj) {
        if (++ai[j] < an[j]) {
          break;
        }
        ai[j] = 0;
      }
    }
    push(p2);
    return restore();
  };

  Eval_user_function = function() {
    var bodyAndFormalArguments, h;
    if (DEBUG) {
      console.log("Eval_user_function evaluating: " + car(p1));
    }
    if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {
      Eval_derivative();
      return;
    }
    bodyAndFormalArguments = get_binding(car(p1));
    p3 = car(cdr(bodyAndFormalArguments));
    p4 = car(cdr(cdr(bodyAndFormalArguments)));
    p5 = cdr(p1);
    if (bodyAndFormalArguments === car(p1)) {
      h = tos;
      push(bodyAndFormalArguments);
      p1 = p5;
      while (iscons(p1)) {
        push(car(p1));
        Eval();
        p1 = cdr(p1);
      }
      list(tos - h);
      return;
    }
    p1 = p4;
    p2 = p5;
    h = tos;
    while (iscons(p1) && iscons(p2)) {
      push(car(p1));
      push(car(p2));
      Eval();
      p1 = cdr(p1);
      p2 = cdr(p2);
    }
    list(tos - h);
    p6 = pop();
    push(p3);
    if (iscons(p6)) {
      push(p6);
      rewrite_args();
    }
    return Eval();
  };

  rewrite_args = function() {
    var h, n;
    n = 0;
    save();
    p2 = pop();
    p1 = pop();
    if (istensor(p1)) {
      n = rewrite_args_tensor();
      restore();
      return n;
    }
    if (iscons(p1)) {
      h = tos;
      push(car(p1));
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        push(p2);
        n += rewrite_args();
        p1 = cdr(p1);
      }
      list(tos - h);
      restore();
      return n;
    }
    if (!issymbol(p1)) {
      push(p1);
      restore();
      return 0;
    }
    p3 = p2;
    while (iscons(p3)) {
      if (p1 === car(p3)) {
        push(cadr(p3));
        restore();
        return 1;
      }
      p3 = cddr(p3);
    }
    p3 = get_binding(p1);
    push(p3);
    if (p1 !== p3) {
      push(p2);
      n = rewrite_args();
      if (n === 0) {
        pop();
        push(p1);
      }
    }
    restore();
    return n;
  };

  rewrite_args_tensor = function() {
    var ac, i, n, ref1;
    n = 0;
    i = 0;
    push(p1);
    copy_tensor();
    p1 = pop();
    for (i = ac = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      push(p1.tensor.elem[i]);
      push(p2);
      n += rewrite_args();
      p1.tensor.elem[i] = pop();
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p1);
    return n;
  };

  Eval_zero = function() {
    var ac, ad, i, k, m, n, ref1, ref2;
    i = 0;
    k = [];
    m = 0;
    n = 0;
    for (i = ac = 0, ref1 = MAXDIM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      k[i] = 0;
    }
    m = 1;
    n = 0;
    p2 = cdr(p1);
    while (iscons(p2)) {
      push(car(p2));
      Eval();
      i = pop_integer();
      if (i < 2) {
        push(zero);
        return;
      }
      m *= i;
      k[n++] = i;
      p2 = cdr(p2);
    }
    if (n === 0) {
      push(zero);
      return;
    }
    p1 = alloc_tensor(m);
    p1.tensor.ndim = n;
    for (i = ad = 0, ref2 = n; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      p1.tensor.dim[i] = k[i];
    }
    return push(p1);
  };


  /*
  // up to 100 blocks of 100,000 atoms

  #define M 100
  #define N 100000

  U *mem[M]
  int mcount

  U *free_list
  int free_count

  U *
  alloc(void)
  {
  	U *p
  	if (free_count == 0) {
  		if (mcount == 0)
  			alloc_mem()
  		else {
  			gc()
  			if (free_count < N * mcount / 2)
  				alloc_mem()
  		}
  		if (free_count == 0)
  			stop("atom space exhausted")
  	}
  	p = free_list
  	free_list = free_list->u.cons.cdr
  	free_count--
  	return p
  }
   */

  allocatedId = 0;

  alloc_tensor = function(nelem) {
    var ac, i, p, ref1;
    i = 0;
    p = new U();
    p.k = TENSOR;
    p.tensor = new tensor();
    p.tensor.nelem = nelem;
    for (i = ac = 0, ref1 = nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p.tensor.elem[i] = zero;
    }
    p.tensor.allocatedId = allocatedId;
    allocatedId++;
    if (p.tensor.nelem !== p.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    return p;
  };


  /*
  // garbage collector

  void
  gc(void)
  {
  	int i, j
  	U *p

  	// tag everything

  	for (i = 0; i < mcount; i++) {
  		p = mem[i]
  		for (j = 0; j < N; j++)
  			p[j].tag = 1
  	}

  	// untag what's used

  	untag(p0)
  	untag(p1)
  	untag(p2)
  	untag(p3)
  	untag(p4)
  	untag(p5)
  	untag(p6)
  	untag(p7)
  	untag(p8)
  	untag(p9)

  	untag(one)
  	untag(zero)
  	untag(imaginaryunit)

  	for (i = 0; i < NSYM; i++) {
  		untag(binding[i])
  		untag(arglist[i])
  	}

  	for (i = 0; i < tos; i++)
  		untag(stack[i])

  	for (i = (int) (frame - stack); i < TOS; i++)
  		untag(stack[i])

  	// collect everything that's still tagged

  	free_count = 0

  	for (i = 0; i < mcount; i++) {
  		p = mem[i]
  		for (j = 0; j < N; j++) {
  			if (p[j].tag == 0)
  				continue
  			// still tagged so it's unused, put on free list
  			switch (p[j].k) {
  			case TENSOR:
  				free(p[j].u.tensor)
  				break
  			case STR:
  				free(p[j].u.str)
  				break
  			case NUM:
  				mfree(p[j].u.q.a)
  				mfree(p[j].u.q.b)
  				break
  			}
  			p[j].k = CONS; // so no double free occurs above
  			p[j].u.cons.cdr = free_list
  			free_list = p + j
  			free_count++
  		}
  	}
  }

  void
  untag(U *p)
  {
  	int i

  	if (iscons(p)) {
  		do {
  			if (p->tag == 0)
  				return
  			p->tag = 0
  			untag(p->u.cons.car)
  			p = p->u.cons.cdr
  		} while (iscons(p))
  		untag(p)
  		return
  	}

  	if (p->tag) {
  		p->tag = 0
   		if (istensor(p)) {
  			for (i = 0; i < p->u.tensor->nelem; i++)
  				untag(p->u.tensor->elem[i])
  		}
  	}
  }

  // get memory for 100,000 atoms

  void
  alloc_mem(void)
  {
  	int i
  	U *p
  	if (mcount == M)
  		return
  	p = (U *) malloc(N * sizeof (struct U))
  	if (p == NULL)
  		return
  	mem[mcount++] = p
  	for (i = 0; i < N; i++) {
  		p[i].k = CONS; // so no free in gc
  		p[i].u.cons.cdr = p + i + 1
  	}
  	p[N - 1].u.cons.cdr = free_list
  	free_list = p
  	free_count += N
  }

  void
  print_mem_info(void)
  {
  	char buf[100]

  	sprintf(buf, "%d blocks (%d bytes/block)\n", N * mcount, (int) sizeof (U))
  	printstr(buf)

  	sprintf(buf, "%d free\n", free_count)
  	printstr(buf)

  	sprintf(buf, "%d used\n", N * mcount - free_count)
  	printstr(buf)
  }
   */

  YMAX = 10000;

  glyph = (function() {
    function glyph() {}

    glyph.prototype.c = 0;

    glyph.prototype.x = 0;

    glyph.prototype.y = 0;

    return glyph;

  })();

  chartab = [];

  for (charTabIndex = ac = 0, ref1 = YMAX; 0 <= ref1 ? ac < ref1 : ac > ref1; charTabIndex = 0 <= ref1 ? ++ac : --ac) {
    chartab[charTabIndex] = new glyph();
  }

  yindex = 0;

  level = 0;

  emit_x = 0;

  expr_level = 0;

  display_flag = 0;

  printchar_nowrap = function(character, accumulator) {
    var topLevelCall;
    if (accumulator == null) {
      topLevelCall = true;
      accumulator = "";
    }
    accumulator += character;
    return accumulator;
  };

  printchar = function(character, accumulator) {
    return printchar_nowrap(character, accumulator);
  };

  display = function(p) {
    var h, ref2, w, y;
    h = 0;
    w = 0;
    y = 0;
    save();
    yindex = 0;
    level = 0;
    emit_x = 0;
    emit_top_expr(p);
    ref2 = get_size(0, yindex), h = ref2[0], w = ref2[1], y = ref2[2];
    if (w > 100) {
      printline(p);
      restore();
      return;
    }
    print_it();
    return restore();
  };

  emit_top_expr = function(p) {
    if (car(p) === symbol(SETQ)) {
      emit_expr(cadr(p));
      __emit_str(" = ");
      emit_expr(caddr(p));
      return;
    }
    if (istensor(p)) {
      return emit_tensor(p);
    } else {
      return emit_expr(p);
    }
  };

  will_be_displayed_as_fraction = function(p) {
    if (level > 0) {
      return 0;
    }
    if (isfraction(p)) {
      return 1;
    }
    if (car(p) !== symbol(MULTIPLY)) {
      return 0;
    }
    if (isfraction(cadr(p))) {
      return 1;
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  emit_expr = function(p) {
    expr_level++;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      if (__is_negative(car(p))) {
        __emit_char('-');
        if (will_be_displayed_as_fraction(car(p))) {
          __emit_char(' ');
        }
      }
      emit_term(car(p));
      p = cdr(p);
      while (iscons(p)) {
        if (__is_negative(car(p))) {
          __emit_char(' ');
          __emit_char('-');
          __emit_char(' ');
        } else {
          __emit_char(' ');
          __emit_char('+');
          __emit_char(' ');
        }
        emit_term(car(p));
        p = cdr(p);
      }
    } else {
      if (__is_negative(p)) {
        __emit_char('-');
        if (will_be_displayed_as_fraction(p)) {
          __emit_char(' ');
        }
      }
      emit_term(p);
    }
    return expr_level--;
  };

  emit_unsigned_expr = function(p) {
    var results;
    if (car(p) === symbol(ADD)) {
      p = cdr(p);
      emit_term(car(p));
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        if (__is_negative(car(p))) {
          __emit_char(' ');
          __emit_char('-');
          __emit_char(' ');
        } else {
          __emit_char(' ');
          __emit_char('+');
          __emit_char(' ');
        }
        emit_term(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      return emit_term(p);
    }
  };

  __is_negative = function(p) {
    if (isnegativenumber(p)) {
      return 1;
    }
    if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
      return 1;
    }
    return 0;
  };

  emit_term = function(p) {
    var n;
    if (car(p) === symbol(MULTIPLY)) {
      n = count_denominators(p);
      if (n && level === 0) {
        return emit_fraction(p, n);
      } else {
        return emit_multiply(p, n);
      }
    } else {
      return emit_factor(p);
    }
  };

  isdenominator = function(p) {
    if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  };

  count_denominators = function(p) {
    var q;
    count = 0;
    p = cdr(p);
    while (iscons(p)) {
      q = car(p);
      if (isdenominator(q)) {
        count++;
      }
      p = cdr(p);
    }
    return count;
  };

  emit_multiply = function(p, n) {
    var results;
    if (n === 0) {
      p = cdr(p);
      if (isplusone(car(p)) || isminusone(car(p))) {
        p = cdr(p);
      }
      emit_factor(car(p));
      p = cdr(p);
      results = [];
      while (iscons(p)) {
        __emit_char(' ');
        emit_factor(car(p));
        results.push(p = cdr(p));
      }
      return results;
    } else {
      emit_numerators(p);
      __emit_char('/');
      if (n > 1 || isfraction(cadr(p))) {
        __emit_char('(');
        emit_denominators(p);
        return __emit_char(')');
      } else {
        return emit_denominators(p);
      }
    }
  };

  emit_fraction = function(p, d) {
    var doNothing, k1, k2, n, x;
    count = 0;
    k1 = 0;
    k2 = 0;
    n = 0;
    x = 0;
    save();
    p3 = one;
    p4 = one;
    if (isrational(cadr(p))) {
      push(cadr(p));
      mp_numerator();
      absval();
      p3 = pop();
      push(cadr(p));
      mp_denominator();
      p4 = pop();
    }
    if (isdouble(cadr(p))) {
      push(cadr(p));
      absval();
      p3 = pop();
    }
    if (isplusone(p3)) {
      n = 0;
    } else {
      n = 1;
    }
    p1 = cdr(p);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        doNothing = 1;
      } else {
        n++;
      }
      p1 = cdr(p1);
    }
    x = emit_x;
    k1 = yindex;
    count = 0;
    if (!isplusone(p3)) {
      emit_number(p3, 0);
      count++;
    }
    p1 = cdr(p);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        doNothing = 1;
      } else {
        if (count > 0) {
          __emit_char(' ');
        }
        if (n === 1) {
          emit_expr(p2);
        } else {
          emit_factor(p2);
        }
        count++;
      }
      p1 = cdr(p1);
    }
    if (count === 0) {
      __emit_char('1');
    }
    k2 = yindex;
    count = 0;
    if (!isplusone(p4)) {
      emit_number(p4, 0);
      count++;
      d++;
    }
    p1 = cdr(p);
    if (isrational(car(p1))) {
      p1 = cdr(p1);
    }
    while (iscons(p1)) {
      p2 = car(p1);
      if (isdenominator(p2)) {
        if (count > 0) {
          __emit_char(' ');
        }
        emit_denominator(p2, d);
        count++;
      }
      p1 = cdr(p1);
    }
    fixup_fraction(x, k1, k2);
    return restore();
  };

  emit_numerators = function(p) {
    var doNothing, n;
    int(n);
    save();
    p1 = one;
    p = cdr(p);
    if (isrational(car(p))) {
      push(car(p));
      mp_numerator();
      absval();
      p1 = pop();
      p = cdr(p);
    } else if (isdouble(car(p))) {
      push(car(p));
      absval();
      p1 = pop();
      p = cdr(p);
    }
    n = 0;
    if (!isplusone(p1)) {
      emit_number(p1, 0);
      n++;
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        doNothing = 1;
      } else {
        if (n > 0) {
          __emit_char(' ');
        }
        emit_factor(car(p));
        n++;
      }
      p = cdr(p);
    }
    if (n === 0) {
      __emit_char('1');
    }
    return restore();
  };

  emit_denominators = function(p) {
    var n;
    int(n);
    save();
    n = 0;
    p = cdr(p);
    if (isfraction(car(p))) {
      push(car(p));
      mp_denominator();
      p1 = pop();
      emit_number(p1, 0);
      n++;
      p = cdr(p);
    }
    while (iscons(p)) {
      if (isdenominator(car(p))) {
        if (n > 0) {
          __emit_char(' ');
        }
        emit_denominator(car(p), 0);
        n++;
      }
      p = cdr(p);
    }
    return restore();
  };

  emit_factor = function(p) {
    if (istensor(p)) {
      if (level === 0) {
        emit_flat_tensor(p);
      } else {
        emit_flat_tensor(p);
      }
      return;
    }
    if (isdouble(p)) {
      emit_number(p, 0);
      return;
    }
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {
      emit_subexpr(p);
      return;
    }
    if (car(p) === symbol(POWER)) {
      emit_power(p);
      return;
    }
    if (iscons(p)) {
      emit_function(p);
      return;
    }
    if (isnum(p)) {
      if (level === 0) {
        emit_numerical_fraction(p);
      } else {
        emit_number(p, 0);
      }
      return;
    }
    if (issymbol(p)) {
      emit_symbol(p);
      return;
    }
    if (isstr(p)) {
      emit_string(p);
    }
  };

  emit_numerical_fraction = function(p) {
    var k1, k2, x;
    k1 = 0;
    k2 = 0;
    x = 0;
    save();
    push(p);
    mp_numerator();
    absval();
    p3 = pop();
    push(p);
    mp_denominator();
    p4 = pop();
    if (isplusone(p4)) {
      emit_number(p3, 0);
      restore();
      return;
    }
    x = emit_x;
    k1 = yindex;
    emit_number(p3, 0);
    k2 = yindex;
    emit_number(p4, 0);
    fixup_fraction(x, k1, k2);
    return restore();
  };

  isfactor = function(p) {
    if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {
      return 1;
    }
    if (issymbol(p)) {
      return 1;
    }
    if (isfraction(p)) {
      return 0;
    }
    if (isnegativenumber(p)) {
      return 0;
    }
    if (isnum(p)) {
      return 1;
    }
    return 0;
  };

  emit_power = function(p) {
    var k1, k2, x;
    k1 = 0;
    k2 = 0;
    x = 0;
    if (cadr(p) === symbol(E)) {
      __emit_str("exp(");
      emit_expr(caddr(p));
      __emit_char(')');
      return;
    }
    if (level > 0) {
      if (isminusone(caddr(p))) {
        __emit_char('1');
        __emit_char('/');
        if (isfactor(cadr(p))) {
          emit_factor(cadr(p));
        } else {
          emit_subexpr(cadr(p));
        }
      } else {
        if (isfactor(cadr(p))) {
          emit_factor(cadr(p));
        } else {
          emit_subexpr(cadr(p));
        }
        __emit_char('^');
        if (isfactor(caddr(p))) {
          emit_factor(caddr(p));
        } else {
          emit_subexpr(caddr(p));
        }
      }
      return;
    }
    if (__is_negative(caddr(p))) {
      x = emit_x;
      k1 = yindex;
      __emit_char('1');
      k2 = yindex;
      emit_denominator(p, 1);
      fixup_fraction(x, k1, k2);
      return;
    }
    k1 = yindex;
    if (isfactor(cadr(p))) {
      emit_factor(cadr(p));
    } else {
      emit_subexpr(cadr(p));
    }
    k2 = yindex;
    level++;
    emit_expr(caddr(p));
    level--;
    return fixup_power(k1, k2);
  };

  emit_denominator = function(p, n) {
    var k1, k2;
    k1 = 0;
    k2 = 0;
    if (isminusone(caddr(p))) {
      if (n === 1) {
        emit_expr(cadr(p));
      } else {
        emit_factor(cadr(p));
      }
      return;
    }
    k1 = yindex;
    if (isfactor(cadr(p))) {
      emit_factor(cadr(p));
    } else {
      emit_subexpr(cadr(p));
    }
    k2 = yindex;
    level++;
    emit_unsigned_expr(caddr(p));
    level--;
    return fixup_power(k1, k2);
  };

  emit_function = function(p) {
    if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
      emit_index_function(p);
      return;
    }
    if (car(p) === symbol(FACTORIAL)) {
      emit_factorial_function(p);
      return;
    }
    if (car(p) === symbol(DERIVATIVE)) {
      __emit_char('d');
    } else {
      emit_symbol(car(p));
    }
    __emit_char('(');
    p = cdr(p);
    if (iscons(p)) {
      emit_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        __emit_char(',');
        emit_expr(car(p));
        p = cdr(p);
      }
    }
    return __emit_char(')');
  };

  emit_index_function = function(p) {
    p = cdr(p);
    if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {
      emit_subexpr(car(p));
    } else {
      emit_expr(car(p));
    }
    __emit_char('[');
    p = cdr(p);
    if (iscons(p)) {
      emit_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        __emit_char(',');
        emit_expr(car(p));
        p = cdr(p);
      }
    }
    return __emit_char(']');
  };

  emit_factorial_function = function(p) {
    p = cadr(p);
    if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
      emit_subexpr(p);
    } else {
      emit_expr(p);
    }
    return __emit_char('!');
  };

  emit_subexpr = function(p) {
    __emit_char('(');
    emit_expr(p);
    return __emit_char(')');
  };

  emit_symbol = function(p) {
    var ad, i, pPrintName, ref2, results;
    i = 0;
    if (p === symbol(E)) {
      __emit_str("exp(1)");
      return;
    }
    pPrintName = get_printname(p);
    results = [];
    for (i = ad = 0, ref2 = pPrintName.length; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      results.push(__emit_char(pPrintName[i]));
    }
    return results;
  };

  emit_string = function(p) {
    var ad, i, pString, ref2;
    i = 0;
    pString = p.str;
    __emit_char('"');
    for (i = ad = 0, ref2 = pString.length; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      __emit_char(pString[i]);
    }
    return __emit_char('"');
  };

  fixup_fraction = function(x, k1, k2) {
    var ad, dx, dy, h1, h2, i, ref2, ref3, ref4, results, w, w1, w2, y, y1, y2;
    dx = 0;
    dy = 0;
    i = 0;
    w = 0;
    y = 0;
    h1 = 0;
    w1 = 0;
    y1 = 0;
    h2 = 0;
    w2 = 0;
    y2 = 0;
    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];
    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];
    if (w2 > w1) {
      dx = (w2 - w1) / 2;
    } else {
      dx = 0;
    }
    dx++;
    y = y1 + h1 - 1;
    dy = -y - 1;
    move(k1, k2, dx, dy);
    if (w2 > w1) {
      dx = -w1;
    } else {
      dx = -w1 + (w1 - w2) / 2;
    }
    dx++;
    dy = -y2 + 1;
    move(k2, yindex, dx, dy);
    if (w2 > w1) {
      w = w2;
    } else {
      w = w1;
    }
    w += 2;
    emit_x = x;
    results = [];
    for (i = ad = 0, ref4 = w; 0 <= ref4 ? ad < ref4 : ad > ref4; i = 0 <= ref4 ? ++ad : --ad) {
      results.push(__emit_char('-'));
    }
    return results;
  };

  fixup_power = function(k1, k2) {
    var dy, h1, h2, ref2, ref3, w1, w2, y1, y2;
    dy = 0;
    h1 = 0;
    w1 = 0;
    y1 = 0;
    h2 = 0;
    w2 = 0;
    y2 = 0;
    ref2 = get_size(k1, k2), h1 = ref2[0], w1 = ref2[1], y1 = ref2[2];
    ref3 = get_size(k2, yindex), h2 = ref3[0], w2 = ref3[1], y2 = ref3[2];
    dy = -y2 - h2 + 1;
    dy += y1 - 1;
    return move(k2, yindex, 0, dy);
  };

  move = function(j, k, dx, dy) {
    var ad, i, ref2, ref3, results;
    i = 0;
    results = [];
    for (i = ad = ref2 = j, ref3 = k; ref2 <= ref3 ? ad < ref3 : ad > ref3; i = ref2 <= ref3 ? ++ad : --ad) {
      chartab[i].x += dx;
      results.push(chartab[i].y += dy);
    }
    return results;
  };

  get_size = function(j, k) {
    var ad, h, i, max_x, max_y, min_x, min_y, ref2, ref3, w, y;
    i = 0;
    min_x = chartab[j].x;
    max_x = chartab[j].x;
    min_y = chartab[j].y;
    max_y = chartab[j].y;
    for (i = ad = ref2 = j + 1, ref3 = k; ref2 <= ref3 ? ad < ref3 : ad > ref3; i = ref2 <= ref3 ? ++ad : --ad) {
      if (chartab[i].x < min_x) {
        min_x = chartab[i].x;
      }
      if (chartab[i].x > max_x) {
        max_x = chartab[i].x;
      }
      if (chartab[i].y < min_y) {
        min_y = chartab[i].y;
      }
      if (chartab[i].y > max_y) {
        max_y = chartab[i].y;
      }
    }
    h = max_y - min_y + 1;
    w = max_x - min_x + 1;
    y = min_y;
    return [h, w, y];
  };

  displaychar = function(c) {
    return __emit_char(c);
  };

  __emit_char = function(c) {
    if (yindex === YMAX) {
      return;
    }
    if (chartab[yindex] == null) {
      debugger;
    }
    chartab[yindex].c = c;
    chartab[yindex].x = emit_x;
    chartab[yindex].y = 0;
    yindex++;
    return emit_x++;
  };

  __emit_str = function(s) {
    var ad, i, ref2, results;
    i = 0;
    results = [];
    for (i = ad = 0, ref2 = s.length; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      results.push(__emit_char(s[i]));
    }
    return results;
  };

  emit_number = function(p, emit_sign) {
    var ad, ae, af, i, ref2, ref3, ref4, results, results1, tmpString;
    tmpString = "";
    i = 0;
    switch (p.k) {
      case NUM:
        tmpString = p.q.a.toString();
        if (tmpString[0] === '-' && emit_sign === 0) {
          tmpString = tmpString.substring(1);
        }
        for (i = ad = 0, ref2 = tmpString.length; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
          __emit_char(tmpString[i]);
        }
        tmpString = p.q.b.toString();
        if (tmpString === "1") {
          break;
        }
        __emit_char('/');
        results = [];
        for (i = ae = 0, ref3 = tmpString.length; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
          results.push(__emit_char(tmpString[i]));
        }
        return results;
        break;
      case DOUBLE:
        tmpString = doubleToReasonableString(p.d);
        if (tmpString[0] === '-' && emit_sign === 0) {
          tmpString = tmpString.substring(1);
        }
        results1 = [];
        for (i = af = 0, ref4 = tmpString.length; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
          results1.push(__emit_char(tmpString[i]));
        }
        return results1;
    }
  };

  cmpGlyphs = function(a, b) {
    if (a.y < b.y) {
      return -1;
    }
    if (a.y > b.y) {
      return 1;
    }
    if (a.x < b.x) {
      return -1;
    }
    if (a.x > b.x) {
      return 1;
    }
    return 0;
  };

  print_it = function() {
    var accumulatedPrint, ad, i, ref2, subsetOfStack, x, y;
    i = 0;
    accumulatedPrint = "";
    subsetOfStack = chartab.slice(0, yindex);
    subsetOfStack.sort(cmpGlyphs);
    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
    x = 0;
    y = chartab[0].y;
    for (i = ad = 0, ref2 = yindex; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      while (chartab[i].y > y) {
        accumulatedPrint = printchar('\n', accumulatedPrint);
        x = 0;
        y++;
      }
      while (chartab[i].x > x) {
        accumulatedPrint = printchar_nowrap(' ', accumulatedPrint);
        x++;
      }
      accumulatedPrint = printchar_nowrap(chartab[i].c, accumulatedPrint);
      x++;
    }
    if (PRINTOUTRESULT) {
      return console.log(accumulatedPrint);
    }
  };

  buffer = "";

  getdisplaystr = function() {
    yindex = 0;
    level = 0;
    emit_x = 0;
    emit_expr(pop());
    fill_buf();
    return buffer;
  };

  fill_buf = function() {
    var ad, i, ref2, sIndex, subsetOfStack, tmpBuffer, x, y;
    tmpBuffer = buffer;
    sIndex = 0;
    i = 0;
    subsetOfStack = chartab.slice(0, yindex);
    subsetOfStack.sort(cmpGlyphs);
    chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
    x = 0;
    y = chartab[0].y;
    for (i = ad = 0, ref2 = yindex; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      while (chartab[i].y > y) {
        tmpBuffer[sIndex++] = '\n';
        x = 0;
        y++;
      }
      while (chartab[i].x > x) {
        tmpBuffer[sIndex++] = ' ';
        x++;
      }
      tmpBuffer[sIndex++] = chartab[i].c;
      x++;
    }
    return tmpBuffer[sIndex++] = '\n';
  };

  N = 100;

  oneElement = (function() {
    function oneElement() {}

    oneElement.prototype.x = 0;

    oneElement.prototype.y = 0;

    oneElement.prototype.h = 0;

    oneElement.prototype.w = 0;

    oneElement.prototype.index = 0;

    oneElement.prototype.count = 0;

    return oneElement;

  })();

  elem = [];

  for (elelmIndex = ad = 0; ad < 10000; elelmIndex = ++ad) {
    elem[elelmIndex] = new oneElement;
  }

  SPACE_BETWEEN_COLUMNS = 3;

  SPACE_BETWEEN_ROWS = 1;

  emit_tensor = function(p) {
    var ae, af, ag, ah, col, dx, dy, eh, ew, h, i, n, ncol, nrow, ref2, ref3, ref4, ref5, ref6, row, w, x, y;
    i = 0;
    n = 0;
    nrow = 0;
    ncol = 0;
    x = 0;
    y = 0;
    h = 0;
    w = 0;
    dx = 0;
    dy = 0;
    eh = 0;
    ew = 0;
    row = 0;
    col = 0;
    if (p.tensor.ndim > 2) {
      emit_flat_tensor(p);
      return;
    }
    nrow = p.tensor.dim[0];
    if (p.tensor.ndim === 2) {
      ncol = p.tensor.dim[1];
    } else {
      ncol = 1;
    }
    n = nrow * ncol;
    if (n > N) {
      emit_flat_tensor(p);
      return;
    }
    x = emit_x;
    for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      elem[i].index = yindex;
      elem[i].x = emit_x;
      emit_expr(p.tensor.elem[i]);
      elem[i].count = yindex - elem[i].index;
      ref3 = get_size(elem[i].index, yindex), elem[i].h = ref3[0], elem[i].w = ref3[1], elem[i].y = ref3[2];
    }
    eh = 0;
    ew = 0;
    for (i = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
      if (elem[i].h > eh) {
        eh = elem[i].h;
      }
      if (elem[i].w > ew) {
        ew = elem[i].w;
      }
    }
    h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
    w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
    y = -(h / 2);
    for (row = ag = 0, ref5 = nrow; 0 <= ref5 ? ag < ref5 : ag > ref5; row = 0 <= ref5 ? ++ag : --ag) {
      for (col = ah = 0, ref6 = ncol; 0 <= ref6 ? ah < ref6 : ah > ref6; col = 0 <= ref6 ? ++ah : --ah) {
        i = row * ncol + col;
        dx = x - elem[i].x;
        dy = y - elem[i].y;
        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
        dx = 0;
        if (col > 0) {
          dx = col * (ew + SPACE_BETWEEN_COLUMNS);
        }
        dy = 0;
        if (row > 0) {
          dy = row * (eh + SPACE_BETWEEN_ROWS);
        }
        dx += (ew - elem[i].w) / 2;
        dy += (eh - elem[i].h) / 2;
        move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
      }
    }
    return emit_x = x + w;

    /*
    	if 0

    		 * left brace

    		for (i = 0; i < h; i++) {
    			if (yindex == YMAX)
    				break
    			chartab[yindex].c = '|'
    			chartab[yindex].x = x - 2
    			chartab[yindex].y = y + i
    			yindex++
    		}

    		 * right brace

    		emit_x++

    		for (i = 0; i < h; i++) {
    			if (yindex == YMAX)
    				break
    			chartab[yindex].c = '|'
    			chartab[yindex].x = emit_x
    			chartab[yindex].y = y + i
    			yindex++
    		}

    		emit_x++

    	endif
     */
  };

  emit_flat_tensor = function(p) {
    return emit_tensor_inner(p, 0, 0);
  };

  emit_tensor_inner = function(p, j, k) {
    var ae, i, ref2;
    i = 0;
    __emit_char('(');
    for (i = ae = 0, ref2 = p.tensor.dim[j]; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      if (j + 1 === p.tensor.ndim) {
        emit_expr(p.tensor.elem[k]);
        k = k + 1;
      } else {
        k = emit_tensor_inner(p, j + 1, k);
      }
      if (i + 1 < p.tensor.dim[j]) {
        __emit_char(',');
      }
    }
    __emit_char(')');
    return k;
  };


  /*
  void
  test_display(void)
  {
  	test(__FILE__, s, sizeof s / sizeof (char *))
  }

  #endif
   */

  Find = function(p, q) {
    var ae, i, ref2;
    i = 0;
    if (equal(p, q)) {
      return 1;
    }
    if (istensor(p)) {
      for (i = ae = 0, ref2 = p.tensor.nelem; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
        if (Find(p.tensor.elem[i], q)) {
          return 1;
        }
      }
      return 0;
    }
    while (iscons(p)) {
      if (Find(car(p), q)) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  };

  $.Find = Find;

  init = function() {
    var ae, af, i, ref2, ref3;
    i = 0;
    flag = 0;
    tos = 0;
    esc_flag = 0;
    draw_flag = 0;
    frame = TOS;
    if (flag) {
      return;
    }
    flag = 1;
    for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      symtab[i] = new U();
    }
    for (i = af = 0, ref3 = NSYM; 0 <= ref3 ? af < ref3 : af > ref3; i = 0 <= ref3 ? ++af : --af) {
      symtab[i].k = SYM;
      binding[i] = symtab[i];
    }
    p0 = symbol(NIL);
    p1 = symbol(NIL);
    p2 = symbol(NIL);
    p3 = symbol(NIL);
    p4 = symbol(NIL);
    p5 = symbol(NIL);
    p6 = symbol(NIL);
    p7 = symbol(NIL);
    p8 = symbol(NIL);
    p9 = symbol(NIL);
    std_symbol("abs", ABS);
    std_symbol("add", ADD);
    std_symbol("pattern", PATTERN);
    std_symbol("adj", ADJ);
    std_symbol("and", AND);
    std_symbol("arccos", ARCCOS);
    std_symbol("arccosh", ARCCOSH);
    std_symbol("arcsin", ARCSIN);
    std_symbol("arcsinh", ARCSINH);
    std_symbol("arctan", ARCTAN);
    std_symbol("arctanh", ARCTANH);
    std_symbol("arg", ARG);
    std_symbol("atomize", ATOMIZE);
    std_symbol("besselj", BESSELJ);
    std_symbol("bessely", BESSELY);
    std_symbol("binding", BINDING);
    std_symbol("binomial", BINOMIAL);
    std_symbol("ceiling", CEILING);
    std_symbol("check", CHECK);
    std_symbol("choose", CHOOSE);
    std_symbol("circexp", CIRCEXP);
    std_symbol("clear", CLEAR);
    std_symbol("clearsubstrules", CLEARSUBSTRULES);
    std_symbol("clock", CLOCK);
    std_symbol("coeff", COEFF);
    std_symbol("cofactor", COFACTOR);
    std_symbol("condense", CONDENSE);
    std_symbol("conj", CONJ);
    std_symbol("contract", CONTRACT);
    std_symbol("cos", COS);
    std_symbol("cosh", COSH);
    std_symbol("decomp", DECOMP);
    std_symbol("defint", DEFINT);
    std_symbol("deg", DEGREE);
    std_symbol("denominator", DENOMINATOR);
    std_symbol("det", DET);
    std_symbol("derivative", DERIVATIVE);
    std_symbol("dim", DIM);
    std_symbol("dirac", DIRAC);
    std_symbol("display", DISPLAY);
    std_symbol("divisors", DIVISORS);
    std_symbol("do", DO);
    std_symbol("dot", DOT);
    std_symbol("draw", DRAW);
    std_symbol("dsolve", DSOLVE);
    std_symbol("erf", ERF);
    std_symbol("erfc", ERFC);
    std_symbol("eigen", EIGEN);
    std_symbol("eigenval", EIGENVAL);
    std_symbol("eigenvec", EIGENVEC);
    std_symbol("eval", EVAL);
    std_symbol("exp", EXP);
    std_symbol("expand", EXPAND);
    std_symbol("expcos", EXPCOS);
    std_symbol("expsin", EXPSIN);
    std_symbol("factor", FACTOR);
    std_symbol("factorial", FACTORIAL);
    std_symbol("factorpoly", FACTORPOLY);
    std_symbol("filter", FILTER);
    std_symbol("float", FLOATF);
    std_symbol("floor", FLOOR);
    std_symbol("for", FOR);
    std_symbol("function", FUNCTION);
    std_symbol("Gamma", GAMMA);
    std_symbol("gcd", GCD);
    std_symbol("hermite", HERMITE);
    std_symbol("hilbert", HILBERT);
    std_symbol("imag", IMAG);
    std_symbol("component", INDEX);
    std_symbol("inner", INNER);
    std_symbol("integral", INTEGRAL);
    std_symbol("inv", INV);
    std_symbol("invg", INVG);
    std_symbol("isinteger", ISINTEGER);
    std_symbol("isprime", ISPRIME);
    std_symbol("laguerre", LAGUERRE);
    std_symbol("lcm", LCM);
    std_symbol("leading", LEADING);
    std_symbol("legendre", LEGENDRE);
    std_symbol("log", LOG);
    std_symbol("lookup", LOOKUP);
    std_symbol("mag", MAG);
    std_symbol("mod", MOD);
    std_symbol("multiply", MULTIPLY);
    std_symbol("not", NOT);
    std_symbol("nroots", NROOTS);
    std_symbol("number", NUMBER);
    std_symbol("numerator", NUMERATOR);
    std_symbol("operator", OPERATOR);
    std_symbol("or", OR);
    std_symbol("outer", OUTER);
    std_symbol("polar", POLAR);
    std_symbol("power", POWER);
    std_symbol("prime", PRIME);
    std_symbol("print", PRINT);
    std_symbol("printlatex", PRINTLATEX);
    std_symbol("printLeaveEAlone", PRINT_LEAVE_E_ALONE);
    std_symbol("printLeaveXAlone", PRINT_LEAVE_X_ALONE);
    std_symbol("printlist", PRINTLIST);
    std_symbol("product", PRODUCT);
    std_symbol("quote", QUOTE);
    std_symbol("quotient", QUOTIENT);
    std_symbol("rank", RANK);
    std_symbol("rationalize", RATIONALIZE);
    std_symbol("real", REAL);
    std_symbol("rect", YYRECT);
    std_symbol("roots", ROOTS);
    std_symbol("equals", SETQ);
    std_symbol("sgn", SGN);
    std_symbol("simplify", SIMPLIFY);
    std_symbol("sin", SIN);
    std_symbol("sinh", SINH);
    std_symbol("shape", SHAPE);
    std_symbol("sqrt", SQRT);
    std_symbol("stop", STOP);
    std_symbol("subst", SUBST);
    std_symbol("sum", SUM);
    std_symbol("tan", TAN);
    std_symbol("tanh", TANH);
    std_symbol("taylor", TAYLOR);
    std_symbol("test", TEST);
    std_symbol("testeq", TESTEQ);
    std_symbol("testge", TESTGE);
    std_symbol("testgt", TESTGT);
    std_symbol("testle", TESTLE);
    std_symbol("testlt", TESTLT);
    std_symbol("transpose", TRANSPOSE);
    std_symbol("unit", UNIT);
    std_symbol("zero", ZERO);
    std_symbol("nil", NIL);
    std_symbol("autoexpand", AUTOEXPAND);
    std_symbol("bake", BAKE);
    std_symbol("last", LAST);
    std_symbol("lastlatexprint", LAST_LATEX_PRINT);
    std_symbol("trace", TRACE);
    std_symbol("tty", TTY);
    std_symbol("~", YYE);
    std_symbol("$DRAWX", DRAWX);
    std_symbol("$METAA", METAA);
    std_symbol("$METAB", METAB);
    std_symbol("$METAX", METAX);
    std_symbol("$SECRETX", SECRETX);
    std_symbol("pi", PI);
    std_symbol("a", SYMBOL_A);
    std_symbol("b", SYMBOL_B);
    std_symbol("c", SYMBOL_C);
    std_symbol("d", SYMBOL_D);
    std_symbol("i", SYMBOL_I);
    std_symbol("j", SYMBOL_J);
    std_symbol("n", SYMBOL_N);
    std_symbol("r", SYMBOL_R);
    std_symbol("s", SYMBOL_S);
    std_symbol("t", SYMBOL_T);
    std_symbol("x", SYMBOL_X);
    std_symbol("y", SYMBOL_Y);
    std_symbol("z", SYMBOL_Z);
    std_symbol("I", SYMBOL_IDENTITY_MATRIX);
    std_symbol("a_", SYMBOL_A_UNDERSCORE);
    std_symbol("b_", SYMBOL_B_UNDERSCORE);
    std_symbol("x_", SYMBOL_X_UNDERSCORE);
    std_symbol("$C1", C1);
    std_symbol("$C2", C2);
    std_symbol("$C3", C3);
    std_symbol("$C4", C4);
    std_symbol("$C5", C5);
    std_symbol("$C6", C6);
    push_integer(0);
    zero = pop();
    push_integer(1);
    one = pop();
    push_symbol(POWER);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    push_integer(-1);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    push_rational(1, 2);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    list(3);
    if (DEBUG) {
      print1(stack[tos - 1]);
    }
    imaginaryunit = pop();
    return defn();
  };

  defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "printLeaveEAlone=1", "printLeaveXAlone=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

  defn = function() {
    var ae, definitionOfInterest, defn_i, ref2, results;
    results = [];
    for (defn_i = ae = 0, ref2 = defn_str.length; 0 <= ref2 ? ae < ref2 : ae > ref2; defn_i = 0 <= ref2 ? ++ae : --ae) {
      definitionOfInterest = defn_str[defn_i];
      scan(definitionOfInterest);
      if (DEBUG) {
        console.log("... evaling " + definitionOfInterest);
        console.log("top of stack:");
        print1(stack[tos - 1]);
      }
      Eval();
      results.push(pop());
    }
    return results;
  };

  mcmp = function(a, b) {
    return a.compare(b);
  };

  mcmpint = function(a, n) {
    var b, t;
    b = bigInt(n);
    t = mcmp(a, b);
    return t;
  };


  /*
  #if SELFTEST

  void
  test_mcmp(void)
  {
  	int i, j, k
  	unsigned int *x, *y
  	logout("testing mcmp\n")
  	for (i = -1000; i < 1000; i++) {
  		x = mint(i)
  		for (j = -1000; j < 1000; j++) {
  			y = mint(j)
  			k = mcmp(x, y)
  			if (i == j && k != 0) {
  				logout("failed\n")
  				errout()
  			}
  			if (i < j && k != -1) {
  				logout("failed\n")
  				errout()
  			}
  			if (i > j && k != 1) {
  				logout("failed\n")
  				errout()
  			}
  			mfree(y)
  		}
  		mfree(x)
  	}
  	logout("ok\n")
  }

  #endif
   */

  strcmp = function(str1, str2) {
    if (str1 === str2) {
      return 0;
    } else if (str1 > str2) {
      return 1;
    } else {
      return -1;
    }
  };

  doubleToReasonableString = function(d) {
    return parseFloat(d.toPrecision(6));
  };

  clear_term = function() {};

  isspace = function(s) {
    if (s == null) {
      return false;
    }
    return s === ' ' || s === '\t' || s === '\n' || s === '\v' || s === '\f' || s === '\r';
  };

  isdigit = function(str) {
    if (str == null) {
      return false;
    }
    return /^\d+$/.test(str);
  };

  isalpha = function(str) {
    if (str == null) {
      return false;
    }
    return str.search(/[^A-Za-z]/) === -1;
  };

  isalphaOrUnderscore = function(str) {
    if (str == null) {
      return false;
    }
    return str.search(/[^A-Za-z_]/) === -1;
  };

  isunderscore = function(str) {
    if (str == null) {
      return false;
    }
    return str.search(/_/) === -1;
  };

  isalnumorunderscore = function(str) {
    if (str == null) {
      return false;
    }
    return isalphaOrUnderscore(str) || isdigit(str);
  };

  stop = function(s) {
    var message;
    errorMessage += "Stop: ";
    errorMessage += s;
    message = errorMessage;
    errorMessage = '';
    tos = 0;
    throw new Error(message);
  };

  test_dependencies = function() {
    var testResult;
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('1');
    if (testResult[0] === "All local dependencies: . All dependencies recursively: " && testResult[1] === "1" && testResult[2] === "") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = x+1\n g = f\n h = g\n f = g');
    if (testResult[0] === "All local dependencies:  variable f depends on: x, g, ;  variable g depends on: f, ;  variable h depends on: g, ; . All dependencies recursively:  variable f depends on: x, ;  f --> g -->  ... then f again,  variable g depends on: x, ;  g --> f -->  ... then g again,  variable h depends on: x, ;  h --> g --> f -->  ... then g again, " && testResult[1] === "" && testResult[2] === "// f is part of a cyclic dependency, no code generated.\n// g is part of a cyclic dependency, no code generated.\n// h is part of a cyclic dependency, no code generated.") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('f = x+1\n g = f + y\n h = g')[0] === "All local dependencies:  variable f depends on: x, ;  variable g depends on: f, y, ;  variable h depends on: g, ; . All dependencies recursively:  variable f depends on: x, ;  variable g depends on: x, y, ;  variable h depends on: x, y, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('g = h(x,y)')[0] === "All local dependencies:  variable g depends on: h, x, y, ; . All dependencies recursively:  variable g depends on: h, x, y, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('f(x,y) = k')[0] === "All local dependencies:  variable f depends on: 'x, 'y, k, ; . All dependencies recursively:  variable f depends on: 'x, 'y, k, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('x = z\n f(x,y) = k')[0] === "All local dependencies:  variable x depends on: z, ;  variable f depends on: 'x, 'y, k, ; . All dependencies recursively:  variable x depends on: z, ;  variable f depends on: 'x, 'y, k, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('x = z\n g = f(x,y)')[0] === "All local dependencies:  variable x depends on: z, ;  variable g depends on: f, x, y, ; . All dependencies recursively:  variable x depends on: z, ;  variable g depends on: f, z, y, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    if (findDependenciesInScript('x = 1\n x = y\n x = z')[0] === "All local dependencies:  variable x depends on: y, z, ; . All dependencies recursively:  variable x depends on: y, z, ; ") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test");
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = y*y');
    if (testResult[0] === "All local dependencies:  variable x depends on: y, ; . All dependencies recursively:  variable x depends on: y, ; " && testResult[1] === "" && testResult[2] === "x = function (y) { return ( Math.pow(y, 2) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = -sqrt(2)/2');
    if (testResult[0] === "All local dependencies:  variable x depends on: sqrt, ; . All dependencies recursively:  variable x depends on: sqrt, ; " && testResult[1] === "" && testResult[2] === "x = function (sqrt) { return ( -1/2*Math.pow(2, (1/2)) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = 2^(1/2-a)*2^a/10');
    if (testResult[0] === "All local dependencies:  variable x depends on: a, ; . All dependencies recursively:  variable x depends on: a, ; " && testResult[1] === "" && testResult[2] === "x = function (a) { return ( 1/10*Math.pow(2, (1/2)) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = rationalize(t*y/(t+y)+2*t^2*y*(2*t+y)^(-2))');
    if (testResult[0] === "All local dependencies:  variable x depends on: t, y, ; . All dependencies recursively:  variable x depends on: t, y, ; " && testResult[1] === "" && testResult[2] === "x = function (t, y) { return ( t*y*(6*Math.pow(t, 2) + Math.pow(y, 2) + 6*t*y) / ((t + y)*Math.pow((2*t + y), 2)) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = mag((a+i*b)/(c+i*d))');
    if (testResult[0] === "All local dependencies:  variable x depends on: a, b, c, d, ; . All dependencies recursively:  variable x depends on: a, b, c, d, ; " && testResult[1] === "" && testResult[2] === "x = function (a, b, c, d) { return ( Math.pow((Math.pow(a, 2) + Math.pow(b, 2)), (1/2)) / (Math.pow((Math.pow(c, 2) + Math.pow(d, 2)), (1/2))) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = sin(1/10)^2 + cos(1/10)^2 + y');
    if (testResult[0] === "All local dependencies:  variable x depends on: y, ; . All dependencies recursively:  variable x depends on: y, ; " && testResult[1] === "" && testResult[2] === "x = function (y) { return ( 1 + y ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('x = sin(1/10)^2 + cos(1/10)^2');
    if (testResult[0] === "All local dependencies:  variable x depends on: ; . All dependencies recursively:  variable x depends on: ; " && testResult[1] === "" && testResult[2] === "x = 1;") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f(x) = x * x');
    if (testResult[0] === "All local dependencies:  variable f depends on: 'x, x, ; . All dependencies recursively:  variable f depends on: 'x, x, ; " && testResult[1] === "" && testResult[2] === "f = function (x) { return ( x*x ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f(x) = x * x + g(y)');
    if (testResult[0] === "All local dependencies:  variable f depends on: 'x, x, g, y, ; . All dependencies recursively:  variable f depends on: 'x, x, g, y, ; " && testResult[1] === "" && testResult[2] === "f = function (x, g, y) { return ( g(y) + Math.pow(x, 2) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('y = 2\nf(x) = x * x + g(y)');
    if (testResult[0] === "All local dependencies:  variable y depends on: ;  variable f depends on: 'x, x, g, y, ; . All dependencies recursively:  variable y depends on: ;  variable f depends on: 'x, x, g, ; " && testResult[1] === "" && testResult[2] === "y = 2;\nf = function (x, g) { return ( g(2) + Math.pow(x, 2) ); }") {
      console.log("ok dependency test");
    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('g(x) = x + 2\ny = 2\nf(x) = x * x + g(y)');
    if (testResult[0] === "All local dependencies:  variable g depends on: 'x, x, ;  variable y depends on: ;  variable f depends on: 'x, x, g, y, ; . All dependencies recursively:  variable g depends on: 'x, x, ;  variable y depends on: ;  variable f depends on: 'x, x, ; " && testResult[1] === "" && testResult[2] === "g = function (x) { return ( 2 + x ); }\ny = 2;\nf = function (x) { return ( 4 + Math.pow(x, 2) ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('g(x) = x + 2\nf(x) = x * x + g(y)');
    if (testResult[0] === "All local dependencies:  variable g depends on: 'x, x, ;  variable f depends on: 'x, x, g, y, ; . All dependencies recursively:  variable g depends on: 'x, x, ;  variable f depends on: 'x, x, y, ; " && testResult[1] === "" && testResult[2] === "g = function (x) { return ( 2 + x ); }\nf = function (x, y) { return ( 2 + y + Math.pow(x, 2) ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();

    /*
    	testResult = findDependenciesInScript('g(x) = f(x)\nf(x)=g(x)')
    	if testResult[0] == "All local dependencies:  variable g depends on: 'x, f, x, ;  variable f depends on: 'x, g, x, ; . All dependencies recursively:  variable g depends on: 'x, x, ;  g --> f -->  ... then g again,  variable f depends on: 'x, x, ;  f --> g -->  ... then f again, " and
    		testResult[1] == "" and
    		testResult[2] == "// g is part of a cyclic dependency, no code generated.\n// f is part of a cyclic dependency, no code generated."
    	else
    			console.log "fail dependency test. expected: " + testResult

    	clear_symbols(); defn()
     */
    testResult = findDependenciesInScript('f = roots(a*x^2 + b*x + c, x)');
    if (testResult[0] === "All local dependencies:  variable f depends on: a, b, c, ; . All dependencies recursively:  variable f depends on: a, b, c, ; " && testResult[1] === "" && testResult[2] === "f = function (a, b, c) { return ( [-1/2*(Math.pow((Math.pow(b, 2) / (Math.pow(a, 2)) - 4*c / a), (1/2)) + b / a),1/2*(Math.pow((Math.pow(b, 2) / (Math.pow(a, 2)) - 4*c / a), (1/2)) - b / a)] ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = roots(a*x^2 + b*x + c)');
    if (testResult[0] === "All local dependencies:  variable f depends on: a, b, c, ; . All dependencies recursively:  variable f depends on: a, b, c, ; " && testResult[1] === "" && testResult[2] === "f = function (a, b, c) { return ( [-1/2*(Math.pow((Math.pow(b, 2) / (Math.pow(a, 2)) - 4*c / a), (1/2)) + b / a),1/2*(Math.pow((Math.pow(b, 2) / (Math.pow(a, 2)) - 4*c / a), (1/2)) - b / a)] ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = roots(integral(a*x + b))');
    if (testResult[0] === "All local dependencies:  variable f depends on: a, b, ; . All dependencies recursively:  variable f depends on: a, b, ; " && testResult[1] === "" && testResult[2] === "f = function (a, b) { return ( [0,-2*b / a] ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = roots(defint(a*x + y,y,0,1))');
    if (testResult[0] === "All local dependencies:  variable f depends on: a, ; . All dependencies recursively:  variable f depends on: a, ; " && testResult[1] === "" && testResult[2] === "f = function (a) { return ( -1 / (2*a) ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = roots(defint(a*x + y + z,y,0,1, z, 0, 1))');
    if (testResult[0] === "All local dependencies:  variable f depends on: a, ; . All dependencies recursively:  variable f depends on: a, ; " && testResult[1] === "" && testResult[2] === "f = function (a) { return ( -1 / a ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = defint(2*x - 3*y,x,0,2*y)');
    if (testResult[0] === "All local dependencies:  variable f depends on: y, ; . All dependencies recursively:  variable f depends on: y, ; " && testResult[1] === "" && testResult[2] === "f = function (y) { return ( -2*Math.pow(y, 2) ); }") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    clear_symbols();
    defn();
    testResult = findDependenciesInScript('f = defint(12 - x^2 - (y^2)/2,x,0,2,y,0,3)');
    if (testResult[0] === "All local dependencies:  variable f depends on: ; . All dependencies recursively:  variable f depends on: ; " && testResult[1] === "" && testResult[2] === "f = 55;") {

    } else {
      console.log("fail dependency test. expected: " + testResult);
    }
    return console.log("-- done dependency tests");
  };

  findDependenciesInScript = function(stringToBeParsed) {
    var ae, af, ag, ah, aj, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, error, error1, generatedBody, generatedCode, i, indexOfPartRemainingToBeParsed, inited, key, len, len1, len2, len3, len4, n, parameters, readableSummaryOfGeneratedCode, recursedDependencies, scriptEvaluation, testableString, toBePrinted, value, variablesWithCycles;
    if (DEBUG) {
      console.log("stringToBeParsed: " + stringToBeParsed);
    }
    inited = true;
    symbolsDependencies = {};
    indexOfPartRemainingToBeParsed = 0;
    allReturnedPlainStrings = "";
    n = 0;
    while (1.) {
      try {
        errorMessage = "";
        check_stack();
        if (DEBUG) {
          console.log("findDependenciesInScript: scanning");
        }
        n = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));
        if (DEBUG) {
          console.log("scanned");
        }
        pop();
        check_stack();
      } catch (error1) {
        error = error1;
        if (PRINTOUTRESULT) {
          console.log(error);
        }
        allReturnedPlainStrings += error.message;
        init();
        break;
      }
      if (n === 0) {
        break;
      }
      indexOfPartRemainingToBeParsed += n;
    }
    testableString = "";
    if (DEBUG) {
      console.log("all local dependencies ----------------");
    }
    testableString += "All local dependencies: ";
    for (key in symbolsDependencies) {
      value = symbolsDependencies[key];
      if (DEBUG) {
        console.log("variable " + key + " depends on: ");
      }
      testableString += " variable " + key + " depends on: ";
      for (ae = 0, len = value.length; ae < len; ae++) {
        i = value[ae];
        if (DEBUG) {
          console.log("		" + i);
        }
        testableString += i + ", ";
      }
      testableString += "; ";
    }
    testableString += ". ";
    if (DEBUG) {
      console.log("All dependencies recursively ----------------");
    }
    testableString += "All dependencies recursively: ";
    scriptEvaluation = run(stringToBeParsed, true);
    generatedCode = "";
    readableSummaryOfGeneratedCode = "";
    for (key in symbolsDependencies) {
      codeGen = true;
      if (DEBUG) {
        console.log("	variable " + key + " is: " + get_binding(usr_symbol(key)).toString());
      }
      codeGen = false;
      if (DEBUG) {
        console.log("	variable " + key + " depends on: ");
      }
      testableString += " variable " + key + " depends on: ";
      recursedDependencies = [];
      variablesWithCycles = [];
      cyclesDescriptions = [];
      recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);
      for (af = 0, len1 = variablesWithCycles.length; af < len1; af++) {
        i = variablesWithCycles[af];
        if (DEBUG) {
          console.log("		--> cycle through " + i);
        }
      }
      for (ag = 0, len2 = recursedDependencies.length; ag < len2; ag++) {
        i = recursedDependencies[ag];
        if (DEBUG) {
          console.log("		" + i);
        }
        testableString += i + ", ";
      }
      testableString += "; ";
      for (ah = 0, len3 = cyclesDescriptions.length; ah < len3; ah++) {
        i = cyclesDescriptions[ah];
        testableString += " " + i + ", ";
      }
      if (DEBUG) {
        console.log("	code generation:" + key + " is: " + get_binding(usr_symbol(key)).toString());
      }
      push(get_binding(usr_symbol(key)));
      simplifyForCodeGeneration();
      toBePrinted = pop();
      codeGen = true;
      generatedBody = toBePrinted.toString();
      codeGen = false;
      bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();
      if (variablesWithCycles.indexOf(key) !== -1) {
        generatedCode += "// " + key + " is part of a cyclic dependency, no code generated.";
        readableSummaryOfGeneratedCode += "#" + key + " is part of a cyclic dependency, no code generated.";
      } else {
        if (recursedDependencies.length !== 0) {
          parameters = "(";
          for (aj = 0, len4 = recursedDependencies.length; aj < len4; aj++) {
            i = recursedDependencies[aj];
            if (i.indexOf("'") === -1) {
              parameters += i + ", ";
            }
          }
          parameters = parameters.replace(/, $/gm, "");
          parameters += ")";
          generatedCode += key + " = function " + parameters + " { return ( " + generatedBody + " ); }";
          readableSummaryOfGeneratedCode += key + parameters + " = " + bodyForReadableSummaryOfGeneratedCode;
        } else {
          generatedCode += key + " = " + generatedBody + ";";
          readableSummaryOfGeneratedCode += key + " = " + bodyForReadableSummaryOfGeneratedCode;
        }
      }
      generatedCode += "\n";
      readableSummaryOfGeneratedCode += "\n";
      if (DEBUG) {
        console.log("		" + generatedCode);
      }
    }
    generatedCode = generatedCode.replace(/\n$/gm, "");
    readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\n$/gm, "");
    symbolsDependencies = {};
    if (DEBUG) {
      console.log("testable string: " + testableString);
    }
    return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1]];
  };

  recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {
    var ae, af, cyclesDescription, i, k, len, len1, ref2;
    variablesAlreadyFleshedOut.push(variableToBeChecked);
    chainBeingChecked.push(variableToBeChecked);
    if (symbolsDependencies[variableToBeChecked] == null) {
      if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {
        arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);
      }
      return arrayWhereDependenciesWillBeAdded;
    } else {
      ref2 = symbolsDependencies[variableToBeChecked];
      for (ae = 0, len = ref2.length; ae < len; ae++) {
        i = ref2[ae];
        if (chainBeingChecked.indexOf(i) !== -1) {
          if (DEBUG) {
            console.log("	found cycle:");
          }
          cyclesDescription = "";
          for (af = 0, len1 = chainBeingChecked.length; af < len1; af++) {
            k = chainBeingChecked[af];
            if (variablesWithCycles.indexOf(k) === -1) {
              variablesWithCycles.push(k);
            }
            if (DEBUG) {
              console.log(k + " --> ");
            }
            cyclesDescription += k + " --> ";
          }
          if (DEBUG) {
            console.log(" ... then " + i + " again");
          }
          cyclesDescription += " ... then " + i + " again";
          cyclesDescriptions.push(cyclesDescription);
          if (variablesWithCycles.indexOf(i) === -1) {
            variablesWithCycles.push(i);
          }
        } else {
          recursiveDependencies(i, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);
          chainBeingChecked.pop();
        }
      }
      return arrayWhereDependenciesWillBeAdded;
    }
  };

  inited = false;

  run = function(stringToBeRun, generateLatex) {
    var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, error1, error2, i, indexOfPartRemainingToBeParsed, n;
    if (generateLatex == null) {
      generateLatex = false;
    }
    stringToBeRun = stringToBeRun;
    if (stringToBeRun === "selftest") {
      selftest();
      return;
    }
    if (!inited) {
      inited = true;
      init();
    }
    i = 0;
    n = 0;
    indexOfPartRemainingToBeParsed = 0;
    allReturnedPlainStrings = "";
    if (generateLatex) {
      allReturnedLatexStrings = "";
    }
    while (1.) {
      try {
        errorMessage = "";
        check_stack();
        n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));
        p1 = pop();
        check_stack();
      } catch (error1) {
        error = error1;
        if (PRINTOUTRESULT) {
          console.log(error);
        }
        allReturnedPlainStrings += error.message;
        if (generateLatex) {
          allReturnedLatexStrings += "$$\\text{" + error.message + "}$$";
        }
        init();
        break;
      }
      if (n === 0) {
        break;
      }
      indexOfPartRemainingToBeParsed += n;
      push(p1);
      try {
        top_level_eval();
        p2 = pop();
        check_stack();
        if (p2 === symbol(NIL)) {
          continue;
        }
        if (isstr(p2)) {
          if (DEBUG) {
            console.log(p2.str);
          }
          if (DEBUG) {
            console.log("\n");
          }
          continue;
        }
        collectedPlainResult = collectPlainResultLine(p2);
        if (generateLatex) {
          collectedLatexResult = "$$" + collectLatexResultLine(p2) + "$$";
          if (DEBUG) {
            console.log("collectedLatexResult: " + collectedLatexResult);
          }
        }
        allReturnedPlainStrings += collectedPlainResult;
        if (generateLatex) {
          allReturnedLatexStrings += collectedLatexResult;
        }
        if (PRINTOUTRESULT) {
          if (DEBUG) {
            console.log("printline");
          }
          if (DEBUG) {
            console.log(collectedPlainResult);
          }
        }
        if (PRINTOUTRESULT) {
          if (DEBUG) {
            console.log("display:");
          }
          display(p2);
        }
        allReturnedPlainStrings += "\n";
        if (generateLatex) {
          allReturnedLatexStrings += "\n";
        }
      } catch (error2) {
        error = error2;
        collectedPlainResult = error.message;
        if (generateLatex) {
          collectedLatexResult = "$$\\text{" + error.message + "}$$";
        }
        if (PRINTOUTRESULT) {
          console.log(collectedPlainResult);
        }
        allReturnedPlainStrings += collectedPlainResult;
        allReturnedPlainStrings += "\n";
        if (generateLatex) {
          allReturnedLatexStrings += collectedLatexResult;
          allReturnedLatexStrings += "\n";
        }
        init();
      }
    }
    if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === "\n") {
      allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);
    }
    if (generateLatex) {
      if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === "\n") {
        allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);
      }
    }
    if (generateLatex) {
      if (DEBUG) {
        console.log("allReturnedLatexStrings: " + allReturnedLatexStrings);
      }
      return [allReturnedPlainStrings, allReturnedLatexStrings];
    } else {
      return allReturnedPlainStrings;
    }
  };

  check_stack = function() {
    if (tos !== 0) {
      debugger;
      stop("stack error");
    }
    if (frame !== TOS) {
      debugger;
      return stop("frame error");
    }
  };

  echo_input = function(s) {
    console.log(s);
    return console.log("\n");
  };

  top_level_eval = function() {
    var doNothing;
    if (DEBUG) {
      console.log("#### top level eval");
    }
    save();
    trigmode = 0;
    p1 = symbol(AUTOEXPAND);
    if (iszero(get_binding(p1))) {
      expanding = 0;
    } else {
      expanding = 1;
    }
    p1 = pop();
    push(p1);
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push(p2);
      restore();
      return;
    }
    set_binding(symbol(LAST), p2);
    if (!iszero(get_binding(symbol(BAKE)))) {
      push(p2);
      bake();
      p2 = pop();
    }
    if ((p1 === symbol(SYMBOL_I) || p1 === symbol(SYMBOL_J)) && isimaginaryunit(p2)) {
      doNothing = 0;
    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
      push(p2);
      push(imaginaryunit);
      push_symbol(SYMBOL_J);
      subst();
      p2 = pop();
    } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
      push(p2);
      push(imaginaryunit);
      push_symbol(SYMBOL_I);
      subst();
      p2 = pop();
    }
    push(p2);
    return restore();
  };

  check_esc_flag = function() {
    if (esc_flag) {
      return stop("esc key");
    }
  };

  computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {
    var code, latexResult, readableSummaryOfCode, ref2, result, testableStringIsIgnoredHere;
    clear_symbols();
    defn();
    ref2 = findDependenciesInScript(codeFromAlgebraBlock), testableStringIsIgnoredHere = ref2[0], result = ref2[1], code = ref2[2], readableSummaryOfCode = ref2[3], latexResult = ref2[4];
    if (readableSummaryOfCode !== "") {
      result += "\n" + readableSummaryOfCode;
      result = result.replace(/\n/g, "\n\n");
      latexResult += "\n" + "$$" + readableSummaryOfCode + "$$";
      latexResult = latexResult.replace(/\n/g, "\n\n");
    }
    code = code.replace(/Math\./g, "");
    code = code.replace(/\n/g, "\n\n");
    return {
      code: code,
      result: latexResult,
      latexResult: latexResult
    };
  };

  (typeof exports !== "undefined" && exports !== null ? exports : this).run = run;

  (typeof exports !== "undefined" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;

  (typeof exports !== "undefined" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;

  tos = 0;

  nil_symbols = 0;

  push = function(p) {
    if (p == null) {
      debugger;
    }
    if (p.isZero != null) {
      debugger;
    }
    if (p === symbol(NIL)) {
      nil_symbols++;
      if (DEBUG) {
        console.log("pushing symbol(NIL) #" + nil_symbols);
      }
    }
    if (tos >= frame) {
      stop("stack overflow");
    }
    return stack[tos++] = p;
  };

  pop = function() {
    var elementToBeReturned;
    if (tos === 0) {
      debugger;
      stop("stack underflow");
    }
    if (stack[tos - 1] == null) {
      debugger;
    }
    elementToBeReturned = stack[--tos];
    return elementToBeReturned;
  };

  push_frame = function(n) {
    var ae, i, ref2, results;
    i = 0;
    frame -= n;
    if (frame < tos) {
      debugger;
      stop("frame overflow, circular reference?");
    }
    results = [];
    for (i = ae = 0, ref2 = n; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      results.push(stack[frame + i] = symbol(NIL));
    }
    return results;
  };

  pop_frame = function(n) {
    frame += n;
    if (frame > TOS) {
      return stop("frame underflow");
    }
  };

  save = function() {
    frame -= 10;
    if (frame < tos) {
      debugger;
      stop("frame overflow, circular reference?");
    }
    stack[frame + 0] = p0;
    stack[frame + 1] = p1;
    stack[frame + 2] = p2;
    stack[frame + 3] = p3;
    stack[frame + 4] = p4;
    stack[frame + 5] = p5;
    stack[frame + 6] = p6;
    stack[frame + 7] = p7;
    stack[frame + 8] = p8;
    return stack[frame + 9] = p9;
  };

  restore = function() {
    if (frame > TOS - 10) {
      stop("frame underflow");
    }
    p0 = stack[frame + 0];
    p1 = stack[frame + 1];
    p2 = stack[frame + 2];
    p3 = stack[frame + 3];
    p4 = stack[frame + 4];
    p5 = stack[frame + 5];
    p6 = stack[frame + 6];
    p7 = stack[frame + 7];
    p8 = stack[frame + 8];
    p9 = stack[frame + 9];
    return frame += 10;
  };

  swap = function() {
    var p, q;
    p = pop();
    q = pop();
    push(p);
    return push(q);
  };

  dupl = function() {
    var p;
    p = pop();
    push(p);
    return push(p);
  };

  $.dupl = dupl;

  $.swap = swap;

  $.restore = restore;

  $.save = save;

  $.push = push;

  $.pop = pop;

  std_symbol = function(s, n, latexPrint) {
    var p;
    p = symtab[n];
    if (p == null) {
      debugger;
    }
    p.printname = s;
    if (latexPrint != null) {
      return p.latexPrint = latexPrint;
    } else {
      return p.latexPrint = s;
    }
  };

  usr_symbol = function(s) {
    var ae, i, p, ref2;
    i = 0;
    for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      if (symtab[i].printname === "") {
        break;
      }
      if (s === symtab[i].printname) {
        return symtab[i];
      }
    }
    if (i === NSYM) {
      stop("symbol table overflow");
    }
    p = symtab[i];
    p.printname = s;
    return p;
  };

  get_printname = function(p) {
    if (p.k !== SYM) {
      stop("symbol error");
    }
    return p.printname;
  };

  set_binding = function(p, q) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> set_binding lookup " + indexFound);
    }
    return binding[indexFound] = q;
  };

  get_binding = function(p) {
    var indexFound;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> get_binding lookup " + indexFound);
    }
    return binding[indexFound];
  };

  lookupsTotal = 0;

  symnum = function(p) {
    var indexFound;
    lookupsTotal++;
    if (p.k !== SYM) {
      stop("symbol error");
    }
    indexFound = symtab.indexOf(p);
    if (symtab.indexOf(p, indexFound + 1) !== -1) {
      console.log("ops, more than one element!");
      debugger;
    }
    if (DEBUG) {
      console.log("lookup >> symnum lookup " + indexFound + " lookup # " + lookupsTotal);
    }
    return indexFound;
  };

  push_symbol = function(k) {
    return push(symtab[k]);
  };

  clear_symbols = function() {
    var ae, i, ref2, results;
    i = 0;
    results = [];
    for (i = ae = 0, ref2 = NSYM; 0 <= ref2 ? ae < ref2 : ae > ref2; i = 0 <= ref2 ? ++ae : --ae) {
      results.push(binding[i] = symtab[i]);
    }
    return results;
  };

  $.get_binding = get_binding;

  $.set_binding = set_binding;

  $.usr_symbol = usr_symbol;

  if (!inited) {
    inited = true;
    init();
  }

  $.init = init;

  parse_internal = function(argu) {
    if (typeof argu === 'string') {
      return scan(argu);
    } else if (typeof argu === 'number') {
      if (argu % 1 === 0) {
        return push_integer(argu);
      } else {
        return push_double(argu);
      }
    } else if (argu instanceof U) {
      return push(argu);
    } else {
      console.warn('unknown argument type', argu);
      return push(symbol(NIL));
    }
  };

  parse = function(argu) {
    var data, error, error1;
    try {
      parse_internal(argu);
      data = pop();
      check_stack();
    } catch (error1) {
      error = error1;
      reset_after_error();
      throw error;
    }
    return data;
  };

  exec = function() {
    var ae, argu, argus, error, error1, fn, len, name, result;
    name = arguments[0], argus = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    fn = get_binding(usr_symbol(name));
    check_stack();
    push(fn);
    for (ae = 0, len = argus.length; ae < len; ae++) {
      argu = argus[ae];
      parse_internal(argu);
    }
    list(1 + argus.length);
    p1 = pop();
    push(p1);
    try {
      fixed_top_level_eval();
      result = pop();
      check_stack();
    } catch (error1) {
      error = error1;
      reset_after_error();
      throw error;
    }
    return result;
  };

  reset_after_error = function() {
    tos = 0;
    esc_flag = 0;
    draw_flag = 0;
    return frame = TOS;
  };

  fixed_top_level_eval = function() {
    save();
    trigmode = 0;
    p1 = symbol(AUTOEXPAND);
    if (iszero(get_binding(p1))) {
      expanding = 0;
    } else {
      expanding = 1;
    }
    p1 = pop();
    push(p1);
    Eval();
    p2 = pop();
    if (p2 === symbol(NIL)) {
      push(p2);
      restore();
      return;
    }
    if (!iszero(get_binding(symbol(BAKE)))) {
      push(p2);
      bake();
      p2 = pop();
    }
    push(p2);
    return restore();
  };

  $.exec = exec;

  $.parse = parse;

  (function() {
    var ae, builtin_fns, fn, len, results;
    builtin_fns = ["abs", "add", "pattern", "adj", "and", "arccos", "arccosh", "arcsin", "arcsinh", "arctan", "arctanh", "arg", "atomize", "besselj", "bessely", "binding", "binomial", "ceiling", "check", "choose", "circexp", "clear", "clearsubstrules", "clock", "coeff", "cofactor", "condense", "conj", "contract", "cos", "cosh", "decomp", "defint", "deg", "denominator", "det", "derivative", "dim", "dirac", "display", "divisors", "do", "dot", "draw", "dsolve", "eigen", "eigenval", "eigenvec", "erf", "erfc", "eval", "exp", "expand", "expcos", "expsin", "factor", "factorial", "factorpoly", "filter", "float", "floor", "for", "Gamma", "gcd", "hermite", "hilbert", "imag", "component", "inner", "integral", "inv", "invg", "isinteger", "isprime", "laguerre", "lcm", "leading", "legendre", "log", "mag", "mod", "multiply", "not", "nroots", "number", "numerator", "operator", "or", "outer", "polar", "power", "prime", "print", "product", "quote", "quotient", "rank", "rationalize", "real", "rect", "roots", "equals", "shape", "sgn", "simplify", "sin", "sinh", "sqrt", "stop", "subst", "sum", "tan", "tanh", "taylor", "test", "testeq", "testge", "testgt", "testle", "testlt", "transpose", "unit", "zero"];
    results = [];
    for (ae = 0, len = builtin_fns.length; ae < len; ae++) {
      fn = builtin_fns[ae];
      results.push($[fn] = exec.bind(this, fn));
    }
    return results;
  })();

}).call(this);
